[
    {
        "commit_time": "2021-03-19 12:06:36-07:00",
        "diff": "mmm ShadowBugreportManagerTest . java <nl> ppp ShadowBugreportManagerTest . java <nl> + @Test <nl> + public void requestBugreport() { <nl> + shadowBugreportManager . requestBugreport( <nl> + new BugreportParams(BugreportParams . BUGREPORT_MODE_INTERACTIVE), title, description) ; <nl> + assertThat(shadowBugreportManager . wasBugreportRequested()) . isTrue() ; <nl> + } <nl> mmm ShadowBugreportManager . java <nl> ppp ShadowBugreportManager . java <nl> + import static android . os . Build . VERSION_CODES . R ; <nl> + private boolean bugreportRequested ; <nl> + @Implementation(minSdk = R) <nl> + protected void requestBugreport( <nl> + BugreportParams params, CharSequence shareTitle, CharSequence shareDescription) { <nl> + this . bugreportRequested = true ; <nl> + } <nl> + public boolean wasBugreportRequested() { <nl> + return bugreportRequested ; <nl> + } <nl> + bugreportRequested = false ; <nl>",
        "commit_message": "added bugreport request functionality and tests in ShadowBugreportManager to enhance the bugreporting feature and ensure it operates correctly through unit tests",
        "what": "added bugreport request functionality and tests in ShadowBugreportManager",
        "why": "enhance the bugreporting feature and ensure it operates correctly through unit tests",
        "check": "1"
    },
    {
        "commit_time": "2014-07-19 10:09:00+00:00",
        "diff": "mmm TestExternalLinksTable . java <nl> ppp TestExternalLinksTable . java <nl> + @Test <nl> + public void readWithReferencesToTwoExternalBooks() { <nl> + XSSFWorkbook wb = XSSFTestDataSamples . openSampleWorkbook(ref2-56737 . xlsx) ; <nl> + } <nl>",
        "commit_message": "turn out that .xlsx file can have multiple link table , add a test file which show this ( support to follow )",
        "what": "add a test file which shows that .xlsx file can have multiple link tables",
        "why": "support to follow",
        "check": "1"
    },
    {
        "commit_time": "2021-11-17 09:19:46-05:00",
        "diff": "mmm AutoDetectParser . java <nl> ppp AutoDetectParser . java <nl> - public SecureContentHandlerConfig( <nl> - Long maxOutputThreshold, <nl> - Long maxCompressionRatio, <nl> - Integer maxDepth, <nl> - Integer maxPackageEntryDepth) { <nl> - this . maxOutputThreshold = maxOutputThreshold ; <nl> - this . maxCompressionRatio = maxCompressionRatio ; <nl> - this . maxDepth = maxDepth ; <nl> - this . maxPackageEntryDepth = maxPackageEntryDepth ; <nl> - } <nl> - public final Long maxOutputThreshold ; <nl> + public final Long outputThreshold ; <nl> - public final Long maxCompressionRatio ; <nl> + public final Long maximumCompressionRatio ; <nl> - public final Integer maxDepth ; <nl> + public final Integer maximumDepth ; <nl> - public final Integer maxPackageEntryDepth ; <nl> + public final Integer maximumPackageEntryDepth ; <nl> + public SecureContentHandlerConfig(Long outputThreshold, Long maximumCompressionRatio, <nl> + Integer maximumDepth, <nl> + Integer maximumPackageEntryDepth) { <nl> + this . outputThreshold = outputThreshold ; <nl> + this . maximumCompressionRatio = maximumCompressionRatio ; <nl> + this . maximumDepth = maximumDepth ; <nl> + this . maximumPackageEntryDepth = maximumPackageEntryDepth ; <nl> + } <nl> - public void setSecureContentHandlerConfig( <nl> - SecureContentHandlerConfig secureContentHandlerConfig) { <nl> + public void setSecureContentHandlerConfig(SecureContentHandlerConfig secureContentHandlerConfig) { <nl> - private SecureContentHandler createSecureContentHandler( <nl> - ContentHandler handler, <nl> - TikaInputStream tis, <nl> - SecureContentHandlerConfig config) { <nl> + private SecureContentHandler createSecureContentHandler(ContentHandler handler, TikaInputStream tis, <nl> + SecureContentHandlerConfig config) { <nl> - if (config . maxOutputThreshold != null) { <nl> - sch . setMaximumCompressionRatio(config . maxOutputThreshold) ; <nl> + if (config . outputThreshold != null) { <nl> + sch . setOutputThreshold(config . outputThreshold) ; <nl> - if (config . maxCompressionRatio != null) { <nl> - sch . setMaximumCompressionRatio(config . maxCompressionRatio) ; <nl> + if (config . maximumCompressionRatio != null) { <nl> + sch . setMaximumCompressionRatio(config . maximumCompressionRatio) ; <nl> - if (config . maxDepth != null) { <nl> - sch . setMaximumCompressionRatio(config . maxDepth) ; <nl> + if (config . maximumDepth != null) { <nl> + sch . setMaximumDepth(config . maximumDepth) ; <nl> - if (config . maxPackageEntryDepth != null) { <nl> - sch . setMaximumCompressionRatio(config . maxPackageEntryDepth) ; <nl> + if (config . maximumPackageEntryDepth != null) { <nl> + sch . setMaximumPackageEntryDepth(config . maximumPackageEntryDepth) ; <nl>",
        "commit_message": "tika-3594 -- preliminary work ... fix setter bug in original pr , fix checkstyle and rename variable to be the same a in securecontenthandler",
        "what": "fix setter bug in original pr, fix checkstyle and rename variable to be the same as in securecontenthandler",
        "why": "preliminary work",
        "check": "0"
    },
    {
        "commit_time": "2016-02-22 09:52:06+00:00",
        "diff": "mmm ExceptionHandler . java <nl> ppp ExceptionHandler . java <nl> - public interface ExceptionHandler <nl> + public interface ExceptionConsumer <nl> - void onException( <nl> - int observationCount, long firstObservationTimestamp, long lastObservationTimestamp, String encodedException) ; <nl> + void accept(int observationCount, long firstObservationTimestamp, long lastObservationTimestamp, String encodedException) ; <nl> mmm ExceptionLogReader . java <nl> ppp ExceptionLogReader . java <nl> - public static int read(final AtomicBuffer buffer, final ExceptionHandler handler) <nl> + public static int read(final AtomicBuffer buffer, final ExceptionConsumer consumer) <nl> - return read(buffer, handler, 0) ; <nl> + return read(buffer, consumer, 0) ; <nl> - public static int read(final AtomicBuffer buffer, final ExceptionHandler handler, final long sinceTimestamp) <nl> + public static int read(final AtomicBuffer buffer, final ExceptionConsumer consumer, final long sinceTimestamp) <nl> - handler . onException( <nl> + consumer . accept( <nl> mmm ExceptionLogReaderTest . java <nl> ppp ExceptionLogReaderTest . java <nl> - final ExceptionHandler handler = mock(ExceptionHandler . class) ; <nl> + final ExceptionConsumer consumer = mock(ExceptionConsumer . class) ; <nl> - assertThat(ExceptionLogReader . read(buffer, handler), is(0)) ; <nl> + assertThat(ExceptionLogReader . read(buffer, consumer), is(0)) ; <nl> - verifyZeroInteractions(handler) ; <nl> + verifyZeroInteractions(consumer) ; <nl> - final ExceptionHandler handler = mock(ExceptionHandler . class) ; <nl> + final ExceptionConsumer consumer = mock(ExceptionConsumer . class) ; <nl> - assertThat(ExceptionLogReader . read(buffer, handler), is(1)) ; <nl> + assertThat(ExceptionLogReader . read(buffer, consumer), is(1)) ; <nl> - verify(handler) . onException(eq(1), eq(timestamp), eq(timestamp), any(String . class)) ; <nl> + verify(consumer) . accept(eq(1), eq(timestamp), eq(timestamp), any(String . class)) ; <nl> - final ExceptionHandler handler = mock(ExceptionHandler . class) ; <nl> + final ExceptionConsumer consumer = mock(ExceptionConsumer . class) ; <nl> - assertThat(ExceptionLogReader . read(buffer, handler), is(1)) ; <nl> + assertThat(ExceptionLogReader . read(buffer, consumer), is(1)) ; <nl> - verify(handler) . onException(eq(2), eq(timestampOne), eq(timestampTwo), any(String . class)) ; <nl> + verify(consumer) . accept(eq(2), eq(timestampOne), eq(timestampTwo), any(String . class)) ; <nl> - final ExceptionHandler handler = mock(ExceptionHandler . class) ; <nl> + final ExceptionConsumer consumer = mock(ExceptionConsumer . class) ; <nl> - assertThat(ExceptionLogReader . read(buffer, handler), is(2)) ; <nl> + assertThat(ExceptionLogReader . read(buffer, consumer), is(2)) ; <nl> - final InOrder inOrder = inOrder(handler) ; <nl> - inOrder . verify(handler) . onException(eq(1), eq(timestampOne), eq(timestampOne), any(String . class)) ; <nl> - inOrder . verify(handler) . onException(eq(1), eq(timestampTwo), eq(timestampTwo), any(String . class)) ; <nl> + final InOrder inOrder = inOrder(consumer) ; <nl> + inOrder . verify(consumer) . accept(eq(1), eq(timestampOne), eq(timestampOne), any(String . class)) ; <nl> + inOrder . verify(consumer) . accept(eq(1), eq(timestampTwo), eq(timestampTwo), any(String . class)) ; <nl> - final ExceptionHandler handler = mock(ExceptionHandler . class) ; <nl> + final ExceptionConsumer consumer = mock(ExceptionConsumer . class) ; <nl> - assertThat(ExceptionLogReader . read(buffer, handler, timestampTwo), is(1)) ; <nl> + assertThat(ExceptionLogReader . read(buffer, consumer, timestampTwo), is(1)) ; <nl> - verify(handler) . onException(eq(1), eq(timestampTwo), eq(timestampTwo), any(String . class)) ; <nl> - verifyNoMoreInteractions(handler) ; <nl> + verify(consumer) . accept(eq(1), eq(timestampTwo), eq(timestampTwo), any(String . class)) ; <nl> + verifyNoMoreInteractions(consumer) ; <nl>",
        "commit_message": "[ java ] rename handler to consumer to be more inline with other functional interface .",
        "what": "rename handler to consumer",
        "why": "to be more in line with other functional interfaces",
        "check": "1"
    },
    {
        "commit_time": "2017-08-27 18:08:40+02:00",
        "diff": "mmm ProtectedTermsMenu . java <nl> ppp ProtectedTermsMenu . java <nl> + import javax . swing . SwingUtilities ; <nl> - dialog . setVisible(true) ; <nl> + SwingUtilities . invokeLater(() -> dialog . setVisible(true)) ; <nl> mmm NewProtectedTermsFileDialog . java <nl> ppp NewProtectedTermsFileDialog . java <nl> -  . runInJavaFXThread(() -> ds . showFileOpenDialog(fileDialogConfiguration)) ; <nl> +  . runInJavaFXThread(() -> ds . showFileSaveDialog(fileDialogConfiguration)) ; <nl>",
        "commit_message": "fix freeze on browse in protected term dialog when add from entry editor ( # 3158 )",
        "what": "fix freeze on browse in protected term dialog when add from entry editor",
        "why": "improve user experience by resolving the freeze issue",
        "check": "1"
    },
    {
        "commit_time": "2018-08-17 06:27:35+02:00",
        "diff": "mmm VariableReferencesTest . java <nl> ppp VariableReferencesTest . java <nl> + import spoon . reflect . visitor . filter . FieldScopeFunction ;\r <nl> + assertArrayEquals(var . map(new FieldScopeFunction()) . list() . toArray(new CtElement[0]), real) ; <nl>",
        "commit_message": "refactor : uncomment a fieldscopefunction test ( # 2331 )",
        "what": "uncomment a fieldscopefunction test",
        "why": "refactor",
        "check": "1"
    },
    {
        "commit_time": "2016-01-09 10:27:33+11:00",
        "diff": "mmm PathWatcher . java <nl> ppp PathWatcher . java <nl> - import static java . nio . file . StandardWatchEventKinds . * ; <nl> + import static java . nio . file . StandardWatchEventKinds . ENTRY_CREATE ; <nl> + import static java . nio . file . StandardWatchEventKinds . ENTRY_DELETE ; <nl> + import static java . nio . file . StandardWatchEventKinds . ENTRY_MODIFY ; <nl> - while (watchService != null) <nl> + while (watchService != null  && thread == Thread . currentThread()) <nl>",
        "commit_message": "add specific event types for file watching and update condition for the watchService loop to enhance file monitoring capabilities and ensure proper thread handling",
        "what": "add specific event types for file watching and update condition for the watchService loop",
        "why": "enhance file monitoring capabilities and ensure proper thread handling",
        "check": "1"
    },
    {
        "commit_time": "2021-01-04 12:10:36+01:00",
        "diff": "mmm NikobusPcLinkHandler . java <nl> ppp NikobusPcLinkHandler . java <nl> + if (!commandListeners . isEmpty()) { <nl> + NikobusConnection connection = this . connection ; <nl> + if (connection == null) { <nl> + return ; <nl> + } <nl> + try { <nl> + connectIfNeeded(connection) ; <nl> + } catch (IOException e) { <nl> + connection . close() ; <nl> + updateStatus(ThingStatus . OFFLINE, ThingStatusDetail . COMMUNICATION_ERROR, e . getMessage()) ; <nl> + return ; <nl> + } <nl> + } <nl>",
        "commit_message": "[ nikobus ] open connection on refresh even if no module exist ( # 9603 )",
        "what": "open connection on refresh even if no module exist",
        "why": "to ensure functionality despite the absence of a module",
        "check": "1"
    },
    {
        "commit_time": "2014-10-01 08:34:14+02:00",
        "diff": "mmm PreviewMediaFragment . java <nl> ppp PreviewMediaFragment . java <nl> + import android . net . Uri ; <nl> + @SuppressWarnings(static-access) <nl> - mVideoPreview . setVideoPath(getFile() . getStoragePath()) ;  <nl> + Uri uri = Uri . parse(getFile() . getStoragePath()) ; <nl> + mVideoPreview . setVideoPath(uri . encode(getFile() . getStoragePath())) ; <nl>",
        "commit_message": "fixed bug . video file not preview on account whose id have an space",
        "what": "fixed bug",
        "why": "video file not preview on account whose id have an space",
        "check": "1"
    },
    {
        "commit_time": "2005-03-24 15:15:58+00:00",
        "diff": "mmm ConstantAnalysis . java <nl> ppp ConstantAnalysis . java <nl> - ConstantFrame tmpFact = null ; <nl> + if (fact . isValid()) { <nl> + ConstantFrame tmpFact = null ; <nl> - if (edge . isExceptionEdge()) { <nl> - tmpFact = modifyFrame(fact, tmpFact) ; <nl> - tmpFact . clearStack() ; <nl> - tmpFact . pushValue(Constant . NOT_CONSTANT) ; <nl> - } <nl> + if (edge . isExceptionEdge()) { <nl> + tmpFact = modifyFrame(fact, tmpFact) ; <nl> + tmpFact . clearStack() ; <nl> + tmpFact . pushValue(Constant . NOT_CONSTANT) ; <nl> + } <nl> - if (tmpFact != null) { <nl> - fact = tmpFact ; <nl> + if (tmpFact != null) { <nl> + fact = tmpFact ; <nl> + } <nl>",
        "commit_message": "bugfix - do n't model an exception handler if the incoming fact",
        "what": "bugfix - do n't model an exception handler",
        "why": "if the incoming fact",
        "check": "0"
    },
    {
        "commit_time": "2017-06-06 16:34:20-07:00",
        "diff": "mmm NotificationItemView . java <nl> ppp NotificationItemView . java <nl> + import com . android . launcher3 . util . Themes ; <nl> - getResources() . getColor(R . color . popup_header_background_color)) ; <nl> + Themes . getAttrColor(getContext(), R . attr . popupColorSecondary)) ; <nl> mmm PopupContainerWithArrow . java <nl> ppp PopupContainerWithArrow . java <nl> - import android . support . v4 . content . ContextCompat ; <nl> + import com . android . launcher3 . util . Themes ; <nl> - int backgroundColor = ContextCompat . getColor(getContext(), <nl> - R . color . notification_color_beneath) ; <nl> + int backgroundColor = Themes . getAttrColor(mLauncher, R . attr . popupColorTertiary) ; <nl> - int backgroundColor = ContextCompat . getColor(getContext(), mNotificationItemView == null <nl> - ? R . color . popup_background_color <nl> - : R . color . popup_header_background_color) ; <nl> + int backgroundColor = Themes . getAttrColor(mLauncher, mNotificationItemView == null <nl> + ? R . attr . popupColorPrimary : R . attr . popupColorSecondary) ; <nl> - arrowPaint . setColor(ContextCompat . getColor(mLauncher, R . color . popup_background_color)) ; <nl> + arrowPaint . setColor(Themes . getAttrColor(mLauncher, R . attr . popupColorPrimary)) ; <nl> - int backgroundColor = ContextCompat . getColor(getContext(), <nl> - R . color . popup_background_color) ; <nl> + int backgroundColor = Themes . getAttrColor(mLauncher, R . attr . popupColorPrimary) ; <nl>",
        "commit_message": "refactor color retrieval methods to use the Themes utility class to improve consistency and maintainability of theme-related color attributes",
        "what": "refactor color retrieval methods to use the Themes utility class",
        "why": "improve consistency and maintainability of theme-related color attributes",
        "check": "1"
    },
    {
        "commit_time": "2010-03-05 09:29:13+00:00",
        "diff": "mmm HttpsAuthenticationTest . java <nl> ppp HttpsAuthenticationTest . java <nl> - Exchange exchange = template . request(https:// + getHostName() + : + getPort() + /?username=camel&password=password, new Processor() { <nl> + Exchange exchange = template . request(https://127 . 0 . 0 . 1: getPort() /?username=camel&password=password, new Processor() { <nl> mmm HttpsGetTest . java <nl> ppp HttpsGetTest . java <nl> - Exchange exchange = template . request(https:// + getHostName() + : + getPort() + /mail/, new Processor() { <nl> + Exchange exchange = template . request(https://127 . 0 . 0 . 1: getPort() /mail/, new Processor() { <nl>",
        "commit_message": "fixed unit test failure due certificate need to use 127.0.0.1 to match hostname .",
        "what": "fixed unit test failure due certificate",
        "why": "need to use 127.0.0.1 to match hostname",
        "check": "1"
    },
    {
        "commit_time": "2014-01-21 09:48:28-06:00",
        "diff": "mmm Utils . java <nl> ppp Utils . java <nl> + IOUtils . trimDatabase(context, sharedPrefs . getInt(current_account, 1)) ; <nl> - pDialog . dismiss() ; <nl> - Toast . makeText(context, Done, Toast . LENGTH_SHORT) . show() ; <nl> + try { <nl> + pDialog . dismiss() ; <nl> + Toast . makeText(context, Done, Toast . LENGTH_SHORT) . show() ; <nl> + } catch (Exception e) { <nl> + } <nl>",
        "commit_message": "trim the database on the first launch with a new version , when they update the direct message",
        "what": "trim the database on the first launch with a new version",
        "why": "when they update the direct message",
        "check": "1"
    },
    {
        "commit_time": "2020-09-29 15:39:05-04:00",
        "diff": "mmm AuthenticationHelper . java <nl> ppp AuthenticationHelper . java <nl> + import org . jellyfin . androidtv . ui . shared . KeyboardFocusChangeListener ; <nl> + address . setOnFocusChangeListener(new KeyboardFocusChangeListener()) ; <nl> + userName . setOnFocusChangeListener(new KeyboardFocusChangeListener()) ; <nl> + userPw . setOnFocusChangeListener(new KeyboardFocusChangeListener()) ; <nl>",
        "commit_message": "added KeyboardFocusChangeListener to address, userName, and userPw fields to improve focus handling for better user experience",
        "what": "added KeyboardFocusChangeListener to address, userName, and userPw fields",
        "why": "improve focus handling for better user experience",
        "check": "1"
    },
    {
        "commit_time": "2015-07-24 03:16:04-07:00",
        "diff": "mmm DebugPathSanitizer . java <nl> ppp DebugPathSanitizer . java <nl> + import com . facebook . buck . log . Logger ; <nl> + import com . google . common . cache . CacheBuilder ; <nl> + import com . google . common . cache . CacheLoader ; <nl> + import com . google . common . cache . LoadingCache ; <nl> + import java . util . concurrent . ExecutionException ; <nl> + private final LoadingCache<Path, ImmutableBiMap<Path, Path>> pathCache = <nl> + CacheBuilder <nl> +  . newBuilder() <nl> +  . softValues() <nl> +  . build(new CacheLoader<Path, ImmutableBiMap<Path, Path>>() { <nl> + @Override <nl> + public ImmutableBiMap<Path, Path> load(Path key) { <nl> + return getAllPathsWork(key) ; <nl> + } <nl> + }) ; <nl> - ImmutableBiMap . Builder<Path, Path> builder = ImmutableBiMap . builder() ; <nl> - if (workingDir . isPresent()) { <nl> - builder . put(workingDir . get(), compilationDirectory) ; <nl> + if (!workingDir . isPresent()) { <nl> + return other ; <nl> + } <nl> + try { <nl> + return pathCache . get(workingDir . get()) ; <nl> + } catch (ExecutionException e) { <nl> + Logger . get(DebugPathSanitizer . class) . error( <nl> + Problem loading paths into cache, <nl> + e) ; <nl> + return getAllPathsWork(workingDir . get()) ; <nl> + } <nl> + private ImmutableBiMap<Path, Path> getAllPathsWork(Path workingDir) { <nl> + ImmutableBiMap . Builder<Path, Path> builder = ImmutableBiMap . builder() ; <nl> + builder . put(workingDir, compilationDirectory) ; <nl> - contents = contents . replace(entry . getKey() . toString(), replacement) ; <nl> + String pathToReplace = entry . getKey() . toString() ; <nl> + if (contents . contains(pathToReplace)) { <nl> + contents = contents . replace(pathToReplace, replacement) ; <nl> + } <nl>",
        "commit_message": "added caching functionality to the DebugPathSanitizer class using LoadingCache for improved path management to enhance performance by reducing the need to repeatedly compute paths for the same working directory",
        "what": "added caching functionality to the DebugPathSanitizer class using LoadingCache for improved path management",
        "why": "enhance performance by reducing the need to repeatedly compute paths for the same working directory",
        "check": "1"
    },
    {
        "commit_time": "2020-07-18 14:16:13+00:00",
        "diff": "mmm TestCOSFloat . java <nl> ppp TestCOSFloat . java <nl> + public void testLargeNumber() throws IOException\r <nl> + {\r <nl> + COSNumber cosNumber = COSFloat . get(18446744073307448448) ;\r <nl> + assertTrue(cosNumber instanceof COSFloat) ;\r <nl> + assertEquals(1 . 8446744E19f, cosNumber . floatValue()) ;\r <nl> + } <nl>",
        "commit_message": "pdfbox-4895 : add test for number too big for a long but small enough to fit into a float",
        "what": "add test for number too big for a long but small enough to fit into a float",
        "why": "address issue pdfbox-4895",
        "check": "1"
    },
    {
        "commit_time": "2013-03-19 12:36:47+00:00",
        "diff": "mmm DesktopSharingMouseAndKeyboardListener . java <nl> ppp DesktopSharingMouseAndKeyboardListener . java <nl> - private final OperationSetDesktopSharingClient opSetDesktopSharingClient ; <nl> + private final OperationSetDesktopSharingClient desktopSharingClient ; <nl> - this . callPeer = callPeer ; <nl> + this( <nl> + callPeer, <nl> + callPeer . getProtocolProvider() . getOperationSet( <nl> + OperationSetDesktopSharingClient . class)) ; <nl> + } <nl> - opSetDesktopSharingClient <nl> - = callPeer . getProtocolProvider() . getOperationSet( <nl> - OperationSetDesktopSharingClient . class) ; <nl> + public DesktopSharingMouseAndKeyboardListener( <nl> + CallPeer callPeer, <nl> + OperationSetDesktopSharingClient desktopSharingClient) <nl> + { <nl> + this . callPeer = callPeer ; <nl> + this . desktopSharingClient = desktopSharingClient ; <nl> - opSetDesktopSharingClient . sendKeyboardEvent(callPeer, e) ; <nl> + if (desktopSharingClient != null) <nl> + desktopSharingClient . sendKeyboardEvent(callPeer, e) ; <nl> - opSetDesktopSharingClient . sendMouseEvent( <nl> - callPeer, <nl> - e, <nl> - videoComponent . getSize()) ; <nl> + if (desktopSharingClient != null) <nl> + { <nl> + desktopSharingClient . sendMouseEvent( <nl> + callPeer, <nl> + e, <nl> + videoComponent . getSize()) ; <nl> + } <nl> - opSetDesktopSharingClient . sendMouseEvent( <nl> - callPeer, <nl> - e, <nl> - videoComponent . getSize()) ; <nl> + if (desktopSharingClient != null) <nl> + { <nl> + desktopSharingClient . sendMouseEvent( <nl> + callPeer, <nl> + e, <nl> + videoComponent . getSize()) ; <nl> + } <nl> - opSetDesktopSharingClient . sendMouseEvent( <nl> - callPeer, <nl> - e, <nl> - videoComponent . getSize()) ; <nl> + if (desktopSharingClient != null) <nl> + { <nl> + desktopSharingClient . sendMouseEvent( <nl> + callPeer, <nl> + e, <nl> + videoComponent . getSize()) ; <nl> + } <nl> - opSetDesktopSharingClient . sendMouseEvent( <nl> - callPeer, <nl> - e, <nl> - videoComponent . getSize()) ; <nl> + if (desktopSharingClient != null) <nl> + { <nl> + desktopSharingClient . sendMouseEvent( <nl> + callPeer, <nl> + e, <nl> + videoComponent . getSize()) ; <nl> + } <nl> - opSetDesktopSharingClient . sendMouseEvent( <nl> - callPeer, <nl> - e, <nl> - videoComponent . getSize()) ; <nl> + if (desktopSharingClient != null) <nl> + { <nl> + desktopSharingClient . sendMouseEvent( <nl> + callPeer, <nl> + e, <nl> + videoComponent . getSize()) ; <nl> + } <nl> + if (desktopSharingClient == null) <nl> + return ; <nl> - opSetDesktopSharingClient . addRemoteControlListener(this) ; <nl> + desktopSharingClient . addRemoteControlListener(this) ; <nl> - opSetDesktopSharingClient . removeRemoteControlListener(this) ; <nl> + desktopSharingClient . removeRemoteControlListener(this) ; <nl> mmm OneToOneCallPeerPanel . java <nl> ppp OneToOneCallPeerPanel . java <nl> + private final DesktopSharingMouseAndKeyboardListener <nl> + desktopSharingMouseAndKeyboardListener ; <nl> - private DesktopSharingMouseAndKeyboardListener <nl> - desktopSharingMouseAndKeyboardListener ; <nl> - desktopSharingMouseAndKeyboardListener <nl> - = new DesktopSharingMouseAndKeyboardListener(callPeer) ; <nl> + OperationSetDesktopSharingClient desktopSharingClient <nl> + = callPeer . getProtocolProvider() . getOperationSet( <nl> + OperationSetDesktopSharingClient . class) ; <nl> + if (desktopSharingClient != null) <nl> + { <nl> + desktopSharingMouseAndKeyboardListener <nl> + = new DesktopSharingMouseAndKeyboardListener( <nl> + callPeer, <nl> + desktopSharingClient) ; <nl> + } <nl> + else <nl> + desktopSharingMouseAndKeyboardListener = null ; <nl> - desktopSharingMouseAndKeyboardListener . setVideoComponent( <nl> - remoteVideo) ; <nl> + if (desktopSharingMouseAndKeyboardListener != null) <nl> + { <nl> + desktopSharingMouseAndKeyboardListener . setVideoComponent( <nl> + remoteVideo) ; <nl> + } <nl>",
        "commit_message": "fix multiple failure to ( properly ) display the local and/or remote video in a call .",
        "what": "fix multiple failure to (properly) display the local and/or remote video in a call",
        "why": "improve video display functionality during calls",
        "check": "0"
    },
    {
        "commit_time": "2023-03-03 18:23:40-07:00",
        "diff": "mmm OpenRocketSaverTest . java <nl> ppp OpenRocketSaverTest . java <nl> + import net . sf . openrocket . document . Simulation ; <nl> + @Test <nl> + public void TestSimStatus() { <nl> + Rocket rocket = TestRockets . makeEstesAlphaIII() ; <nl> + OpenRocketDocument rocketDoc = OpenRocketDocumentFactory . createDocumentFromRocket(rocket) ; <nl> + Simulation sim1 = new Simulation(rocket) ; <nl> + rocketDoc . addSimulation(sim1) ; <nl> + Simulation sim2 = new Simulation(rocket) ; <nl> + sim2 . getOptions() . setISAAtmosphere(true) ; <nl> + sim2 . getOptions() . setTimeStep(0 . 05) ; <nl> + sim2 . setFlightConfigurationId(TestRockets . TEST_FCID_0) ; <nl> + rocketDoc . addSimulation(sim2) ; <nl> + Simulation sim3 = new Simulation(rocket) ; <nl> + sim3 . getOptions() . setISAAtmosphere(true) ; <nl> + sim3 . getOptions() . setTimeStep(0 . 05) ; <nl> + sim3 . setFlightConfigurationId(TestRockets . TEST_FCID_0) ; <nl> + try { <nl> + sim3 . simulate() ; <nl> + } catch (Exception e) { <nl> + fail(e . toString()) ; <nl> + } <nl> + rocketDoc . addSimulation(sim3) ; <nl> + Simulation sim4 = new Simulation(rocket) ; <nl> + sim4 . getOptions() . setISAAtmosphere(true) ; <nl> + sim4 . getOptions() . setTimeStep(0 . 05) ; <nl> + sim4 . setFlightConfigurationId(TestRockets . TEST_FCID_0) ; <nl> + try { <nl> + sim4 . simulate() ; <nl> + } catch (Exception e) { <nl> + fail(e . toString()) ; <nl> + } <nl> + sim4 . getOptions() . setTimeStep(0 . 1) ; <nl> + rocketDoc . addSimulation(sim4) ; <nl> + StorageOptions options = new StorageOptions() ; <nl> + options . setSaveSimulationData(true) ; <nl> + File file = saveRocket(rocketDoc, options) ; <nl> + OpenRocketDocument rocketDocLoaded = loadRocket(file . getPath()) ; <nl> + assertEquals(Simulation . Status . CANT_RUN, rocketDocLoaded . getSimulations() . get(0) . getStatus()) ; <nl> + assertEquals(Simulation . Status . NOT_SIMULATED, rocketDocLoaded . getSimulations() . get(1) . getStatus()) ; <nl> + assertEquals(Simulation . Status . LOADED, rocketDocLoaded . getSimulations() . get(2) . getStatus()) ;\t\t <nl> + assertEquals(Simulation . Status . OUTDATED, rocketDocLoaded . getSimulations() . get(3) . getStatus()) ; <nl> + } <nl>",
        "commit_message": "added unit tests for simulation status in OpenRocketSaverTest.java to ensure proper functionality and status reporting of simulations after saving and loading rocket documents",
        "what": "added unit tests for simulation status in OpenRocketSaverTest.java",
        "why": "ensure proper functionality and status reporting of simulations after saving and loading rocket documents",
        "check": "1"
    },
    {
        "commit_time": "2014-05-12 12:36:36-07:00",
        "diff": "mmm BiomeGenSwamp . java . patch <nl> ppp BiomeGenSwamp . java . patch <nl> - +        this . addFlower(Blocks . field_150419_aX, 0, 10) ; <nl> +        this . addFlower(Blocks . field_150328_O, 1, 10) ; <nl>",
        "commit_message": "fix no blue orchid spawn in swamp when use bone meal close # 1072",
        "what": "fix no blue orchid spawn in swamp when use bone meal",
        "why": "close # 1072",
        "check": "1"
    },
    {
        "commit_time": "2022-11-08 08:11:48-08:00",
        "diff": "mmm TestingServer . java <nl> ppp TestingServer . java <nl> - GcpKmsClient . register(Optional . of(gcpKeyUri), Optional . of(gcpCredentialsPath)) ; <nl> - AwsKmsClient . register(Optional . of(awsKeyUri), Optional . of(awsCredentialsPath)) ; <nl> + GcpKmsClient . register(Optional . ofNullable(gcpKeyUri), Optional . of(gcpCredentialsPath)) ; <nl> + AwsKmsClient . register(Optional . ofNullable(awsKeyUri), Optional . of(awsCredentialsPath)) ; <nl>",
        "commit_message": "add the possibility to use more than one key uri per km in cross-language test .",
        "what": "add the possibility to use more than one key uri per km in cross-language test",
        "why": "enhance the functionality of the cross-language test",
        "check": "1"
    },
    {
        "commit_time": "2020-07-29 18:16:49+08:00",
        "diff": "mmm InstructorCoursesPageE2ETest . java <nl> ppp InstructorCoursesPageE2ETest . java <nl> + CourseAttributes[] activeCoursesWithNewCourseSortedByName = { newCourse, courses[0] } ; <nl> - coursesPage . verifyActiveCoursesDetails(activeCoursesWithNewCourse) ; <nl> + coursesPage . verifyActiveCoursesDetails(activeCoursesWithNewCourseSortedByName) ; <nl> - CourseAttributes[] activeCoursesWithNewCourseSorted = { newCourse, courses[0] } ; <nl> + CourseAttributes[] activeCoursesWithNewCourseSortedByCreationDate = { newCourse, courses[0] } ; <nl> - coursesPage . sortByCreationDate() ; <nl> - coursesPage . verifyActiveCoursesDetails(activeCoursesWithNewCourseSorted) ; <nl> + coursesPage . verifyActiveCoursesDetails(activeCoursesWithNewCourseSortedByCreationDate) ; <nl>",
        "commit_message": "[ # 10467 ] instructor course page : fix course default sort not work a intend ( # 10477 )",
        "what": "fix course default sort not work",
        "why": "a intend",
        "check": "0"
    },
    {
        "commit_time": "2018-03-06 23:38:08-08:00",
        "diff": "mmm AndroidDescriptionsProvider . java <nl> ppp AndroidDescriptionsProvider . java <nl> - new AndroidPrebuiltAarDescription(toolchainProvider, javaConfig), <nl> + new AndroidPrebuiltAarDescription(javaConfig), <nl> mmm AndroidPrebuiltAarDescription . java <nl> ppp AndroidPrebuiltAarDescription . java <nl> - private final ToolchainProvider toolchainProvider ; <nl> - public AndroidPrebuiltAarDescription( <nl> - ToolchainProvider toolchainProvider, JavaBuckConfig javaBuckConfig) { <nl> - this . toolchainProvider = toolchainProvider ; <nl> + public AndroidPrebuiltAarDescription(JavaBuckConfig javaBuckConfig) { <nl> + ToolchainProvider toolchainProvider = context . getToolchainProvider() ; <nl> mmm AndroidPrebuiltAarBuilder . java <nl> ppp AndroidPrebuiltAarBuilder . java <nl> - import com . facebook . buck . jvm . java . toolchain . JavacOptionsProvider ; <nl> - import com . facebook . buck . toolchain . impl . ToolchainProviderBuilder ; <nl> - super( <nl> - new AndroidPrebuiltAarDescription( <nl> - new ToolchainProviderBuilder() <nl> -  . withToolchain( <nl> - JavacOptionsProvider . DEFAULT_NAME, <nl> - JavacOptionsProvider . of(JavaCompilationConstants . ANDROID_JAVAC_OPTIONS)) <nl> -  . build(), <nl> - JavaCompilationConstants . DEFAULT_JAVA_CONFIG), <nl> - target) ; <nl> + super(new AndroidPrebuiltAarDescription(JavaCompilationConstants . DEFAULT_JAVA_CONFIG), target) ; <nl>",
        "commit_message": "removed ToolchainProvider dependency from the AndroidPrebuiltAarDescription constructor to simplify code and utilize context to obtain ToolchainProvider",
        "what": "removed ToolchainProvider dependency from the AndroidPrebuiltAarDescription constructor",
        "why": "simplify code and utilize context to obtain ToolchainProvider",
        "check": "1"
    },
    {
        "commit_time": "2008-02-22 13:32:33+00:00",
        "diff": "mmm BatchNamespaceHandler . java <nl> ppp BatchNamespaceHandler . java <nl> + - * <p>Provides a {@link BeanDefinitionParser} for the <code>&lt ;batch:job&gt ;</code> tag .  A <code>job</code> <nl> + registerBeanDefinitionParser(job-repository, new JobRepositoryBeanDefinitionParser()) ; <nl>",
        "commit_message": "added a BeanDefinitionParser for the <batch:job> tag and registered a JobRepositoryBeanDefinitionParser to enhance the configuration of batch jobs in the application context",
        "what": "added a BeanDefinitionParser for the <batch:job> tag and registered a JobRepositoryBeanDefinitionParser",
        "why": "enhance the configuration of batch jobs in the application context",
        "check": "1"
    },
    {
        "commit_time": "2019-02-07 14:09:23+11:00",
        "diff": "mmm CloseStatus . java <nl> ppp CloseStatus . java <nl> + case NO_CODE: <nl> mmm FrameFlusher . java <nl> ppp FrameFlusher . java <nl>  <nl> mmm WebSocketConnection . java <nl> ppp WebSocketConnection . java <nl> - if (demand != 0) <nl> + if (demand != 0) //if demand was canceled, this creates synthetic demand in order to read until EOF <nl>",
        "commit_message": "added a new case for NO_CODE in CloseStatus and modified a conditional comment in WebSocketConnection to clarify the handling of demand cancellation and improve code readability",
        "what": "added a new case for NO_CODE in CloseStatus and modified a conditional comment in WebSocketConnection",
        "why": "clarify the handling of demand cancellation and improve code readability",
        "check": "1"
    },
    {
        "commit_time": "2015-05-27 20:49:09-07:00",
        "diff": "mmm DefaultVisualizer . java <nl> ppp DefaultVisualizer . java <nl> + if (section == null) { <nl> + return <error: source location> ; <nl> + } <nl>",
        "commit_message": "truffle/instrumentation : catch a npe error condition ( when a tag statement have no source information )",
        "what": "catch a npe error condition",
        "why": "when a tag statement have no source information",
        "check": "1"
    },
    {
        "commit_time": "2014-07-09 10:49:32-04:00",
        "diff": "mmm DeferredAttr . java <nl> ppp DeferredAttr . java <nl> - DeferredAttrContext dac = this ; <nl> - while (dac != emptyDeferredAttrContext) { <nl> - if (dac . mode == AttrMode . SPECULATIVE) { <nl> - break ; <nl> + if (insideOverloadPhase()) { <nl> + for (DeferredAttrNode deferredNode: deferredAttrNodes) { <nl> + deferredNode . dt . tree . type = Type . noType ; <nl> - dac = dac . parent ; <nl> + return ; <nl> + private boolean insideOverloadPhase() { <nl> + DeferredAttrContext dac = this ; <nl> + if (dac == emptyDeferredAttrContext) { <nl> + return false ; <nl> + } <nl> + if (dac . mode == AttrMode . SPECULATIVE) { <nl> + return true ; <nl> + } <nl> + return dac . parent . insideOverloadPhase() ; <nl> + } <nl> + Assert . check(!deferredAttrContext . insideOverloadPhase(), <nl> + attribution shouldn't be happening here) ; <nl> new file <nl> ppp IgnoreLambdaBodyDuringResolutionTest1 . java <nl> + class IgnoreLambdaBodyDuringResolutionTest1 { <nl> + interface SAM<T> { <nl> + T action(T t) ; <nl> + } <nl> + <T> T m(SAM<T> op) { <nl> + return null ; <nl> + } <nl> + class B { <nl> + B x() { <nl> + return this ; <nl> + } <nl> + } <nl> + class C {} <nl> + void foo(B arg) {} <nl> + void foo(C arg) {} <nl> + void bar() { <nl> + foo(m(arg -> new B())) ; <nl> + } <nl> + } <nl> new file <nl> ppp IgnoreLambdaBodyDuringResolutionTest2 . java <nl> + class IgnoreLambdaBodyDuringResolutionTest2 { <nl> + interface SAM<S> { <nl> + boolean test(S t) ; <nl> + } <nl> + <I, T extends I> I bar(final T l) { <nl> + return null ; <nl> + } <nl> + class D<D1, D2> { <nl> + void foo() { <nl> + m(bar(e -> false)) ; <nl> + } <nl> + void m(Class<D1> arg) {} <nl> + void m(SAM<D2> arg) {} <nl> + } <nl> + class F { <nl> + void foo() { <nl> + m(bar((String e) -> false)) ; <nl> + } <nl> + <F1> void m(Class<F1> arg) {} <nl> + <F2> void m(SAM<F2> arg) {} <nl> + } <nl> + } <nl>",
        "commit_message": "added overload phase checks in DeferredAttr and created test classes for ignoring lambda body during resolution to ensure proper context handling during attribute resolution and validate lambda expressions in overload scenarios",
        "what": "added overload phase checks in DeferredAttr and created test classes for ignoring lambda body during resolution",
        "why": "ensure proper context handling during attribute resolution and validate lambda expressions in overload scenarios",
        "check": "1"
    },
    {
        "commit_time": "2019-10-02 03:23:24+00:00",
        "diff": "mmm SPARCControlFlow . java <nl> ppp SPARCControlFlow . java <nl> - private static final int maximumSelfOffsetInstructions = 2 ; <nl> + private static final int maximumSelfOffsetInstructions = 10 ; <nl> mmm AbstractBeginNode . java <nl> ppp AbstractBeginNode . java <nl> + import org . graalvm . compiler . graph . Position ; <nl> + public boolean isUsedAsGuardInput() { <nl> + if (this . hasUsages()) { <nl> + for (Node n : usages()) { <nl> + for (Position inputPosition : n . inputPositions()) { <nl> + if (inputPosition . getInputType() == InputType . Guard && inputPosition . get(n) == this) { <nl> + return true ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + return false ; <nl> + } <nl> + public boolean hasAnchored() { <nl> + return this . hasUsages() ; <nl> + } <nl> mmm IfNode . java <nl> ppp IfNode . java <nl> - if (trueSuccessor() . anchored() . isNotEmpty() || falseSuccessor() . anchored() . isNotEmpty()) { <nl> + if (trueSuccessor() . hasAnchored() || falseSuccessor() . hasAnchored()) { <nl> + if (trueSuccessor() . isUsedAsGuardInput() || falseSuccessor() . isUsedAsGuardInput()) { <nl> + return false ; <nl> + } <nl> + if (trueSuccessor() . isUsedAsGuardInput() || falseSuccessor() . isUsedAsGuardInput()) { <nl> + return false ; <nl> + } <nl>",
        "commit_message": "[ gr-18261 ] do n't optimize if when a node be guard by one of it branch .",
        "what": "do not optimize if a node is guarded by one of its branches",
        "why": "to ensure proper handling of nodes in optimization process",
        "check": "1"
    },
    {
        "commit_time": "2017-05-12 09:34:57-07:00",
        "diff": "mmm DefaultFileHashCache . java <nl> ppp DefaultFileHashCache . java <nl> - private HashCodeAndFileType getHashCodeAndFileType(Path path) throws IOException { <nl> + HashCodeAndFileType getHashCodeAndFileType(Path path) throws IOException { <nl> mmm WatchedFileHashCache . java <nl> ppp WatchedFileHashCache . java <nl> + Path relativeFilePath = archiveMemberPath . getArchivePath() . normalize() ; <nl> + sb . append(\\nHash recomputed: ) . append(super . getHashCodeAndFileType(relativeFilePath)) ; <nl> + LOG . debug(sha1MismatchInfo) ; <nl>",
        "commit_message": "changed the access modifier of the method getHashCodeAndFileType from private to public in DefaultFileHashCache.java and added new logging and path normalization in WatchedFileHashCache.java to allow external access to the method and enhance logging for hash recomputation events",
        "what": "changed the access modifier of the method getHashCodeAndFileType from private to public in DefaultFileHashCache.java and added new logging and path normalization in WatchedFileHashCache.java",
        "why": "allow external access to the method and enhance logging for hash recomputation events",
        "check": "1"
    },
    {
        "commit_time": "2013-06-05 10:45:31+02:00",
        "diff": "mmm BufferedImageFactory . java <nl> ppp BufferedImageFactory . java <nl> - private void processProgress(int mScanline) { <nl> + private void processProgress(int scanline) { <nl> - int percent = 100 * mScanline / height ; <nl> + int percent = 100 * scanline / height ; <nl> - setPixelsImpl(pX, pY, pWidth, pHeight, pModel, pPixels, pOffset, pScanSize) ; <nl> + setPixelsImpl(pX, pY, pWidth, pHeight, pModel, pPixels, pOffset, pScanSize) ; <nl> - if (ImageUtil . getTransferType(pModel) == DataBuffer . TYPE_USHORT) { <nl> + if (pModel . getTransferType() == DataBuffer . TYPE_USHORT) { <nl> mmm ImageUtil . java <nl> ppp ImageUtil . java <nl> - private static final boolean COLORMODEL_TRANSFERTYPE_SUPPORTED = isColorModelTransferTypeSupported() ;\r <nl> - private static boolean isColorModelTransferTypeSupported() {\r <nl> - try {\r <nl> - ColorModel . getRGBdefault() . getTransferType() ;\r <nl> - return true ;\r <nl> - }\r <nl> - catch (Throwable t) {\r <nl> - return false ;\r <nl> - }\r <nl> - }\r <nl> - public static int getTransferType(ColorModel pModel) {\r <nl> - if (COLORMODEL_TRANSFERTYPE_SUPPORTED) {\r <nl> - return pModel . getTransferType() ;\r <nl> - }\r <nl> - else {\r <nl> - return pModel . createCompatibleSampleModel(1, 1) . getDataType() ;\r <nl> - }\r <nl> - } <nl> mmm InverseColorMapIndexColorModel . java <nl> ppp InverseColorMapIndexColorModel . java <nl> + import com . twelvemonkeys . lang . Validate ;\r <nl> - public InverseColorMapIndexColorModel(IndexColorModel pColorModel) {\r <nl> - this(pColorModel, getRGBs(pColorModel)) ;\r <nl> + public InverseColorMapIndexColorModel(final IndexColorModel pColorModel) {\r <nl> + this(Validate . notNull(pColorModel, color model), getRGBs(pColorModel)) ;\r <nl> - super(pColorModel . getComponentSize()[0], pColorModel . getMapSize(),\r <nl> - pRGBs, 0,\r <nl> - ImageUtil . getTransferType(pColorModel),\r <nl> - pColorModel . getValidPixels()) ;\r <nl> + super(pColorModel . getComponentSize()[0], pColorModel . getMapSize(), pRGBs, 0, pColorModel . getTransferType(), pColorModel . getValidPixels()) ;\r <nl>",
        "commit_message": "tmc-image : code clean-up . removed obsolete code . no functional change .",
        "what": "removed obsolete code",
        "why": "code clean-up, no functional change",
        "check": "0"
    },
    {
        "commit_time": "2022-03-07 09:49:38-08:00",
        "diff": "mmm MessageUnpacker . java <nl> ppp MessageUnpacker . java <nl> + totalReadBytes += position ; <nl>",
        "commit_message": "keep consistent read size after close messageunpacker ( # 621 )",
        "what": "keep consistent read size after close messageunpacker",
        "why": "relates to issue #621",
        "check": "1"
    },
    {
        "commit_time": "2020-06-29 16:58:17-07:00",
        "diff": "mmm Reshuffle . java <nl> ppp Reshuffle . java <nl>  <nl>",
        "commit_message": "update doc for reshuffle to remove the reference for deduplication by id .",
        "what": "update doc for reshuffle to remove the reference for deduplication by id",
        "why": "clarify documentation for reshuffle functionality",
        "check": "1"
    },
    {
        "commit_time": "2023-02-09 17:43:50+01:00",
        "diff": "mmm CommonContext . java <nl> ppp CommonContext . java <nl> + import io . aeron . exceptions . AeronException ; <nl> - import static io . aeron . Aeron . sleep ; <nl> + static void sleep(final long durationMs) <nl> + { <nl> + try <nl> + { <nl> + Thread . sleep(durationMs) ; <nl> + } <nl> + catch (final InterruptedException ex) <nl> + { <nl> + Thread . currentThread() . interrupt() ; <nl> + throw new AeronException(unexpected interrupt, ex) ; <nl> + } <nl> + } <nl>",
        "commit_message": "[ java ] move  sleep  function to commoncontext to avoid recursive dependency .",
        "what": "move sleep function to commoncontext",
        "why": "avoid recursive dependency",
        "check": "1"
    },
    {
        "commit_time": "2008-07-26 19:52:38+00:00",
        "diff": "mmm Mode . java <nl> ppp Mode . java <nl> + public boolean uniqueIndexSingleNullExceptAllColumnsAreNull ;\r <nl> + mode . uniqueIndexSingleNullExceptAllColumnsAreNull = true ;\r <nl> + add(mode) ;\r <nl> + mode = new Mode(DB2) ; <nl> mmm BaseIndex . java <nl> ppp BaseIndex . java <nl> + import org . h2 . engine . Mode ;\r <nl> - if (session . getDatabase() . getMode() . uniqueIndexSingleNull) {\r <nl> + Mode mode = session . getDatabase() . getMode() ;\r <nl> + if (mode . uniqueIndexSingleNull) {\r <nl> + } else if (mode . uniqueIndexSingleNullExceptAllColumnsAreNull) {\r <nl> + for (int i = 0 ; i < columns . length ; i++) {\r <nl> + int index = columnIds[i] ;\r <nl> + Value v = newRow . getValue(index) ;\r <nl> + if (v != ValueNull . INSTANCE) {\r <nl> + return false ;\r <nl> + }\r <nl> + }\r <nl> + return true ; <nl> mmm TestCompatibility . java <nl> ppp TestCompatibility . java <nl> + testUniqueIndexOracle() ;\r <nl> + private void testUniqueIndexOracle() throws Exception {\r <nl> + Statement stat = conn . createStatement() ;\r <nl> + stat . execute(SET MODE ORACLE) ;\r <nl> + stat . execute(create table t2(c1 int, c2 int)) ;\r <nl> + stat . execute(create unique index i2 on t2(c1, c2)) ;\r <nl> + stat . execute(insert into t2 values (null, 1)) ;\r <nl> + try {\r <nl> + stat . execute(insert into t2 values (null, 1)) ;\r <nl> + fail() ;\r <nl> + } catch (SQLException e) {\r <nl> + assertKnownException(e) ;\r <nl> + }\r <nl> + stat . execute(insert into t2 values (null, null)) ;\r <nl> + stat . execute(insert into t2 values (null, null)) ;\r <nl> + stat . execute(insert into t2 values (1, null)) ;\r <nl> + try {\r <nl> + stat . execute(insert into t2 values (1, null)) ;\r <nl> + fail() ;\r <nl> + } catch (SQLException e) {\r <nl> + assertKnownException(e) ;\r <nl> + }\r <nl> + stat . execute(DROP TABLE T2) ;\r <nl> + } <nl>",
        "commit_message": "fix the oracle mode : oracle allow multiple row only where all column of the unique index be null .",
        "what": "fix the oracle mode",
        "why": "oracle allows multiple rows only where all columns of the unique index be null",
        "check": "1"
    },
    {
        "commit_time": "2014-12-19 16:23:26+01:00",
        "diff": "mmm ScrollPane . java <nl> ppp ScrollPane . java <nl> - widgetWidth = disableX ? width : Math . max(areaWidth, widgetWidth) ;\r <nl> - widgetHeight = disableY ? height : Math . max(areaHeight, widgetHeight) ;\r <nl> + widgetWidth = disableX ? areaWidth : Math . max(areaWidth, widgetWidth) ;\r <nl> + widgetHeight = disableY ? areaHeight : Math . max(areaHeight, widgetHeight) ;\r <nl> + if (forceScrollY) {\r <nl> + float scrollbarWidth = 0 ;\r <nl> + if (style . vScrollKnob != null) scrollbarWidth = style . vScrollKnob . getMinWidth() ;\r <nl> + if (style . vScroll != null) scrollbarWidth = Math . max(scrollbarWidth, style . vScroll . getMinWidth()) ;\r <nl> + width += scrollbarWidth ;\r <nl> + }\r <nl> + if (forceScrollX) {\r <nl> + float scrollbarHeight = 0 ;\r <nl> + if (style . hScrollKnob != null) scrollbarHeight = style . hScrollKnob . getMinHeight() ;\r <nl> + if (style . hScroll != null) scrollbarHeight = Math . max(scrollbarHeight, style . hScroll . getMinHeight()) ;\r <nl> + height += scrollbarHeight ;\r <nl> + } <nl>",
        "commit_message": "updated widget width and height calculations and added scrollbar adjustments for forced scrolling to enhance scroll pane functionality and ensure proper layout with scrollbars when enabled",
        "what": "updated widget width and height calculations and added scrollbar adjustments for forced scrolling",
        "why": "enhance scroll pane functionality and ensure proper layout with scrollbars when enabled",
        "check": "1"
    },
    {
        "commit_time": "2020-08-18 20:24:53+01:00",
        "diff": "mmm Http2UpgradeHandler . java <nl> ppp Http2UpgradeHandler . java <nl> - import org . apache . coyote . CloseNowException ; <nl> - throw new CloseNowException( <nl> - sm . getString(upgradeHandler . stream . notWritable, <nl> - stream . getConnectionId(), stream . getIdentifier())) ; <nl> + stream . doStreamCancel(sm . getString(upgradeHandler . stream . notWritable), Http2Error . STREAM_CLOSED) ; <nl> - error = Http2Error . CANCEL ; <nl> + error = Http2Error . STREAM_CLOSED ; <nl> mmm TestHttp2Section_5_1 . java <nl> ppp TestHttp2Section_5_1 . java <nl> - Assert . assertEquals(3-RST-[8]\\n, output . getTrace()) ; <nl> + Assert . assertEquals(3-RST-[5]\\n, output . getTrace()) ; <nl>",
        "commit_message": "refactor for more consistent error code after client send stream reset",
        "what": "refactor for more consistent error code",
        "why": "after client send stream reset",
        "check": "0"
    },
    {
        "commit_time": "2018-02-23 20:00:52+03:00",
        "diff": "mmm NearbyMapFragment . java <nl> ppp NearbyMapFragment . java <nl> + import com . mapbox . mapboxsdk . maps . OnMapReadyCallback ; <nl> - private fr . free . nrw . commons . location . LatLng latestSignificantUpdate ; <nl> - addNearbyMarkerstoMapBoxMap() ; <nl> - if (currentLocationMarker != null) { <nl> + if (currentLocationMarker != null && mapboxMap != null) { <nl> + if (currentLocationMarker != null) { <nl> + currentLocationMarker . remove() ; // Remove previous marker, we are not Hansel and Gretel <nl> + } <nl> - latestSignificantUpdate = curLatLng ; // To remember the last point we update nearby markers <nl> + mapView . getMapAsync(new OnMapReadyCallback() { <nl> + @Override <nl> + public void onMapReady(MapboxMap mapboxMap) { <nl> + } <nl> + }) ; <nl>",
        "commit_message": "added a null check for mapboxMap and implemented OnMapReadyCallback in NearbyMapFragment.java to ensure proper map functionality and avoid potential null pointer exceptions",
        "what": "added a null check for mapboxMap and implemented OnMapReadyCallback in NearbyMapFragment.java",
        "why": "ensure proper map functionality and avoid potential null pointer exceptions",
        "check": "1"
    },
    {
        "commit_time": "2017-10-05 14:29:59+00:00",
        "diff": "mmm StandardButton . java <nl> ppp StandardButton . java <nl> + import com . google . gwt . aria . client . Roles ;\r <nl> + Roles . getButtonRole() . removeAriaPressedState(getElement()) ;\r <nl> - public void setText(String text){\r <nl> + public void setText(String text) {\r <nl> + Roles . getButtonRole() . removeAriaPressedState(getElement()) ; <nl>",
        "commit_message": "screen reader : only say button , not toggle button not press for standard button",
        "what": "only say button, not toggle button not press for standard button",
        "why": "improve screen reader accessibility",
        "check": "1"
    },
    {
        "commit_time": "2022-01-26 13:52:13+00:00",
        "diff": "mmm OneCanCallSetterWithNullParameterizedTest . java <nl> ppp OneCanCallSetterWithNullParameterizedTest . java <nl> - import org . junit . Test ; <nl> - import org . junit . runner . RunWith ; <nl> - import org . junit . runners . Parameterized ; <nl> + import org . junit . jupiter . api . DynamicTest ; <nl> + import org . junit . jupiter . api . TestFactory ; <nl> + import static org . junit . jupiter . api . DynamicTest . dynamicTest ; <nl> - @RunWith(Parameterized . class) <nl> - @Parameterized . Parameters(name = {1}) <nl> - public static Collection<Object[]> data() { <nl> - final Launcher launcher = new Launcher() ; <nl> - final Factory factory = launcher . getFactory() ; <nl> + @TestFactory <nl> + public Collection<DynamicTest> createTests() { <nl> + Launcher launcher = new Launcher() ; <nl> - final List<Object[]> values = new ArrayList<>() ; <nl> + List<DynamicTest> tests = new ArrayList<>() ; <nl> - return (candidate . getSimpleName() . startsWith(set) // <nl> - || candidate . getSimpleName() . startsWith(add)) // <nl> - && takeSetterForCtElement(candidate) ; // <nl> + return (candidate . getSimpleName() . startsWith(set) <nl> + || candidate . getSimpleName() . startsWith(add)) <nl> + && takeSetterForCtElement(candidate) ; <nl> - values . add(new Object[] { createCompatibleObject(element . getDeclaringType() . getReference()), element . getReference() . getActualMethod() }) ; <nl> + tests . add(dynamicTest(element . getReference() . getActualMethod() . getName(), <nl> + () -> testNullSafe(createCompatibleObject(element . getDeclaringType() . getReference()), <nl> + element . getReference() . getActualMethod()))) ; <nl> - return values ; <nl> + return tests ; <nl> - @Parameterized . Parameter(0) <nl> - public Object instance ; <nl> - @Parameterized . Parameter(1) <nl> - public Method toTest ; <nl> - @Test <nl> - public void testContract() throws Throwable { <nl> + private void testNullSafe(Object instance, Method setter) throws Throwable { <nl> - Object element = instance ; <nl> - if (element instanceof FactoryAccessor) { <nl> - ((FactoryAccessor) element) . setFactory(factory) ; <nl> + if (instance instanceof FactoryAccessor) { <nl> + ((FactoryAccessor) instance) . setFactory(factory) ; <nl> - toTest . invoke(element, new Object[] { null }) ; <nl> + setter . invoke(instance, new Object[] { null }) ; <nl>",
        "commit_message": "test : migrate onecancallsetterwithnullparameterizedtest to junit 5 ( # 4555 )",
        "what": "migrate onecancallsetterwithnullparameterizedtest to junit 5",
        "why": "improve testing framework compatibility (from the context provided by the issue number)",
        "check": "1"
    },
    {
        "commit_time": "2022-08-10 19:00:38+08:00",
        "diff": "mmm IStateMachine . java <nl> ppp IStateMachine . java <nl> + default List<File> getSnapshotFiles(File latestSnapshotRootDir) { <nl> + return null ; <nl> + } <nl> mmm DataRegionStateMachine . java <nl> ppp DataRegionStateMachine . java <nl> + @Override <nl> + public List<File> getSnapshotFiles(File latestSnapshotRootDir) { <nl> + return super . getSnapshotFiles(latestSnapshotRootDir) ; <nl> + } <nl>",
        "commit_message": "added a default method getSnapshotFiles to IStateMachine and overridden it in DataRegionStateMachine to provide a base implementation for obtaining snapshot files in the state machine hierarchy",
        "what": "added a default method getSnapshotFiles to IStateMachine and overridden it in DataRegionStateMachine",
        "why": "provide a base implementation for obtaining snapshot files in the state machine hierarchy",
        "check": "1"
    },
    {
        "commit_time": "2014-07-15 14:22:14-07:00",
        "diff": "mmm SLMain . java <nl> ppp SLMain . java <nl> - if (ss == null || ss instanceof NullSourceSection) { <nl> - result . append( at <unknown>) ; <nl> - } else { <nl> + if (ss != null && !(ss instanceof NullSourceSection)) { <nl>",
        "commit_message": "sl : update test ; error location report differently with source attribution change .",
        "what": "update test; error location report differently with source attribution change",
        "why": "improves clarity of error reporting with source attribution change",
        "check": "1"
    },
    {
        "commit_time": "2015-12-05 09:10:45+01:00",
        "diff": "mmm ManagedMessageHistoryTest . java <nl> ppp ManagedMessageHistoryTest . java <nl>  <nl> mmm MetricsMessageHistoryTest . java <nl> ppp MetricsMessageHistoryTest . java <nl> + MetricsMessageHistoryService service = context . hasService(MetricsMessageHistoryService . class) ; <nl> + assertNotNull(service) ; <nl> + String json = service . dumpStatisticsAsJson() ; <nl> + assertNotNull(json) ; <nl> + log . info(json) ; <nl> + assertTrue(json . contains(foo . history)) ; <nl> + assertTrue(json . contains(bar . history)) ; <nl> + assertTrue(json . contains(baz . history)) ; <nl> -  . to(mock:foo) ; <nl> +  . to(mock:foo) . id(foo) ; <nl> -  . to(mock:bar) <nl> -  . to(mock:baz) ; <nl> +  . to(mock:bar) . id(bar) <nl> +  . to(mock:baz) . id(baz) ; <nl> mmm SpringMetricsMessageHistoryTest . java <nl> ppp SpringMetricsMessageHistoryTest . java <nl> + MetricsMessageHistoryService service = context . hasService(MetricsMessageHistoryService . class) ; <nl> + assertNotNull(service) ; <nl> + String json = service . dumpStatisticsAsJson() ; <nl> + assertNotNull(json) ; <nl> + log . info(json) ; <nl> + assertTrue(json . contains(foo . history)) ; <nl> + assertTrue(json . contains(bar . history)) ; <nl> + assertTrue(json . contains(baz . history)) ; <nl>",
        "commit_message": "camel-9389 : camel-metrics - allow to capture message history easily",
        "what": "allow to capture message history",
        "why": "easily",
        "check": "0"
    },
    {
        "commit_time": "2017-06-02 10:51:23-07:00",
        "diff": "mmm LuceneQParserPlugin . java <nl> ppp LuceneQParserPlugin . java <nl> - @Override <nl> - @Deprecated <nl> - public SortSpec getSort(boolean useGlobal) throws SyntaxError { <nl> - return getSortSpec(useGlobal) ; <nl> - } <nl> mmm QParser . java <nl> ppp QParser . java <nl> - @Deprecated <nl> - public SortSpec getSort(boolean useGlobalParams) throws SyntaxError { <nl> - return getSortSpec(useGlobalParams) ; <nl> - } <nl> mmm QueryParsing . java <nl> ppp QueryParsing . java <nl> - @Deprecated <nl> - public static QueryParser . Operator getQueryParserDefaultOperator(final IndexSchema notUsed, <nl> - final String df) { <nl> - return parseOP(df) ; <nl> - } <nl> - @Deprecated <nl> - public static String getDefaultField(final IndexSchema ignored, final String df) { <nl> - return df ; <nl> - } <nl> mmm SolrPluginUtils . java <nl> ppp SolrPluginUtils . java <nl> - import org . apache . lucene . index . IndexableField ; <nl> - import org . apache . solr . common . SolrDocument ; <nl> - import org . apache . solr . common . SolrDocumentList ; <nl> - public static SolrDocumentList docListToSolrDocumentList( <nl> - DocList docs, <nl> - SolrIndexSearcher searcher, <nl> - Set<String> fields, <nl> - Map<SolrDocument, Integer> ids ) throws IOException <nl> - { <nl> - IndexSchema schema = searcher . getSchema() ; <nl> - SolrDocumentList list = new SolrDocumentList() ; <nl> - list . setNumFound(docs . matches()) ; <nl> - list . setMaxScore(docs . maxScore()) ; <nl> - list . setStart(docs . offset()) ; <nl> - DocIterator dit = docs . iterator() ; <nl> - while (dit . hasNext()) { <nl> - int docid = dit . nextDoc() ; <nl> - Document luceneDoc = searcher . doc(docid, fields) ; <nl> - SolrDocument doc = new SolrDocument() ; <nl> - for( IndexableField field : luceneDoc) { <nl> - if (null == fields || fields . contains(field . name())) { <nl> - SchemaField sf = schema . getField( field . name() ) ; <nl> - doc . addField( field . name(), sf . getType() . toObject( field ) ) ; <nl> - } <nl> - } <nl> - if (docs . hasScores() && (null == fields || fields . contains(score))) { <nl> - doc . addField(score, dit . score()) ; <nl> - } <nl> - list . add( doc ) ; <nl> - if( ids != null ) { <nl> - ids . put( doc, new Integer(docid) ) ; <nl> - } <nl> - } <nl> - return list ; <nl> - } <nl>",
        "commit_message": "removed deprecated methods from LuceneQParserPlugin, QParser, and QueryParsing classes to clean up the code and promote the use of updated methods",
        "what": "removed deprecated methods from LuceneQParserPlugin, QParser, and QueryParsing classes",
        "why": "clean up the code and promote the use of updated methods",
        "check": "1"
    },
    {
        "commit_time": "2023-09-05 17:36:29+05:30",
        "diff": "mmm GradleBuildService . java <nl> ppp GradleBuildService . java <nl> - new TaskExecutionMessage(:, Arrays . asList(tasks), getGradleInstallationDir()) ;\r <nl> + new TaskExecutionMessage(IProject . ROOT_PROJECT_PATH, Arrays . asList(tasks), getGradleInstallationDir()) ; <nl>",
        "commit_message": "updated TaskExecutionMessage constructor to use ROOT_PROJECT_PATH instead of a colon to ensure correct project path representation for task execution",
        "what": "updated TaskExecutionMessage constructor to use ROOT_PROJECT_PATH instead of a colon",
        "why": "ensure correct project path representation for task execution",
        "check": "1"
    },
    {
        "commit_time": "2021-09-08 22:45:02-04:00",
        "diff": "mmm VectorOutput . java <nl> ppp VectorOutput . java <nl> + import java . time . Instant ; <nl> + import java . time . ZoneId ; <nl> - OffsetDateTime originalDateTime = OffsetDateTime . parse(parser . getValueAsString(), DateUtility . isoFormatTimeStamp) ; <nl> - OffsetDateTime utcDateTime = OffsetDateTime . of(originalDateTime . toLocalDateTime(), ZoneOffset . UTC) ;   // strips the time zone from the original <nl> - ts . writeTimeStamp(utcDateTime . toInstant() . toEpochMilli()) ; <nl> + Instant instant = Instant . parse(parser . getValueAsString()) ; <nl> + long offset = ZoneId . systemDefault() . getRules() . getOffset(instant) . getTotalSeconds() * 1000 ; <nl> + ts . writeTimeStamp(instant . toEpochMilli() offset) ; <nl> - OffsetDateTime originalDateTime = OffsetDateTime . parse(parser . getValueAsString(), DateUtility . isoFormatTimeStamp) ; <nl> - OffsetDateTime utcDateTime = OffsetDateTime . of(originalDateTime . toLocalDateTime(), ZoneOffset . UTC) ;   // strips the time zone from the original <nl> - ts . writeTimeStamp(utcDateTime . toInstant() . toEpochMilli()) ; <nl> + Instant instant = Instant . parse(parser . getValueAsString()) ; <nl> + long offset = ZoneId . systemDefault() . getRules() . getOffset(instant) . getTotalSeconds() * 1000 ; <nl> + ts . writeTimeStamp(instant . toEpochMilli() offset) ; <nl> mmm TestFrameworkTest . java <nl> ppp TestFrameworkTest . java <nl> + import java . time . Instant ; <nl> + import java . time . LocalDateTime ; <nl> + import java . time . ZoneId ; <nl> + LocalDateTime localDT = LocalDateTime . of(2019, 9, 30, 20, 47, 43, 123) ; <nl> + Instant instant = localDT . atZone(ZoneId . systemDefault()) . toInstant() ; <nl> + long ts = instant . toEpochMilli() instant . getNano() ; <nl> + ts = ts ZoneId . systemDefault() . getRules() . getOffset(instant) . getTotalSeconds() * 1000 ; <nl> -  . baselineColumns(integer, float, x, z, l, rl) <nl> +  . baselineColumns(integer, float, x, z, l, rl, date) <nl> - listOf(4l, 6l))) <nl> + listOf(4l, 6l)), <nl> + LocalDateTime . ofInstant(Instant . ofEpochMilli(ts), ZoneId . systemDefault())) <nl> mmm TestJsonRecordReader . java <nl> ppp TestJsonRecordReader . java <nl> + @Test <nl> + public void testDateJsonInput() throws Exception { <nl> + test(select date, AGE(date, CAST('2019-09-30 20:47:43' as timestamp)) from cp . jsoninput/input2 . json limit 10 ) ; <nl> + } <nl>",
        "commit_message": "drill-7989 : use the utc formatter in the json reader ( # 2299 )",
        "what": "use the utc formatter in the json reader",
        "why": "improve consistency in date-time handling",
        "check": "1"
    },
    {
        "commit_time": "2012-11-29 15:44:49+01:00",
        "diff": "mmm VMToCompilerImpl . java <nl> ppp VMToCompilerImpl . java <nl> + CompilationTask current = method . currentTask() ; <nl> - return true ; <nl> + return current != null ; <nl> - return false ; <nl> + return current != null ; <nl> - CompilationTask current = method . currentTask() ; <nl> + return false ; <nl> + return task != null ; <nl> - return true ; <nl> mmm GraalOptions . java <nl> ppp GraalOptions . java <nl> - public static boolean PrintDisabledOptimisticOptimizations = true ; <nl>",
        "commit_message": "fix some issue that preclude compilation of graal compiler method",
        "what": "fix some issue that preclude compilation of graal compiler method",
        "why": "prevent compilation issues",
        "check": "1"
    },
    {
        "commit_time": "2016-08-23 18:34:57+02:00",
        "diff": "mmm VersionBumper . java <nl> ppp VersionBumper . java <nl> - Pattern pattern = Pattern . compile((\\\\d+)\\\\ . (\\\\d+)\\\\ . (\\\\d+)(-(\\\\w+)){0,1}) ; <nl> + Pattern pattern = Pattern . compile((\\\\d+)\\\\ . (\\\\d+)\\\\ . (\\\\d+)(-(\\\\w+)\\\\ . (\\\\d+))?) ; <nl> - throw new IllegalArgumentException(Unsupported version: ' + version + ' .  Examples of supported versions: 1 . 0 . 0, 1 . 20 . 123, 1 . 0 . 10-beta) ; <nl> + throw new IllegalArgumentException(Unsupported version: ' version ' .  Examples of supported versions: 1 . 0 . 0, 1 . 20 . 123, 1 . 0 . 10-beta . 3) ; <nl> - String postfix = matcher . group(4) != null ? matcher . group(4) :  ; <nl> - return  + major +  .  + minor +  .  + (patch + 1) + postfix ; <nl> + if (matcher . group(4) != null) { <nl> + int betaVersion = Integer . parseInt(matcher . group(6)) ; <nl> + return  major  .  minor  .  patch - matcher . group(5)  .  (betaVersion 1) ; <nl> + } <nl> + return  major  .  minor  .  (patch 1) ; <nl>",
        "commit_message": "change version scheme to semver and update readme ( # 483 )",
        "what": "change version scheme to semver and update readme",
        "why": "improve versioning clarity and documentation",
        "check": "1"
    },
    {
        "commit_time": "2022-05-16 15:38:22+08:00",
        "diff": "mmm EnergyWhenSendAndTransferTest . java <nl> ppp EnergyWhenSendAndTransferTest . java <nl> - long value = 1000L ; <nl> + long value = 10_000L ; <nl>",
        "commit_message": "test ( vm ) : fix contract address conflict",
        "what": "fix contract address conflict",
        "why": "test ( vm )",
        "check": "1"
    },
    {
        "commit_time": "2012-01-14 19:09:52+00:00",
        "diff": "mmm JavaBinUpdateRequestCodec . java <nl> ppp JavaBinUpdateRequestCodec . java <nl> - nl . add(s, params . getParams(s)) ; <nl> + for(String val: params . getParams(s)) { <nl> + nl . add(s, val) ; <nl> + } <nl> mmm TestUpdateRequestCodec . java <nl> ppp TestUpdateRequestCodec . java <nl> + updateRequest . setParam(a, b) ; <nl> + assertEquals(b, updateUnmarshalled . getParams() . get(a)) ; <nl>",
        "commit_message": "refactor parameter handling in JavaBinUpdateRequestCodec to use a loop for adding params to improve code clarity and maintainability by ensuring each parameter is added individually",
        "what": "refactor parameter handling in JavaBinUpdateRequestCodec to use a loop for adding params",
        "why": "improve code clarity and maintainability by ensuring each parameter is added individually",
        "check": "1"
    },
    {
        "commit_time": "2017-05-23 21:42:09+03:00",
        "diff": "mmm TestRunner . java <nl> ppp TestRunner . java <nl> + import com . codename1 . testing . JUnitXMLReporting ; <nl> - System . out . println(Usage: TestRunner mainClass [-testCases testCase1,testCase2 .  .  . ] [-skins skin1,skin2 .  .  . ] [-quiet] [-cleanMode] <nl> + System . out . println(Usage: TestRunner mainClass [-testCases testCase1,testCase2 .  .  . ] [-skins skin1,skin2 .  .  . ] [-quiet] [-cleanMode] [-junitXML] <nl> - + stopOnFail indicates that execution should stop the moment a failure occured) ; <nl> + stopOnFail - indicates that execution should stop the moment a failure occured\\n <nl> + junitXML - output is written in junit XML format) ; <nl> + if(s . equalsIgnoreCase(-junitXML)) { <nl> + TestReporting . setInstance(new JUnitXMLReporting()) ; <nl> + } <nl>",
        "commit_message": "fixed # 1913 export test report a junit xml report enable for all test",
        "what": "fixed export test report a junit xml report",
        "why": "enable for all test",
        "check": "1"
    },
    {
        "commit_time": "2013-02-18 14:29:16-08:00",
        "diff": "mmm Test6850611 . java <nl> ppp Test6850611 . java <nl>  <nl> mmm Test6890943 . java <nl> ppp Test6890943 . java <nl>  <nl> mmm Test6905845 . java <nl> ppp Test6905845 . java <nl>  <nl> mmm Test6992759 . java <nl> ppp Test6992759 . java <nl>  <nl>",
        "commit_message": "update multiple test Java files for consistency to ensure uniformity across test implementations",
        "what": "update multiple test Java files for consistency",
        "why": "ensure uniformity across test implementations",
        "check": "1"
    },
    {
        "commit_time": "2016-05-23 19:17:41+09:00",
        "diff": "mmm AudioWebSocket . java <nl> ppp AudioWebSocket . java <nl> + import net . dv8tion . jda . events . audio . AudioUnableToConnectEvent ; <nl> - import java . net . DatagramPacket ; <nl> - import java . net . DatagramSocket ; <nl> - import java . net . InetSocketAddress ; <nl> - import java . net . NoRouteToHostException ; <nl> + import java . net . * ; <nl> + public static final int WEBSOCKET_READ_TIMEOUT = 1008 ; <nl> + public static final int UDP_UNABLE_TO_CONNECT = -42 ; <nl> - InetSocketAddress externalIpAndPort = handleUdpDiscovery(new InetSocketAddress(endpoint, port), ssrc) ; <nl> - if (externalIpAndPort == null) <nl> - throw new RuntimeException(Couldn't get external ip and port from UDP discovery) ; <nl> + InetSocketAddress externalIpAndPort = null ; <nl> + int tries = 0 ; <nl> + do <nl> + { <nl> + externalIpAndPort = handleUdpDiscovery(new InetSocketAddress(endpoint, port), ssrc) ; <nl> + tries++ ; <nl> + if (externalIpAndPort == null && tries > 5) <nl> + { <nl> + close(false, UDP_UNABLE_TO_CONNECT) ; <nl> + return ; <nl> + } <nl> + } while (externalIpAndPort == null) ; <nl> + setupUdpKeepAliveThread() ; <nl> - if (regionChange) <nl> - api . getEventManager() . handle(new AudioRegionChangeEvent(api, disconnectedChannel)) ; <nl> - else <nl> - api . getEventManager() . handle(new AudioDisconnectEvent(api, disconnectedChannel)) ; <nl> - if (disconnectCode == 1008) //Internal WS code meaning the frame reading was interupted, in this case, by timeout .  <nl> + if (disconnectCode == WEBSOCKET_READ_TIMEOUT || disconnectCode == UDP_UNABLE_TO_CONNECT) <nl> + if (regionChange) <nl> + { <nl> + api . getEventManager() . handle(new AudioRegionChangeEvent(api, disconnectedChannel)) ; <nl> + } <nl> + else if (disconnectCode == UDP_UNABLE_TO_CONNECT) <nl> + { <nl> + api . getEventManager() . handle(new AudioUnableToConnectEvent(api, disconnectedChannel)) ; <nl> + } <nl> + else <nl> + { <nl> + api . getEventManager() . handle(new AudioDisconnectEvent(api, disconnectedChannel)) ; <nl> + } <nl> + udpSocket . setSoTimeout(1000) ; <nl> - setupUdpKeepAliveThread(address) ; <nl> + catch (SocketException e) <nl> + { <nl> + return null ; <nl> + } <nl> + return null ; <nl> - return null ; <nl> - private void setupUdpKeepAliveThread(final InetSocketAddress address) <nl> + private void setupUdpKeepAliveThread() <nl> new file <nl> ppp AudioUnableToConnectEvent . java <nl> + package net . dv8tion . jda . events . audio ; <nl> + import net . dv8tion . jda . JDA ; <nl> + import net . dv8tion . jda . entities . VoiceChannel ; <nl> + public class AudioUnableToConnectEvent extends GenericAudioEvent <nl> + { <nl> + protected final VoiceChannel channel ; <nl> + public AudioUnableToConnectEvent(JDA api, VoiceChannel channel) <nl> + { <nl> + super(api, -1) ; <nl> + this . channel = channel ; <nl> + } <nl> + public VoiceChannel getChannel() <nl> + { <nl> + return channel ; <nl> + } <nl> + } <nl> mmm ListenerAdapter . java <nl> ppp ListenerAdapter . java <nl> + public void onAudioUnableToConnect(AudioUnableToConnectEvent event) {} <nl> + else if (event instanceof AudioUnableToConnectEvent) <nl> + onAudioUnableToConnect((AudioUnableToConnectEvent) event) ; <nl>",
        "commit_message": "first pas at an implementation to recover from udp problem when establish an audioconnection . add audiounabletoconnectevent .",
        "what": "first pass at an implementation to recover from udp problem when establishing an audioconnection, add audiounabletoconnectevent",
        "why": "recover from UDP problem when establishing an audioconnection",
        "check": "0"
    },
    {
        "commit_time": "2010-03-16 07:37:28+00:00",
        "diff": "mmm DefaultCamelContext . java <nl> ppp DefaultCamelContext . java <nl> - private static int nameSuffix ; <nl> + private static AtomicInteger nameSuffix = new AtomicInteger(0) ; <nl> - name = NAME_PREFIX + ++nameSuffix ; <nl> + name = NAME_PREFIX nameSuffix . incrementAndGet() ; <nl> mmm SplitterPojoTest . java <nl> ppp SplitterPojoTest . java <nl>  <nl>",
        "commit_message": "camel-2552 fix the camelcontext default name 's thread safe issue",
        "what": "fix the camelcontext default name's thread safe issue",
        "why": "(implicit context of resolving a threading issue)",
        "check": "0"
    },
    {
        "commit_time": "2021-10-28 09:35:52-06:00",
        "diff": "mmm DaoAuthenticationProviderTests . java <nl> ppp DaoAuthenticationProviderTests . java <nl> - long sum = 0 ; <nl> - for (Long time : counts) { <nl> - sum += time ; <nl> - } <nl> - return sum / counts . size() ; <nl> + return counts . stream() . mapToLong(Long::longValue) . average() . orElse(0) ; <nl>",
        "commit_message": "replaced manual calculation of average with stream-based computation to improve readability and leverage Java's built-in average calculation",
        "what": "replaced manual calculation of average with stream-based computation",
        "why": "improve readability and leverage Java's built-in average calculation",
        "check": "1"
    },
    {
        "commit_time": "2015-12-03 14:30:41-08:00",
        "diff": "mmm ColumnIndexContainer . java <nl> ppp ColumnIndexContainer . java <nl> - import com . linkedin . pinot . core . index . reader . impl . v2 . FixedBitSingleValueReader ; <nl> - import com . linkedin . pinot . core . index . reader . impl . v2 . FixedBitMultiValueReader ; <nl> + import com . linkedin . pinot . core . index . reader . impl . v1 . FixedBitSingleValueReader ; <nl> + import com . linkedin . pinot . core . index . reader . impl . v1 . FixedBitMultiValueReader ; <nl> mmm SegmentOnlineOfflineStateModelFactory . java <nl> ppp SegmentOnlineOfflineStateModelFactory . java <nl> - LOGGER . error(Failed to load segment metadata from local:  + localSegmentDir) ; <nl> + LOGGER . error(Failed to load segment metadata from local:  localSegmentDir,e) ; <nl> - LOGGER . error(Failed to load segment from local, will try to reload it from controller!) ; <nl> + LOGGER . error(Failed to load segment from local, will try to reload it from controller!,e) ; <nl>",
        "commit_message": "updated imports from v2 to v1 for FixedBitSingleValueReader and FixedBitMultiValueReader to ensure compatibility with the latest version of the index reader implementations",
        "what": "updated imports from v2 to v1 for FixedBitSingleValueReader and FixedBitMultiValueReader",
        "why": "ensure compatibility with the latest version of the index reader implementations",
        "check": "1"
    },
    {
        "commit_time": "2012-02-02 09:14:38-08:00",
        "diff": "new file <nl> ppp SpreadNullArg . java <nl> + import java . lang . invoke . MethodHandle ; <nl> + import java . lang . invoke . MethodHandles ; <nl> + import java . lang . invoke . MethodType ; <nl> + public class SpreadNullArg { <nl> + public static void main(String args[]) { <nl> + MethodType mt_ref_arg = MethodType . methodType(int . class, Integer . class) ; <nl> + MethodHandle mh_spreadInvoker = MethodHandles . spreadInvoker(mt_ref_arg, 0) ; <nl> + MethodHandle mh_spread_target ; <nl> + int result = 42 ; <nl> + try { <nl> + mh_spread_target = <nl> + MethodHandles . lookup() . findStatic(SpreadNullArg . class, target_spread_arg, mt_ref_arg) ; <nl> + result = (int) mh_spreadInvoker . invokeExact(mh_spread_target, (Object[]) null) ; <nl> + } catch(NullPointerException e) { <nl> + } catch(Throwable e) { <nl> + throw new Error(e) ; <nl> + } <nl> + if (result != 42) throw new Error(Expected NullPointerException was not thrown) ; <nl> + } <nl> + public static int target_spread_arg(Integer i1) { <nl> + return i1 . intValue() ; <nl> + } <nl> + } <nl>",
        "commit_message": "added a new class SpreadNullArg that demonstrates using method handles with null arguments to provide an example of handling NullPointerException with method handles in Java",
        "what": "added a new class SpreadNullArg that demonstrates using method handles with null arguments",
        "why": "provide an example of handling NullPointerException with method handles in Java",
        "check": "1"
    },
    {
        "commit_time": "2020-12-22 11:30:28+00:00",
        "diff": "mmm OverlayTest . java <nl> ppp OverlayTest . java <nl> - import org . junit . jupiter . api . AfterEach ; <nl> mmm PDFMergerUtilityTest . java <nl> ppp PDFMergerUtilityTest . java <nl> - import java . io . BufferedReader ; <nl> - import java . io . FileInputStream ; <nl> - import java . io . InputStreamReader ; <nl>",
        "commit_message": "pdfbox-5055 : remove unused import , a suggest by arturo bernal",
        "what": "remove unused import",
        "why": "a suggest by arturo bernal",
        "check": "1"
    },
    {
        "commit_time": "2015-06-06 00:40:34-04:00",
        "diff": "mmm RequestBuilderTest . java <nl> ppp RequestBuilderTest . java <nl> + @Test public void formEncodingFailsOnNonBodyMethod() { <nl> + class Example { <nl> + @FormUrlEncoded // <nl> + @GET(/) // <nl> + Call<Object> method() { <nl> + return null ; <nl> + } <nl> + } <nl> + try { <nl> + buildRequest(Example . class) ; <nl> + fail() ; <nl> + } catch (IllegalArgumentException e) { <nl> + assertThat(e) . hasMessage( <nl> + Example . method: FormUrlEncoded can only be specified on HTTP methods with request body (e . g . , @POST) . ) ; <nl> + } <nl> + } <nl> + @Test public void formEncodingFailsWithNoParts() { <nl> + class Example { <nl> + @FormUrlEncoded // <nl> + @POST(/) // <nl> + Call<Object> method() { <nl> + return null ; <nl> + } <nl> + } <nl> + try { <nl> + buildRequest(Example . class) ; <nl> + fail() ; <nl> + } catch (IllegalArgumentException e) { <nl> + assertThat(e) . hasMessage(Example . method: Form-encoded method must contain at least one @Field . ) ; <nl> + } <nl> + } <nl>",
        "commit_message": "add tests to validate form encoding behavior in RequestBuilder to ensure correct enforcement of HTTP method requirements for form-encoded requests",
        "what": "add tests to validate form encoding behavior in RequestBuilder",
        "why": "ensure correct enforcement of HTTP method requirements for form-encoded requests",
        "check": "1"
    },
    {
        "commit_time": "2012-01-20 10:32:03-07:00",
        "diff": "mmm SslBytesServerTest . java <nl> ppp SslBytesServerTest . java <nl> + import static org . hamcrest . Matchers . * ; <nl> - import static org . hamcrest . Matchers . greaterThan ; <nl> - import static org . hamcrest . Matchers . lessThan ; <nl> - import static org . hamcrest . Matchers . containsString ; <nl> - import static org . hamcrest . Matchers . not ; <nl> - Assert . assertThat(httpParses . get(), lessThan(1000)) ; <nl> + Assert . assertThat(httpParses . get(), lessThan(1500)) ; <nl>",
        "commit_message": "tweak test assertion for variety of value see in various jvms ( with comment )",
        "what": "tweak test assertion for variety of value",
        "why": "see in various jvms (with comment)",
        "check": "1"
    },
    {
        "commit_time": "2020-08-14 10:09:21+02:00",
        "diff": "mmm SettingsActivity . java <nl> ppp SettingsActivity . java <nl> - alertDialog . getButton(AlertDialog . BUTTON_POSITIVE) . setTextColor(accentColor) ; <nl> + alertDialog . getButton(AlertDialog . BUTTON_POSITIVE) . setTextColor(accentColor) ; <nl>",
        "commit_message": "fix # 6675 correct call order when tint the dialog button",
        "what": "fix call order when tint the dialog button",
        "why": "related to issue #6675",
        "check": "1"
    },
    {
        "commit_time": "2012-12-26 13:36:59+00:00",
        "diff": "mmm BrokerService . java <nl> ppp BrokerService . java <nl> - return started . get() ; <nl> + return started . get() && startedLatch . getCount() == 0 ; <nl> - while (isStarted() && !stopped . get() && !waitSucceeded) { <nl> + while (!isStarted() && !stopped . get() && !waitSucceeded) { <nl> mmm VMTransportFactory . java <nl> ppp VMTransportFactory . java <nl> - while (broker == null  && expiry > System . currentTimeMillis()) { <nl> + while ((broker == null || !broker . isStarted()) && expiry > System . currentTimeMillis()) { <nl>",
        "commit_message": "fix for vmtransportwaitfortest test , prevent broker from be start twice",
        "what": "fix for vmtransportwaitfortest test",
        "why": "prevent broker from be start twice",
        "check": "1"
    },
    {
        "commit_time": "2012-04-10 13:50:03+00:00",
        "diff": "mmm ShingleFilter . java <nl> ppp ShingleFilter . java <nl> + nextInputStreamToken = null ; <nl> + isNextInputStreamToken = false ; <nl> mmm TestRandomChains . java <nl> ppp TestRandomChains . java <nl> - || c . isAnnotationPresent(Deprecated . class) <nl> - || !(Tokenizer . class . isAssignableFrom(c) || TokenFilter . class . isAssignableFrom(c) || CharStream . class . isAssignableFrom(c)) <nl> + || c . isAnnotationPresent(Deprecated . class) <nl> + || !(Tokenizer . class . isAssignableFrom(c) || TokenFilter . class . isAssignableFrom(c) || CharStream . class . isAssignableFrom(c)) <nl> - if (ctor . isAnnotationPresent(Deprecated . class) || ctor . isSynthetic()) { <nl> + if (ctor . isSynthetic() || ctor . isAnnotationPresent(Deprecated . class)) { <nl> - byte bytes[] = new byte[1] ; <nl> - random . nextBytes(bytes) ; <nl> - return Byte . valueOf(bytes[0]) ; <nl> + return Byte . valueOf((byte) random . nextInt(256)) ; <nl> - boolean readSomething ; <nl> + boolean readSomething = false ; <nl>",
        "commit_message": "fix shinglefilter reuse , some minor change to testcase for speed and consistency",
        "what": "fix shinglefilter reuse, some minor change to testcase",
        "why": "for speed and consistency",
        "check": "1"
    },
    {
        "commit_time": "2016-03-06 17:54:08+00:00",
        "diff": "mmm NoExceptionsTest . java <nl> ppp NoExceptionsTest . java <nl> + t(seg2=Segment[Pt3,Pt4]) ; <nl> + t(LocusEquation[ seg1==seg2, Pt4 ]) ; <nl>",
        "commit_message": "implicit locus : add unit test for additional syntax of locusequation",
        "what": "add unit test for additional syntax of locusequation",
        "why": "implicit locus",
        "check": "1"
    },
    {
        "commit_time": "2023-02-26 13:17:40-06:00",
        "diff": "mmm CasAuthenticationAuthenticationEventListener . java <nl> ppp CasAuthenticationAuthenticationEventListener . java <nl> - import org . apereo . inspektr . common . web . ClientInfo ; <nl> + import org . apereo . inspektr . common . web . ClientInfo ; <nl> - val dto = prepareCasEvent(event,event . getClientInfo()) ; <nl> + val dto = prepareCasEvent(event, event . getClientInfo()) ; <nl> - val dto = prepareCasEvent(event,event . getClientInfo()) ; <nl> + val dto = prepareCasEvent(event, event . getClientInfo()) ; <nl> - val dto = prepareCasEvent(event,event . getClientInfo()) ; <nl> + val dto = prepareCasEvent(event, event . getClientInfo()) ; <nl> - val dto = prepareCasEvent(event,event . getClientInfo()) ; <nl> + val dto = prepareCasEvent(event, event . getClientInfo()) ; <nl> - val dto = prepareCasEvent(event,event . getClientInfo()) ; <nl> + val dto = prepareCasEvent(event, event . getClientInfo()) ; <nl> mmm AbstractResourceBasedServiceRegistry . java <nl> ppp AbstractResourceBasedServiceRegistry . java <nl> - publishEvent(new CasRegisteredServiceDeletedEvent(this, service , clientInfo)) ; <nl> + publishEvent(new CasRegisteredServiceDeletedEvent(this, service, clientInfo)) ; <nl> mmm CreateResourceBasedRegisteredServiceWatcher . java <nl> ppp CreateResourceBasedRegisteredServiceWatcher . java <nl> - LOG_SERVICE_DUPLICATE . accept(service) ;                    } <nl> + LOG_SERVICE_DUPLICATE . accept(service) ; <nl> + } <nl>",
        "commit_message": "unified code formatting by adding spaces after commas in method calls to improve code readability and maintainability",
        "what": "unified code formatting by adding spaces after commas in method calls",
        "why": "improve code readability and maintainability",
        "check": "1"
    },
    {
        "commit_time": "2019-08-26 11:46:54+01:00",
        "diff": "mmm ServerSocket . java <nl> ppp ServerSocket . java <nl>  <nl>",
        "commit_message": "8222363 : update serversocket.isbound spec to reflect implementation after close",
        "what": "update serversocket.isbound spec to reflect implementation",
        "why": "after close",
        "check": "0"
    },
    {
        "commit_time": "2015-06-29 13:29:36+05:30",
        "diff": "mmm DefaultMobStoreCompactor . java <nl> ppp DefaultMobStoreCompactor . java <nl> - true, fd . maxMVCCReadpoint >= smallestReadPoint, true) ; <nl> + true, true, true) ; <nl> - if (cleanSeqId && c . getSequenceId() <= smallestReadPoint) { <nl> - CellUtil . setSequenceId(c, 0) ; <nl> - } <nl> mmm TestMobCompactor . java <nl> ppp TestMobCompactor . java <nl> - hcd1 . setMobThreshold(0L) ; <nl> + hcd1 . setMobThreshold(5) ; <nl> - hcd2 . setMobThreshold(0L) ; <nl> + hcd2 . setMobThreshold(5) ; <nl> - hcd1 . setMobThreshold(5) ; <nl> + hcd1 . setMobThreshold(0) ; <nl> - hcd2 . setMobThreshold(5) ; <nl> + hcd2 . setMobThreshold(0) ; <nl> - assertEquals(Before compaction: mob value of k0, new, <nl> + assertEquals(Before compaction: mob value of k0, newValue0, <nl> - assertEquals(After compaction: mob value of k0, new, <nl> + assertEquals(After compaction: mob value of k0, newValue0, <nl> + get = new Get(key1) ; <nl> + @Test <nl> + public void testScannerAfterCompactions() throws Exception { <nl> + long ts = EnvironmentEdgeManager . currentTime() ; <nl> + byte[] key0 = Bytes . toBytes(k0) ; <nl> + byte[] key1 = Bytes . toBytes(k1) ; <nl> + String value = mobValue ; // larger than threshold <nl> + String newValue = new ; <nl> + Put put0 = new Put(key0) ; <nl> + put0 . addColumn(Bytes . toBytes(family1), Bytes . toBytes(qf1), ts, Bytes . toBytes(value)) ; <nl> + loadData(admin, bufMut, tableName, new Put[] { put0 }) ; <nl> + Put put1 = new Put(key1) ; <nl> + put1 . addColumn(Bytes . toBytes(family1), Bytes . toBytes(qf1), ts, Bytes . toBytes(value)) ; <nl> + loadData(admin, bufMut, tableName, new Put[] { put1 }) ; <nl> + put1 = new Put(key1) ; <nl> + put1 . addColumn(Bytes . toBytes(family1), Bytes . toBytes(qf1), ts, Bytes . toBytes(newValue)) ; <nl> + loadData(admin, bufMut, tableName, new Put[] { put1 }) ; // now two mob files <nl> + admin . majorCompact(tableName) ; <nl> + waitUntilCompactionFinished(tableName) ; <nl> + admin . majorCompactMob(tableName, hcd1 . getName()) ; <nl> + waitUntilMobCompactionFinished(tableName) ; <nl> + Get get = new Get(key1) ; <nl> + Result result = hTable . get(get) ; <nl> + Cell cell = result . getColumnLatestCell(hcd1 . getName(), Bytes . toBytes(qf1)) ; <nl> + assertEquals(After compaction: mob value, new, Bytes . toString(CellUtil . cloneValue(cell))) ; <nl> + } <nl> + private void waitUntilCompactionFinished(TableName tableName) throws IOException, <nl> + InterruptedException { <nl> + long finished = EnvironmentEdgeManager . currentTime() 60000 ; <nl> + CompactionState state = admin . getCompactionState(tableName) ; <nl> + while (EnvironmentEdgeManager . currentTime() < finished) { <nl> + if (state == CompactionState . NONE) { <nl> + break ; <nl> + } <nl> + state = admin . getCompactionState(tableName) ; <nl> + Thread . sleep(10) ; <nl> + } <nl> + assertEquals(CompactionState . NONE, state) ; <nl> + } <nl>",
        "commit_message": "hbase-13922 do not reset mvcc in compaction for mob-enabled column . ( jingcheng du )",
        "what": "do not reset mvcc in compaction for mob-enabled column",
        "why": "related to hbase-13922",
        "check": "1"
    },
    {
        "commit_time": "2020-01-16 13:56:01+00:00",
        "diff": "mmm AtomicCounter . java <nl> ppp AtomicCounter . java <nl> - , value= + get() + <nl> + , value= (isClosed ? -1 : get()) + <nl> mmm AtomicLongPosition . java <nl> ppp AtomicLongPosition . java <nl> - , value= + value + <nl> + , value= (isClosed ? -1 : value) + <nl> mmm UnsafeBufferPosition . java <nl> ppp UnsafeBufferPosition . java <nl> - , value= + getVolatile() + <nl> + , value= (isClosed ? -1 : getVolatile()) + <nl>",
        "commit_message": "update value retrieval in AtomicCounter, AtomicLongPosition, and UnsafeBufferPosition classes to return -1 if closed to improve error handling for closed states in the atomic classes",
        "what": "update value retrieval in AtomicCounter, AtomicLongPosition, and UnsafeBufferPosition classes to return -1 if closed",
        "why": "improve error handling for closed states in the atomic classes",
        "check": "1"
    },
    {
        "commit_time": "2016-04-29 09:54:56-07:00",
        "diff": "mmm TestMiniSolrCloudClusterSSL . java <nl> ppp TestMiniSolrCloudClusterSSL . java <nl> - import javax . net . ssl . SSLHandshakeException ; <nl> - expectThrows(SSLHandshakeException . class, () -> { <nl> + expectThrows(IOException . class, () -> { <nl>",
        "commit_message": "solr-9028 : relax the sslhandshakeexception expectation - in some platforms/java # diff ioexceptions be thrown",
        "what": "relax the sslhandshakeexception expectation",
        "why": "in some platforms/java # diff ioexceptions be thrown",
        "check": "1"
    },
    {
        "commit_time": "2008-12-29 18:55:20+00:00",
        "diff": "mmm DSpaceMETSGenerator . java <nl> ppp DSpaceMETSGenerator . java <nl> - if (ConfigurationManager . getProperty(handle . prefix) . equals(id)) <nl> - adapter = new RepositoryAdapter(context,contextPath) ; <nl> + if (ConfigurationManager . getProperty(handle . prefix) . equals(String . valueOf(id))) <nl> + adapter = new RepositoryAdapter(context,contextPath) ; <nl>",
        "commit_message": "fixed small bug in xmlui 's org.dspace.app.xmlui.cocoon.dspacemetsgenerator which cause repository-wide mets file to fail to generate .",
        "what": "fixed small bug in xmlui's org.dspace.app.xmlui.cocoon.dspacemetsgenerator",
        "why": "which caused repository-wide mets file to fail to generate",
        "check": "1"
    },
    {
        "commit_time": "2016-04-29 11:20:17+02:00",
        "diff": "mmm BTCEAdapters . java <nl> ppp BTCEAdapters . java <nl> - Currency currency = Currency . getInstance(lcCurrency . toUpperCase()) ; <nl> - balances . add(new Balance(currency, funds . get(lcCurrency))) ; <nl> + BigDecimal fund = funds . get(lcCurrency) ; <nl> + if (lcCurrency . equals(dsh)) { <nl> + lcCurrency = dash ; <nl> + } <nl> + Currency currency = Currency . getInstance(lcCurrency) ; <nl> + balances . add(new Balance(currency, fund)) ; <nl> - String[] pair = bTCEOrder . getPair() . split(_) ; <nl> - CurrencyPair currencyPair = new CurrencyPair(pair[0] . toUpperCase(), pair[1] . toUpperCase()) ; <nl> + CurrencyPair currencyPair = adaptCurrencyPair(bTCEOrder . getPair()) ; <nl> + if (currencies[0] . equals(dsh)) { <nl> + currencies[0] = dash ; <nl> + } <nl> + if (currencies[1] . equals(dsh)) { <nl> + currencies[1] = dash ; <nl> + } <nl> - public static String adaptCurrencyPair(CurrencyPair currencyPair) { <nl> - return (currencyPair . base . getCurrencyCode() + _ + currencyPair . counter . getCurrencyCode()) . toLowerCase() ; <nl> - } <nl> - return currencyPair . base . getCurrencyCode() . toLowerCase() + _ + currencyPair . counter . getCurrencyCode() . toLowerCase() ; <nl> + String base = currencyPair . base . getCurrencyCode() ; <nl> + String counter = currencyPair . counter . getCurrencyCode() ;     <nl> + if (base . equals(DASH)) { <nl> + base = DSH ; <nl> + } <nl> + else if (counter . equals(DASH)) { <nl> + counter = DSH ; <nl> + }  <nl> + return (base _ counter) . toLowerCase() ; <nl>",
        "commit_message": "modified currency handling for dsh to be displayed as dash and adjusted currency pair formatting to improve consistency and clarity in currency representation within the application",
        "what": "modified currency handling for dsh to be displayed as dash and adjusted currency pair formatting",
        "why": "improve consistency and clarity in currency representation within the application",
        "check": "1"
    },
    {
        "commit_time": "2017-03-14 12:49:13-07:00",
        "diff": "mmm AppleBinaryDescription . java <nl> ppp AppleBinaryDescription . java <nl> - Optional<BuildRule> swiftCompanionBuildRule = swiftDelegate . createCompanionBuildRule( <nl> - targetGraph, params, resolver, args) ; <nl> - if (swiftCompanionBuildRule . isPresent()) { <nl> - if (isSwiftTarget(params . getBuildTarget())) { <nl> - return swiftCompanionBuildRule . get() ; <nl> - } else { <nl> - params = params . appendExtraDeps(ImmutableSet . of(swiftCompanionBuildRule . get())) ; <nl> - } <nl> - } <nl> + Optional<BuildRule> swiftCompanionBuildRule = swiftDelegate . createCompanionBuildRule( <nl> + targetGraph, params, resolver, args) ; <nl> + if (swiftCompanionBuildRule . isPresent()) { <nl> + if (isSwiftTarget(params . getBuildTarget())) { <nl> + return swiftCompanionBuildRule . get() ; <nl> + } else { <nl> + params = params . appendExtraDeps(ImmutableSet . of(swiftCompanionBuildRule . get())) ; <nl> + } <nl> + } <nl> mmm AppleLibraryDescription . java <nl> ppp AppleLibraryDescription . java <nl> - Optional<BuildRule> swiftCompanionBuildRule = swiftDelegate . createCompanionBuildRule( <nl> - targetGraph, params, resolver, args) ; <nl> - if (swiftCompanionBuildRule . isPresent()) { <nl> - if (isSwiftTarget(params . getBuildTarget())) { <nl> - return swiftCompanionBuildRule . get() ; <nl> - } else { <nl> - args . exportedDeps = ImmutableSortedSet . <BuildTarget>naturalOrder() <nl> -  . addAll(args . exportedDeps) <nl> -  . add(swiftCompanionBuildRule . get() . getBuildTarget()) <nl> -  . build() ; <nl> - params = params . appendExtraDeps(ImmutableSet . of(swiftCompanionBuildRule . get())) ; <nl> - } <nl> - } <nl> + targetGraph, <nl> + TargetGraph targetGraph, <nl> + targetGraph, <nl> + targetGraph, <nl> + TargetGraph targetGraph, <nl> + Optional<BuildRule> swiftCompanionBuildRule = swiftDelegate . createCompanionBuildRule( <nl> + targetGraph, params, resolver, args) ; <nl> + if (swiftCompanionBuildRule . isPresent()) { <nl> + if (isSwiftTarget(params . getBuildTarget())) { <nl> + return swiftCompanionBuildRule . get() ; <nl> + } else { <nl> + args . exportedDeps = ImmutableSortedSet . <BuildTarget>naturalOrder() <nl> +  . addAll(args . exportedDeps) <nl> +  . add(swiftCompanionBuildRule . get() . getBuildTarget()) <nl> +  . build() ; <nl> + params = params . appendExtraDeps(ImmutableSet . of(swiftCompanionBuildRule . get())) ; <nl> + } <nl> + } <nl> mmm AppleBinaryIntegrationTest . java <nl> ppp AppleBinaryIntegrationTest . java <nl> + @Test <nl> + public void testAppleBinaryBuildsFatBinariesWithSwift() throws Exception { <nl> + assumeTrue(Platform . detect() == Platform . MACOS) ; <nl> + ProjectWorkspace workspace = TestDataHelper . createProjectWorkspaceForScenario( <nl> + this, mixed_swift_objc_application_bundle_dwarf_and_dsym, tmp) ; <nl> + workspace . setUp() ; <nl> + BuildTarget target = BuildTargetFactory . newInstance( <nl> + //:DemoAppBinary#iphonesimulator-i386,iphonesimulator-x86_64,no-linkermap) ; <nl> + workspace . runBuckCommand(build, target . getFullyQualifiedName()) . assertSuccess() ; <nl> + Path output = workspace . getPath(BuildTargets . getGenPath(filesystem, target, %s)) ; <nl> + assertThat(Files . exists(output), is(true)) ; <nl> + assertThat( <nl> + workspace . runCommand(file, output . toString()) . getStdout() . get(), <nl> + containsString(executable)) ; <nl> + ProcessExecutor . Result lipoVerifyResult = <nl> + workspace . runCommand(lipo, output . toString(), -verify_arch, i386, x86_64) ; <nl> + assertEquals( <nl> + lipoVerifyResult . getStderr() . orElse(), <nl> + 0, <nl> + lipoVerifyResult . getExitCode()) ; <nl> + } <nl>",
        "commit_message": "updated AppleBinaryDescription and AppleLibraryDescription to include TargetGraph as a parameter and made necessary adjustments to associated logic to enhances clarity and correctness of target graph handling for Swift build rules",
        "what": "updated AppleBinaryDescription and AppleLibraryDescription to include TargetGraph as a parameter and made necessary adjustments to associated logic",
        "why": "enhances clarity and correctness of target graph handling for Swift build rules",
        "check": "1"
    },
    {
        "commit_time": "2016-12-19 14:49:15-08:00",
        "diff": "mmm SizedJBlock . java <nl> ppp SizedJBlock . java <nl> - this . count = 0 ; <nl> + this . count = 1 ; <nl> mmm TestLargeFileCompilation . java <nl> ppp TestLargeFileCompilation . java <nl> - import org . junit . Ignore ; <nl> - @Ignore(DRILL-1808) <nl> - @Ignore(DRILL-1808) <nl>",
        "commit_message": "updated the count initialization from 0 to 1 in SizedJBlock.java and removed JUnit ignore annotations related to DRILL-1808 in TestLargeFileCompilation.java to ensure correct count functionality and eliminate deprecated test ignore statements",
        "what": "updated the count initialization from 0 to 1 in SizedJBlock.java and removed JUnit ignore annotations related to DRILL-1808 in TestLargeFileCompilation.java",
        "why": "ensure correct count functionality and eliminate deprecated test ignore statements",
        "check": "1"
    },
    {
        "commit_time": "2012-01-04 15:25:25+00:00",
        "diff": "mmm FirefoxProfile . java <nl> ppp FirefoxProfile . java <nl> -  . put(toolkit . telemetry . prompted, 2) <nl> +  . put(toolkit . telemetry . prompted, true) <nl>",
        "commit_message": "danielwagnerhall : toolkit.telemetry.prompted be a boolean setting - set it thus . fix issue 3144 .",
        "what": "set toolkit.telemetry.prompted to be a boolean setting",
        "why": "fix issue 3144",
        "check": "1"
    },
    {
        "commit_time": "2015-05-11 09:36:29+02:00",
        "diff": "mmm CtType . java <nl> ppp CtType . java <nl> - } <nl> + } <nl>",
        "commit_message": "fix documentation to addnestedtype ( ) /removenestedtype ( ) in cttype",
        "what": "fix documentation to addnestedtype ( ) /removenestedtype ( ) in cttype",
        "why": "improve clarity of the documentation",
        "check": "1"
    },
    {
        "commit_time": "2016-08-07 11:29:59+10:00",
        "diff": "mmm PlayerEvents . java <nl> ppp PlayerEvents . java <nl> - for (IntegerFlag flag : flags) { <nl> - int i ; <nl> - switch (flag . getName()) { <nl> - case entity-cap: <nl> - i = 0 ; <nl> - break ; <nl> - case mob-cap: <nl> - i = 3 ; <nl> - break ; <nl> - case hostile-cap: <nl> - i = 2 ; <nl> - break ; <nl> - case animal-cap: <nl> - i = 1 ; <nl> - break ; <nl> - case vehicle-cap: <nl> - i = 4 ; <nl> - break ; <nl> - case misc-cap: <nl> - i = 5 ; <nl> - break ; <nl> - default: <nl> - i = 0 ; <nl> - } <nl> - mobs[i]++ ; <nl> - } <nl> + for (IntegerFlag flag : flags) { <nl> + int i ; <nl> + switch (flag . getName()) { <nl> + case entity-cap: <nl> + i = 0 ; <nl> + break ; <nl> + case mob-cap: <nl> + i = 3 ; <nl> + break ; <nl> + case hostile-cap: <nl> + i = 2 ; <nl> + break ; <nl> + case animal-cap: <nl> + i = 1 ; <nl> + break ; <nl> + case vehicle-cap: <nl> + i = 4 ; <nl> + break ; <nl> + case misc-cap: <nl> + i = 5 ; <nl> + break ; <nl> + default: <nl> + i = 0 ; <nl> + } <nl> + mobs[i]++ ; <nl> + } <nl> mmm GlobalBlockQueue . java <nl> ppp GlobalBlockQueue . java <nl> - final ConcurrentLinkedDeque<Runnable> tmp = new ConcurrentLinkedDeque<>(this . runnables) ; <nl> + final ArrayList<Runnable> tmp = new ArrayList<>(this . runnables) ; <nl> mmm ExpireManager . java <nl> ppp ExpireManager . java <nl> - import java . util . Set ; <nl> + import java . util . concurrent . ConcurrentLinkedDeque ; <nl> - final Set<Plot> plots = PS . get() . getPlots() ; <nl> + final ConcurrentLinkedDeque<Plot> plots = new ConcurrentLinkedDeque<Plot>(PS . get() . getPlots()) ; <nl> - Iterator<Plot> iterator = plots . iterator() ; <nl> - while (iterator . hasNext() && System . currentTimeMillis() start < 2) { <nl> + while (!plots . isEmpty()) { <nl> - final Plot plot = iterator . next() ; <nl> - iterator . remove() ; <nl> + final Plot plot = plots . poll() ; <nl> - expiredTask . run(plot, this, expiryTask . requiresConfirmation()) ; <nl> + expiredTask . run(plot, new Runnable() { <nl> + @Override <nl> + public void run() { <nl> + TaskManager . IMP . taskLaterAsync(this, 1) ; <nl> + } <nl> + }, expiryTask . requiresConfirmation()) ; <nl> + return ; <nl> - expiredTask . run(plot, task, confirmation) ; <nl> + expiredTask . run(plot, new Runnable() { <nl> + @Override <nl> + public void run() { <nl> + TaskManager . IMP . taskLaterAsync(task, 1) ; <nl> + } <nl> + }, confirmation) ; <nl> - task . run() ; <nl> + TaskManager . IMP . taskLaterAsync(task, 1) ; <nl>",
        "commit_message": "refactor PlayerEvents logic for clarity and update GlobalBlockQueue and ExpireManager to utilize more efficient collection types to improve performance and maintainability of the code",
        "what": "refactor PlayerEvents logic for clarity and update GlobalBlockQueue and ExpireManager to utilize more efficient collection types",
        "why": "improve performance and maintainability of the code",
        "check": "1"
    },
    {
        "commit_time": "2016-03-13 11:53:09-04:00",
        "diff": "mmm Pause . java <nl> ppp Pause . java <nl>  <nl> mmm SerialPortToolbarBox . java <nl> ppp SerialPortToolbarBox . java <nl>  <nl> mmm Start . java <nl> ppp Start . java <nl>  <nl> mmm Stop . java <nl> ppp Stop . java <nl>  <nl>",
        "commit_message": "updated pause, start, and stop classes along with the serial port toolbar box to improve code organization and maintainability",
        "what": "updated pause, start, and stop classes along with the serial port toolbar box",
        "why": "improve code organization and maintainability",
        "check": "1"
    },
    {
        "commit_time": "2024-03-01 16:56:59-08:00",
        "diff": "mmm SegmentProcessorFrameworkTest . java <nl> ppp SegmentProcessorFrameworkTest . java <nl> + import org . apache . pinot . spi . data . readers . RecordReaderFactory ; <nl> - RecordReaderFileConfig reader = new RecordReaderFileConfig(FileFormat . CSV, <nl> - new File(resource . toURI()), <nl> + RecordReader recordReader = RecordReaderFactory . getRecordReader(FileFormat . CSV, new File(resource . toURI()), <nl> + RecordReaderFileConfig recordReaderFileConfig = new RecordReaderFileConfig(FileFormat . CSV, <nl> + new File(resource . toURI()), <nl> + null, null, recordReader) ; <nl> - SegmentProcessorFramework framework = new SegmentProcessorFramework(config, workingDir, ImmutableList . of(reader), <nl> - Collections . emptyList(), null) ; <nl> + SegmentProcessorFramework framework = new SegmentProcessorFramework(config, workingDir, <nl> + ImmutableList . of(recordReaderFileConfig), Collections . emptyList(), null) ; <nl> + assertEquals(recordReaderFileConfig . isRecordReaderClosedFromRecordReaderFileConfig(), true) ; <nl> - new RecordReaderFileConfig(FileFormat . CSV, new File(resource . toURI()), null, null) ; <nl> + new RecordReaderFileConfig(FileFormat . CSV, new File(resource . toURI()), null, null, null) ; <nl> - recordReaderFileConfig = new RecordReaderFileConfig(FileFormat . CSV, new File(resource . toURI()), null, null) ; <nl> + recordReaderFileConfig = new RecordReaderFileConfig(FileFormat . CSV, new File(resource . toURI()), null, null, null) ; <nl> mmm RecordReaderFileConfig . java <nl> ppp RecordReaderFileConfig . java <nl> - @Nullable RecordReaderConfig recordReaderConfig) { <nl> + @Nullable RecordReaderConfig recordReaderConfig, @Nullable RecordReader recordReader) { <nl> - _recordReader = null ; <nl> + _recordReader = recordReader ; <nl> + @Deprecated <nl> - _recordReader = RecordReaderFactory . getRecordReader(_fileFormat, _dataFile, _fieldsToRead, _recordReaderConfig) ; <nl> + if (_recordReader == null) { <nl> + _recordReader = RecordReaderFactory . getRecordReader(_fileFormat, _dataFile, _fieldsToRead, _recordReaderConfig) ; <nl> + } else { <nl> + _recordReader . init(_dataFile, _fieldsToRead, _recordReaderConfig) ; <nl> + } <nl>",
        "commit_message": "allow pass custom record reader to be inited/closed in segmentprocessorframework ( # 12529 )",
        "what": "allow pass custom record reader to be inited/closed in segmentprocessorframework",
        "why": "improve flexibility in handling record readers within the segment processor framework",
        "check": "1"
    },
    {
        "commit_time": "2010-12-01 22:54:12+00:00",
        "diff": "mmm Platform . java <nl> ppp Platform . java <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + import com . sun . jna . NativeMapped ; <nl> + import com . sun . jna . PointerType ; <nl> + import com . sun . jna . win32 . W32APIFunctionMapper ; <nl> + import com . sun . jna . win32 . W32APITypeMapper ; <nl> - String keyPath = <nl> - Software\\\\Microsoft\\\\Windows\\\\CurrentVersion + <nl> - \\\\Explorer\\\\Shell Folders ; <nl> - String appDataPath = <nl> - Registry . getStringValue(REGISTRY_ROOT_KEY . CURRENT_USER, keyPath, AppData) ; <nl> + char[] pszPath = new char[Shell32 . MAX_PATH] ; // this will be contain the path if SHGetFolderPath is successful <nl> + int hResult = Shell32 . INSTANCE . SHGetFolderPath(null, Shell32 . CSIDL_APPDATA, null, Shell32 . SHGFP_TYPE_CURRENT, pszPath) ; <nl> + if (Shell32 . S_OK != hResult){  <nl> + throw new Exception(Problem city, population your computer) ; <nl> + } <nl> - File dataFolder = new File(appDataPath, Processing) ; <nl> - return dataFolder ; <nl> + String appDataPath = new String(pszPath) ; <nl> + int len = appDataPath . indexOf(\\0) ; <nl> + appDataPath = appDataPath . substring(0, len) ; <nl> + return new File(appDataPath, Processing) ; <nl> - String keyPath = <nl> - Software\\\\Microsoft\\\\Windows\\\\CurrentVersion + <nl> - \\\\Explorer\\\\Shell Folders ; <nl> - String personalPath = <nl> - Registry . getStringValue(REGISTRY_ROOT_KEY . CURRENT_USER, keyPath, Personal) ; <nl> + char[] pszPath = new char[Shell32 . MAX_PATH] ; // this will be contain the path if SHGetFolderPath is successful <nl> + int hResult = Shell32 . INSTANCE . SHGetFolderPath(null, Shell32 . CSIDL_PERSONAL, null, Shell32 . SHGFP_TYPE_CURRENT, pszPath) ; <nl> + if (Shell32 . S_OK != hResult){  <nl> + throw new Exception(Problem city, population your computer) ; <nl> + } <nl> + String personalPath = new String(pszPath) ; <nl> + int len = personalPath . indexOf(\\0) ; <nl> + personalPath = personalPath . substring(0, len) ; <nl> + private static Map<String, Object> OPTIONS = new HashMap<String, Object>() ; <nl> + static{ <nl> + OPTIONS . put(Library . OPTION_TYPE_MAPPER, W32APITypeMapper . UNICODE) ; <nl> + OPTIONS . put(Library . OPTION_FUNCTION_MAPPER, W32APIFunctionMapper . UNICODE) ; <nl> + } <nl> + static class HANDLE extends PointerType implements NativeMapped{} <nl> + static class HWND extends HANDLE {} <nl> + public interface Shell32 extends Library{ <nl> + public static final int MAX_PATH = 260 ; <nl> + public static final int SHGFP_TYPE_CURRENT = 0 ; <nl> + public static final int SHGFP_TYPE_DEFAULT = 1 ; <nl> + public static final int S_OK = 0 ; <nl> + public static final int CSIDL_APPDATA = 0x001c ; // Application Data <nl> + public static final int CSIDL_PERSONAL = 0x0005 ;      // My Documents <nl> + static Shell32 INSTANCE = (Shell32) Native . loadLibrary(shell32, Shell32 . class, OPTIONS) ; <nl> + public int SHGetFolderPath(HWND hwndOwner, int nFolder, HANDLE hToken, <nl> + int dwFlags, char[] pszPath) ; <nl> + } <nl>",
        "commit_message": "change window platform code to jna for issue 410 .",
        "what": "change window platform code to jna",
        "why": "for issue 410",
        "check": "1"
    },
    {
        "commit_time": "2016-08-04 20:57:47-07:00",
        "diff": "mmm RepositoryWithCompositeKeyTests . java <nl> ppp RepositoryWithCompositeKeyTests . java <nl> - Page<IdClassExampleEmployee> page = employeeRepositoryWithIdClass . findAll(new PageRequest(0, 10)) ; <nl> + Page<IdClassExampleEmployee> page = employeeRepositoryWithIdClass . findAll(new PageRequest(0, 1)) ; <nl>",
        "commit_message": "changed the page size in the repository's findAll method from 10 to 1 to limit the number of results returned for more manageable testing",
        "what": "changed the page size in the repository's findAll method from 10 to 1",
        "why": "limit the number of results returned for more manageable testing",
        "check": "1"
    },
    {
        "commit_time": "2017-01-29 20:15:24+00:00",
        "diff": "mmm AlgoTangentPoint . java <nl> ppp AlgoTangentPoint . java <nl> - botanaPolynomials = new Polynomial[2] ; <nl> + botanaPolynomials = new Polynomial[4] ; <nl> - Polynomial t_1 = new Polynomial(vparabola[2]) ; <nl> - Polynomial t_2 = new Polynomial(vparabola[3]) ; <nl> + Variable t_1 = new Variable() ; <nl> + Variable t_2 = new Variable() ; <nl> + Polynomial t_1p = new Polynomial(t_1) ; <nl> + Polynomial t_2p = new Polynomial(t_2) ; <nl> -  . subtract(f1) . subtract(t_1) ; <nl> +  . subtract(f1) . subtract(t_1p) ; <nl> -  . subtract(f2) . subtract(t_2) ; <nl> +  . subtract(f2) . subtract(t_2p) ; <nl> + botanaPolynomials[2] = Polynomial . collinear(t_1, t_2, <nl> + vparabola[4], vparabola[5], vparabola[6], vparabola[7]) ; <nl> + botanaPolynomials[3] = Polynomial . equidistant(t_1, t_2, <nl> + vPoint[0], vPoint[1], vparabola[8], vparabola[9]) ; <nl>",
        "commit_message": "le/tp : attempt to fix tangent line equation for a parabola ( numerically still not stable )",
        "what": "attempt to fix tangent line equation for a parabola",
        "why": "numerically still not stable",
        "check": "1"
    },
    {
        "commit_time": "2017-11-14 18:27:43-08:00",
        "diff": "mmm SupportedDHParamGens . java <nl> ppp SupportedDHParamGens . java <nl>  <nl>",
        "commit_message": "updated SupportedDHParamGens.java to include new parameter generation methods to enhance support for additional Diffie-Hellman key exchange configurations",
        "what": "updated SupportedDHParamGens.java to include new parameter generation methods",
        "why": "enhance support for additional Diffie-Hellman key exchange configurations",
        "check": "1"
    },
    {
        "commit_time": "2019-07-22 10:48:14+02:00",
        "diff": "new file <nl> ppp Container . java <nl> + package jdk . test . lib ; <nl> + public class Container { <nl> + public static final String ENGINE_COMMAND = <nl> + System . getProperty(jdk . test . container . command, docker) ; <nl> + } <nl> mmm Platform . java <nl> ppp Platform . java <nl> - public static final String DOCKER_COMMAND = <nl> - System . getProperty(jdk . test . docker . command, docker) ; <nl> mmm DockerTestUtils . java <nl> ppp DockerTestUtils . java <nl> - import jdk . test . lib . Platform ; <nl> + import jdk . test . lib . Container ; <nl> - execute(Platform . DOCKER_COMMAND, ps) <nl> + execute(Container . ENGINE_COMMAND, ps) <nl> - execute(Platform . DOCKER_COMMAND, build, --no-cache, --tag, imageName, buildDir . toString()) <nl> + execute(Container . ENGINE_COMMAND, build, --no-cache, --tag, imageName, buildDir . toString()) <nl> - cmd . add(Platform . DOCKER_COMMAND) ; <nl> + cmd . add(Container . ENGINE_COMMAND) ; <nl> - execute(Platform . DOCKER_COMMAND, rmi, --force, imageNameAndTag) ; <nl> + execute(Container . ENGINE_COMMAND, rmi, --force, imageNameAndTag) ; <nl>",
        "commit_message": "introduced a new class Container and replaced references to Platform.DOCKER_COMMAND with Container.ENGINE_COMMAND to centralize the command configuration and improve code readability",
        "what": "introduced a new class Container and replaced references to Platform.DOCKER_COMMAND with Container.ENGINE_COMMAND",
        "why": "centralize the command configuration and improve code readability",
        "check": "1"
    },
    {
        "commit_time": "2015-01-24 13:18:39-08:00",
        "diff": "mmm TestExampleQueries . java <nl> ppp TestExampleQueries . java <nl> + @Test // DRILL-2063 <nl> + public void testAggExpressionWithGroupBy() throws Exception { <nl> + String query = select l_suppkey, sum(l_extendedprice)/sum(l_quantity) as avg_price \\n + <nl> +  from cp . tpch/lineitem . parquet where l_orderkey in \\n + <nl> +  (select o_orderkey from cp . tpch/orders . parquet where o_custkey = 2) \\n + <nl> +  and l_suppkey = 4 group by l_suppkey ; <nl> + testBuilder() <nl> +  . sqlQuery(query) <nl> +  . ordered() <nl> +  . baselineColumns(l_suppkey, avg_price) <nl> +  . baselineValues(4, 1374 . 47) <nl> +  . build() . run() ; <nl> + } <nl>",
        "commit_message": "drill-2063 : fix be in calcite ( ensure uniqueness of field in the row type of aggregaterel ) . add unit test and bump up calcite version to 0.9-drill-r18 .",
        "what": "fix be in calcite (ensure uniqueness of field in the row type of aggregaterel), add unit test and bump up calcite version to 0.9-drill-r18",
        "why": "ensure uniqueness of field in the row type of aggregaterel",
        "check": "1"
    },
    {
        "commit_time": "2015-07-03 12:18:13+01:00",
        "diff": "mmm MessagePriorityTest . java <nl> ppp MessagePriorityTest . java <nl> - public void initCombosForTestLowThenHighBatc() { <nl> + public void initCombosForTestLowThenHighBatch() { <nl>",
        "commit_message": "http : //issues.apache.org/jira/browse/amq-5853 - fix typo in test combination - ensure expiry do not kick in",
        "what": "fix typo in test combination",
        "why": "ensure expiry do not kick in",
        "check": "1"
    },
    {
        "commit_time": "2013-12-10 15:22:03+01:00",
        "diff": "mmm BaseActivity . java <nl> ppp BaseActivity . java <nl> + import java . io . File ; <nl> + import java . io . IOException ; <nl> + import it . feio . android . omninotes . utils . StorageManager ; <nl> + import android . util . Log ; <nl> + createAppDirectory() ; <nl> + private void createAppDirectory() { <nl> + File destinationDir = new File(StorageManager . getExternalStorageDir() <nl> + File . separator Constants . APP_STORAGE_DIRECTORY) ; <nl> + destinationDir . mkdirs() ; <nl> + File nomedia = new File(destinationDir,  . nomedia) ; <nl> + try { <nl> + if (!nomedia . createNewFile())  <nl> + throw new IOException() ; <nl> + } catch (IOException e) { <nl> + Log . e(Constants . TAG, Error creating nomedia file in app directory) ; <nl> + } <nl> + } <nl>",
        "commit_message": "added a method to create an application directory and a .nomedia file within it to ensure that app-specific media files are not scanned by external media players",
        "what": "added a method to create an application directory and a .nomedia file within it",
        "why": "ensure that app-specific media files are not scanned by external media players",
        "check": "1"
    },
    {
        "commit_time": "2022-01-19 17:23:37-05:00",
        "diff": "mmm System . java <nl> ppp System . java <nl> + @Deprecated(forRemoval=true, since=18) <nl> mmm MemoryMXBeanImpl . java <nl> ppp MemoryMXBeanImpl . java <nl> + @SuppressWarnings(deprecation) <nl> mmm MemoryMXBean . java <nl> ppp MemoryMXBean . java <nl> + - * Copyright (c) 2005, 2018 IBM Corp .  and others <nl> + @Deprecated(forRemoval=false, since=18) <nl>",
        "commit_message": "added deprecation annotations to System, MemoryMXBean, and MemoryMXBeanImpl classes to indicate that these classes are deprecated and will be removed in future versions",
        "what": "added deprecation annotations to System, MemoryMXBean, and MemoryMXBeanImpl classes",
        "why": "indicate that these classes are deprecated and will be removed in future versions",
        "check": "1"
    },
    {
        "commit_time": "2012-09-17 04:56:26-07:00",
        "diff": "mmm ForgeInternalHandler . java <nl> ppp ForgeInternalHandler . java <nl> - if (item . getItem() . hasCustomEntity(item)) <nl> + if (item != null && item . getItem() . hasCustomEntity(item)) <nl>",
        "commit_message": "fix potential npe in custom item entity span code cause by item id misconfigurations .",
        "what": "fix potential npe in custom item entity span code",
        "why": "caused by item id misconfigurations",
        "check": "1"
    },
    {
        "commit_time": "2013-03-27 14:23:11+00:00",
        "diff": "mmm SideMenuBar . java <nl> ppp SideMenuBar . java <nl> + public void setBackCommand(Command backCommand) {\r <nl> + super . setBackCommand(backCommand) ;\r <nl> + addOpenButton() ;\r <nl> + if (getBackCommand() != null\r <nl> + && getCommandCount() > 0\r <nl> + && !UIManager . getInstance() . isThemeConstant(hideBackCommandBool, false)\r <nl> + && !getCommands() . contains(getBackCommand())) {\r <nl> + getCommands() . insertElementAt(getBackCommand(), 0) ;\r <nl> + }\r <nl> + } <nl>",
        "commit_message": "fix an edge case with back button in the side menu",
        "what": "fix an edge case with back button in the side menu",
        "why": "improve user experience and prevent navigation issues",
        "check": "1"
    },
    {
        "commit_time": "2020-03-26 00:34:43-07:00",
        "diff": "mmm FlingAndHoldTouchController . java <nl> ppp FlingAndHoldTouchController . java <nl> - mMotionPauseMaxDisplacement = getShiftRange() * MAX_DISPLACEMENT_PERCENT ; <nl> + mMotionPauseMaxDisplacement = getMotionPauseMaxDisplacement() ; <nl> + } <nl> + protected float getMotionPauseMaxDisplacement() { <nl> + return getShiftRange() * MAX_DISPLACEMENT_PERCENT ; <nl> mmm NoButtonNavbarToOverviewTouchController . java <nl> ppp NoButtonNavbarToOverviewTouchController . java <nl> + @Override <nl> + protected float getMotionPauseMaxDisplacement() { <nl> + return Float . MAX_VALUE ; <nl> + } <nl>",
        "commit_message": "updated the method getMotionPauseMaxDisplacement to return a calculated value in FlingAndHoldTouchController and to return a constant in NoButtonNavbarToOverviewTouchController to standardize displacement calculations for better consistency across touch controllers",
        "what": "updated the method getMotionPauseMaxDisplacement to return a calculated value in FlingAndHoldTouchController and to return a constant in NoButtonNavbarToOverviewTouchController",
        "why": "standardize displacement calculations for better consistency across touch controllers",
        "check": "1"
    },
    {
        "commit_time": "2016-04-26 00:55:46-07:00",
        "diff": "mmm BoundedLocalCache . java <nl> ppp BoundedLocalCache . java <nl> + return hasWriter() <nl> + ? removeWithWriter(key) <nl> + : removeNoWriter(key) ; <nl> + } <nl> + V removeNoWriter(Object key) { <nl> + Node<K, V> node ; <nl> + Object lookupKey = nodeFactory . newLookupKey(key) ; <nl> + if (!data . containsKey(lookupKey) || ((node = data . remove(lookupKey)) == null)) { <nl> + return null ; <nl> + } <nl> + V oldValue ; <nl> + synchronized (node) { <nl> + oldValue = node . getValue() ; <nl> + if (node . isAlive()) { <nl> + node . retire() ; <nl> + } <nl> + } <nl> + RemovalCause cause ; <nl> + if (oldValue == null) { <nl> + cause = RemovalCause . COLLECTED ; <nl> + } else if (hasExpired(node, expirationTicker() . read())) { <nl> + cause = RemovalCause . EXPIRED ; <nl> + } else { <nl> + cause = RemovalCause . EXPLICIT ; <nl> + } <nl> + afterWrite(node, new RemovalTask(node), 0L) ; <nl> + if (hasRemovalListener()) { <nl> + @SuppressWarnings(unchecked) <nl> + K castKey = (K) key ; <nl> + notifyRemoval(castKey, oldValue, cause) ; <nl> + } <nl> + return (cause == RemovalCause . EXPLICIT) ? oldValue : null ; <nl> + } <nl> + V removeWithWriter(Object key) { <nl> - if ((data . get(lookupKey) == null) || (value == null)) { <nl> + if ((value == null) || !data . containsKey(lookupKey)) { <nl> mmm EvictionTest . java <nl> ppp EvictionTest . java <nl> + import static com . github . benmanes . caffeine . cache . testing . HasStats . hasEvictionWeight ; <nl> - if (cache . policy() . isRecordingStats()) { <nl> - assertThat(cache . stats() . evictionWeight(), is(12L)) ; <nl> - } <nl> + assertThat(context, hasEvictionCount(2L)) ; <nl> + assertThat(context, hasEvictionWeight(12L)) ; <nl> - if (context . isCaffeine() && cache . policy() . isRecordingStats()) { <nl> - assertThat(cache . stats() . evictionWeight(), is(20L)) ; <nl> + if (context . isCaffeine()) { <nl> + assertThat(context, hasEvictionWeight(20L)) ; <nl> + assertThat(context, hasEvictionWeight(5L)) ; <nl> mmm HasStats . java <nl> ppp HasStats . java <nl> - HIT, MISS, EVICTION, LOAD_SUCCESS, LOAD_FAILURE, TOTAL_LOAD_TIME <nl> + HIT, MISS, EVICTION_COUNT, EVICTION_WEIGHT, LOAD_SUCCESS, LOAD_FAILURE, TOTAL_LOAD_TIME <nl> - case EVICTION: <nl> + case EVICTION_COUNT: <nl> + case EVICTION_WEIGHT: <nl> + return desc . expectThat(type . name(), stats . evictionWeight(), is(count)) . matches() ; <nl> - return new HasStats(StatsType . EVICTION, count) ; <nl> + return new HasStats(StatsType . EVICTION_COUNT, count) ; <nl> + } <nl> + public static HasStats hasEvictionWeight(long count) { <nl> + return new HasStats(StatsType . EVICTION_WEIGHT, count) ; <nl>",
        "commit_message": "added removal methods and updated eviction statistics in cache management to enhance cache behavior by properly handling removal scenarios and improving eviction statistics reporting",
        "what": "added removal methods and updated eviction statistics in cache management",
        "why": "enhance cache behavior by properly handling removal scenarios and improving eviction statistics reporting",
        "check": "1"
    },
    {
        "commit_time": "2005-10-18 19:48:42+00:00",
        "diff": "mmm METSExport . java <nl> ppp METSExport . java <nl> + throws SQLException <nl> mmm HTMLServlet . java <nl> ppp HTMLServlet . java <nl> + throws SQLException <nl>",
        "commit_message": "add sqlexception declaration - part of item lazy initialization enhancement",
        "what": "add sqlexception declaration",
        "why": "part of item lazy initialization enhancement",
        "check": "1"
    },
    {
        "commit_time": "2017-08-16 12:25:03+04:30",
        "diff": "mmm LdapAuthenticationHandler . java <nl> ppp LdapAuthenticationHandler . java <nl> - final Map<String, Object> attributeMap = collectAttributesForLdapEntry(ldapEntry, username) ; <nl> + final Map<String, Object> attributeMap = collectAttributesForLdapEntry(ldapEntry, id) ; <nl> - final String dnAttribute = getName() . concat( . ) . concat(username) ; <nl> + final String dnAttribute = getName() . concat( . ) . concat(username . trim()) ; <nl>",
        "commit_message": "updated username variable to id and trimmed spaces in dnAttribute to ensure consistent user identification and remove potential whitespace issues in DN creation",
        "what": "updated username variable to id and trimmed spaces in dnAttribute",
        "why": "ensure consistent user identification and remove potential whitespace issues in DN creation",
        "check": "1"
    },
    {
        "commit_time": "2022-07-31 11:12:25+02:00",
        "diff": "mmm SftpPublicKeyAcceptedAlgorithmsIT . java <nl> ppp SftpPublicKeyAcceptedAlgorithmsIT . java <nl> + import org . junit . jupiter . api . parallel . Isolated ; <nl> + @Isolated <nl>",
        "commit_message": "camel-18264 : allow to configure jsch server key setting ( # 8077 )",
        "what": "allow to configure jsch server key setting",
        "why": "related to camel-18264 and issue #8077",
        "check": "1"
    },
    {
        "commit_time": "2020-06-10 11:01:34+02:00",
        "diff": "mmm TreeDiffer . java <nl> ppp TreeDiffer . java <nl>  <nl> mmm TreeHasher . java <nl> ppp TreeHasher . java <nl>  <nl>",
        "commit_message": "8237210 : modify the header to include oracle copyright line",
        "what": "modify the header to include oracle copyright line",
        "why": "necessary to comply with copyright requirements",
        "check": "1"
    },
    {
        "commit_time": "2017-05-17 10:57:19-07:00",
        "diff": "mmm ShuffleHandler . java <nl> ppp ShuffleHandler . java <nl> + private static final String TIMEOUT_HANDLER = timeout ; <nl> + private boolean enabledTimeout ; <nl> + void setEnabledTimeout(boolean enabledTimeout) { <nl> + this . enabledTimeout = enabledTimeout ; <nl> + } <nl> - if (e . getState() == IdleState . WRITER_IDLE) { <nl> + if (e . getState() == IdleState . WRITER_IDLE && enabledTimeout) { <nl> - pipeline . addLast(timeout, new TimeoutHandler()) ; <nl> + pipeline . addLast(TIMEOUT_HANDLER, new TimeoutHandler()) ; <nl> + ChannelPipeline pipeline = ch . getPipeline() ; <nl> + TimeoutHandler timeoutHandler = (TimeoutHandler)pipeline . get(TIMEOUT_HANDLER) ; <nl> + timeoutHandler . setEnabledTimeout(false) ; <nl> + } else { <nl> + timeoutHandler . setEnabledTimeout(true) ; <nl>",
        "commit_message": "hive-16692 . llap : keep alive connection in shuffle handler should not be close until entire data be flush out . ( rajesh balamohan , review by siddharth seth )",
        "what": "keep alive connection in shuffle handler should not be close until entire data be flush out",
        "why": "related to hive-16692",
        "check": "1"
    },
    {
        "commit_time": "2012-11-05 15:25:14+00:00",
        "diff": "mmm TerrainGrid . java <nl> ppp TerrainGrid . java <nl> + public Terrain getTerrainAtCell(Vector3f cellCoordinate) { <nl> + Vector3f gridLocation = cellCoordinate . mult(getLocalScale()) . multLocal(quadSize - 1) ; <nl> + Vector3f tileCell = getTileCell(gridLocation) ; <nl> + return cache . get(tileCell) ; <nl> + } <nl>",
        "commit_message": "add terraingrid.getterrainatcell ( vector3f cellcoordinate ) to get the terrain tile from cell coordinate",
        "what": "add terraingrid.getterrainatcell ( vector3f cellcoordinate ) to get the terrain tile",
        "why": "from cell coordinate",
        "check": "0"
    },
    {
        "commit_time": "2005-03-14 16:13:18+00:00",
        "diff": "mmm IQRouter . java <nl> ppp IQRouter . java <nl> + handler . initialize(XMPPServer . getInstance()) ; <nl>",
        "commit_message": "modify to initialize the iqhandler when add a new one . jm-211",
        "what": "modify to initialize the iqhandler when add a new one",
        "why": "jm-211",
        "check": "1"
    },
    {
        "commit_time": "2022-01-03 09:47:38+05:30",
        "diff": "mmm EditorActivity . java <nl> ppp EditorActivity . java <nl> + import android . os . Handler ; <nl> + import android . os . Looper ; <nl> + import org . eclipse . lsp4j . Range ; <nl> - public static File mCurrentFile ; <nl> + private ActivityResultLauncher<Intent> mUIDesignerLauncher ; <nl> + public static File mCurrentFile ; <nl> - private static final org . eclipse . lsp4j . Range Range_ofZero = new org . eclipse . lsp4j . Range (new Position (0, 0), new Position (0, 0)) ; <nl> + private static final Range Range_ofZero = new Range (new Position (0, 0), new Position (0, 0)) ; <nl> - private ActivityResultLauncher<Intent> mUIDesignerLauncher ; <nl> + public static final String KEY_BOTTOM_SHEET_SHOWN = editor_bottomSheetShown ; <nl> + mBinding . bottomSheet . pager . setOffscreenPageLimit (bottomSheetTabAdapter . getItemCount () - 1) ;  // DO not remove any views <nl> + if (!getApp () . getPrefManager () . getBoolean (KEY_BOTTOM_SHEET_SHOWN) && mEditorBottomSheet . getState ()!= BottomSheetBehavior . STATE_EXPANDED) { <nl> + mEditorBottomSheet . setState (BottomSheetBehavior . STATE_EXPANDED) ; <nl> + new Handler (Looper . getMainLooper ()) . postDelayed (() -> { <nl> + mEditorBottomSheet . setState (BottomSheetBehavior . STATE_COLLAPSED) ; <nl> + getApp () . getPrefManager () . putBoolean (KEY_BOTTOM_SHEET_SHOWN, true) ; <nl> + }, 1500) ; <nl> + } <nl> mmm IDELogFragment . java <nl> ppp IDELogFragment . java <nl> + public IDELogFragment () { <nl> + } <nl> deleted file <nl> mmm IDELogService . java <nl> - package com . itsaky . androidide . services ; <nl> - import android . app . Service ; <nl> - import android . content . Intent ; <nl> - import android . os . IBinder ; <nl> - public class IDELogService extends Service { <nl> - public IDELogService () { <nl> - } <nl> - @Override <nl> - public void onCreate () { <nl> - super . onCreate () ; <nl> - } <nl> - @Override <nl> - public IBinder onBind (Intent intent) { <nl> - return null ; <nl> - } <nl> - } <nl>",
        "commit_message": "updated EditorActivity by importing necessary classes, changing variable accessibility, and modifying bottom sheet behavior to improve UI interaction and maintain cleaner code structure",
        "what": "updated EditorActivity by importing necessary classes, changing variable accessibility, and modifying bottom sheet behavior",
        "why": "improve UI interaction and maintain cleaner code structure",
        "check": "1"
    },
    {
        "commit_time": "2014-06-27 02:16:48+01:00",
        "diff": "mmm SubTileDaffomill . java <nl> ppp SubTileDaffomill . java <nl> + @Override <nl> + public boolean acceptsRedstone() { <nl> + return true ; <nl> + } <nl>",
        "commit_message": "fix the daffomill not be controllable with redstone . close # 116",
        "what": "fix the daffomill not be controllable with redstone",
        "why": "close #116",
        "check": "1"
    },
    {
        "commit_time": "2021-04-28 19:27:40+01:00",
        "diff": "mmm WidgetsFullSheet . java <nl> ppp WidgetsFullSheet . java <nl> - import android . util . Log ; <nl> - if (getHeaderViewHeight() == 0) { <nl> - Log . d(TAG, Header view height is 0 when inflating recommended widgets) ; <nl> - } <nl> mmm WidgetsRecommendationTableLayout . java <nl> ppp WidgetsRecommendationTableLayout . java <nl> - Log . d(TAG, Recommended widgets section max height:  + recommendationTableMaxHeight) ; <nl> - Log . d(TAG, Recommended widget down scale:  + data . mPreviewScale) ; <nl>",
        "commit_message": "removed log statements from WidgetsFullSheet.java and added log statements in WidgetsRecommendationTableLayout.java to improve debugging information related to widget dimensions and scaling",
        "what": "removed log statements from WidgetsFullSheet.java and added log statements in WidgetsRecommendationTableLayout.java",
        "why": "improve debugging information related to widget dimensions and scaling",
        "check": "1"
    },
    {
        "commit_time": "2013-12-28 03:15:22+04:00",
        "diff": "mmm BTCEBasePollingService . java <nl> ppp BTCEBasePollingService . java <nl> + private static final long START_MILLIS = 1356998400000L ; <nl> - private static final AtomicInteger lastNonce = new AtomicInteger(1) ; <nl> + private static final AtomicInteger lastNonce = new AtomicInteger((int) ((System . currentTimeMillis() - START_MILLIS) / 250L)) ; <nl>",
        "commit_message": "use atomicinteger instead sync block , fix multiinstance concurrency problem",
        "what": "use AtomicInteger instead of synchronized block",
        "why": "fix multi-instance concurrency problem",
        "check": "1"
    },
    {
        "commit_time": "2009-12-06 22:18:07-08:00",
        "diff": "mmm FormatData_uk . java <nl> ppp FormatData_uk . java <nl> -  . , // group (thousands) separator <nl> + \\u00a0, // group (thousands) separator <nl>",
        "commit_message": "updated the thousands separator from a period to a non-breaking space in the FormatData_uk.java file to improve readability of formatted numbers in the UK locale",
        "what": "updated the thousands separator from a period to a non-breaking space in the FormatData_uk.java file",
        "why": "improve readability of formatted numbers in the UK locale",
        "check": "1"
    },
    {
        "commit_time": "2011-07-08 20:18:22+05:30",
        "diff": "mmm NicResponse . java <nl> ppp NicResponse . java <nl> - public boolean equals(Object r){ <nl> - return (r instanceof NicResponse) && id==((NicResponse)r) . id ;  <nl> + public int hashCode() { <nl> + final int prime = 31 ; <nl> + int result = 1 ; <nl> + result = prime * result ((id == null) ? 0 : id . hashCode()) ; <nl> + return result ; <nl> + @Override <nl> + public boolean equals(Object obj) { <nl> + if (this == obj) <nl> + return true ; <nl> + if (obj == null) <nl> + return false ; <nl> + if (getClass() != obj . getClass()) <nl> + return false ; <nl> + NicResponse other = (NicResponse) obj ; <nl> + if (id == null) { <nl> + if (other . id != null) <nl> + return false ; <nl> + } else if (!id . equals(other . id)) <nl> + return false ; <nl> + return true ; <nl> + } <nl> mmm SecurityGroupResponse . java <nl> ppp SecurityGroupResponse . java <nl> - public boolean equals(Object r){ <nl> - return  (r instanceof SecurityGroupResponse) && id==((SecurityGroupResponse)r) . id ;  <nl> + public int hashCode() { <nl> + final int prime = 31 ; <nl> + int result = 1 ; <nl> + result = prime * result ((id == null) ? 0 : id . hashCode()) ; <nl> + return result ; <nl> + } <nl> + @Override <nl> + public boolean equals(Object obj) { <nl> + if (this == obj) <nl> + return true ; <nl> + if (obj == null) <nl> + return false ; <nl> + if (getClass() != obj . getClass()) <nl> + return false ; <nl> + SecurityGroupResponse other = (SecurityGroupResponse) obj ; <nl> + if (id == null) { <nl> + if (other . id != null) <nl> + return false ; <nl> + } else if (!id . equals(other . id)) <nl> + return false ; <nl> + return true ; <nl>",
        "commit_message": "bug 10650 : making sure that only unique nics be add to the set",
        "what": "making sure that only unique nics be add to the set",
        "why": "related to bug 10650",
        "check": "1"
    },
    {
        "commit_time": "2016-07-18 09:47:59-07:00",
        "diff": "mmm DefaultDefectReporter . java <nl> ppp DefaultDefectReporter . java <nl> - import static com . facebook . buck . zip . ZipOutputStreams . HandleDuplicates . OVERWRITE_EXISTING ; <nl> + import static com . facebook . buck . zip . ZipOutputStreams . HandleDuplicates . APPEND_TO_ZIP ; <nl> - ZipOutputStreams . newOutputStream(baseOut, OVERWRITE_EXISTING)) { <nl> + ZipOutputStreams . newOutputStream(baseOut, APPEND_TO_ZIP)) { <nl>",
        "commit_message": "updated ZipOutputStreams to use APPEND_TO_ZIP instead of OVERWRITE_EXISTING to allow appending to existing zip files instead of overwriting them",
        "what": "updated ZipOutputStreams to use APPEND_TO_ZIP instead of OVERWRITE_EXISTING",
        "why": "allow appending to existing zip files instead of overwriting them",
        "check": "1"
    },
    {
        "commit_time": "2019-02-09 14:07:22+01:00",
        "diff": "mmm ExmoAccountServiceRaw . java <nl> ppp ExmoAccountServiceRaw . java <nl> - txid, <nl> + txid, <nl> mmm ExmoMarketDataServiceRaw . java <nl> ppp ExmoMarketDataServiceRaw . java <nl> + import static org . apache . commons . lang3 . StringUtils . join ; <nl> + import java . io . IOException ; <nl> + import java . math . BigDecimal ; <nl> + import java . util . * ; <nl> - import java . io . IOException ; <nl> - import java . math . BigDecimal ; <nl> - import java . util . * ; <nl> - import static org . apache . commons . lang3 . StringUtils . join ; <nl>",
        "commit_message": "removed unused import statements in ExmoMarketDataServiceRaw.java and modified the txid variable in ExmoAccountServiceRaw.java to clean up the code and improve clarity by removing unnecessary dependencies",
        "what": "removed unused import statements in ExmoMarketDataServiceRaw.java and modified the txid variable in ExmoAccountServiceRaw.java",
        "why": "clean up the code and improve clarity by removing unnecessary dependencies",
        "check": "1"
    },
    {
        "commit_time": "2020-07-31 15:31:32-04:00",
        "diff": "mmm FlowResource . java <nl> ppp FlowResource . java <nl> + if (requestScheduleComponentsEntity == null) { <nl> + throw new IllegalArgumentException(Schedule Component must be specified . ) ; <nl> + } <nl> + if (requestEntity == null) { <nl> + throw new IllegalArgumentException(Controller service must be specified . ) ; <nl> + } <nl> mmm ParameterContextResource . java <nl> ppp ParameterContextResource . java <nl> + if (requestEntity == null) { <nl> + throw new IllegalArgumentException(Parameter Context must be specified . ) ; <nl> + } <nl> + if (requestEntity == null) { <nl> + throw new IllegalArgumentException(Parameter Context must be specified . ) ; <nl> + } <nl> mmm ProcessGroupResource . java <nl> ppp ProcessGroupResource . java <nl> - if (requestCreateTemplateRequestEntity . getSnippetId() == null) { <nl> + if (requestCreateTemplateRequestEntity == null || requestCreateTemplateRequestEntity . getSnippetId() == null) { <nl> mmm VersionsResource . java <nl> ppp VersionsResource . java <nl> + if (requestEntity == null) { <nl> + throw new IllegalArgumentException(Version control request must be specified . ) ; <nl> + } <nl> + if (requestEntity == null) { <nl> + throw new IllegalArgumentException(Version control information must be specified . ) ; <nl> + } <nl> + if (requestEntity == null) { <nl> + throw new IllegalArgumentException(Version control information must be specified . ) ; <nl> + } <nl>",
        "commit_message": "nifi-7691 : validate request object to be not null .",
        "what": "validate request object to be not null",
        "why": "ensure the request object is properly initialized before processing",
        "check": "1"
    },
    {
        "commit_time": "2021-01-08 23:22:46+01:00",
        "diff": "mmm EpsonProjectorCommandType . java <nl> ppp EpsonProjectorCommandType . java <nl> - KEY_CODE(KeyCode, NumberItem . class), <nl> + KEY_CODE(KeyCode, StringItem . class), <nl> mmm EpsonProjectorDevice . java <nl> ppp EpsonProjectorDevice . java <nl> - public void sendKeyCode(int value) throws EpsonProjectorCommandException, EpsonProjectorException { <nl> - sendCommand(String . format(KEY %02X, value)) ; <nl> + public void sendKeyCode(String value) throws EpsonProjectorCommandException, EpsonProjectorException { <nl> + sendCommand(String . format(KEY %s, value)) ; <nl> mmm ColorMode . java <nl> ppp ColorMode . java <nl> + AUTO(0x00), <nl> mmm PowerStatus . java <nl> ppp PowerStatus . java <nl> + WIRELESSHDSTANDBY(0x07), <nl> mmm EpsonProjectorHandler . java <nl> ppp EpsonProjectorHandler . java <nl> - remoteController . sendKeyCode(((DecimalType) command) . intValue()) ; <nl> + remoteController . sendKeyCode(command . toString()) ; <nl>",
        "commit_message": "[ epsonprojector ] fix keycode channel to allow non-numeric character ( # 9698 )",
        "what": "fix keycode channel to allow non-numeric character",
        "why": "to ensure correct handling of input for non-numeric characters",
        "check": "1"
    },
    {
        "commit_time": "2013-12-06 07:41:04+01:00",
        "diff": "mmm EntityManager . java <nl> ppp EntityManager . java <nl> - import org . javers . model . mapping . type . EntityReferenceType ; <nl> - import org . javers . model . mapping . type . ValueObjectType ; <nl> - import java . util . ArrayList ; <nl> - import java . util . List ; <nl> - private final ValueObjectFactory valueObjectFactory ; <nl> - private final Set<EntityDefinition> entityDefinitions = new HashSet<>() ; <nl> + private final Set<ManagedClassDefinition> managedClassDefinitions = new HashSet<>() ; <nl> - public EntityManager(EntityFactory entityFactory, ValueObjectFactory valueObjectFactory, TypeMapper typeMapper) { <nl> - argumentsAreNotNull(entityFactory, valueObjectFactory, typeMapper) ; <nl> + public EntityManager(EntityFactory entityFactory, TypeMapper typeMapper) { <nl> + argumentsAreNotNull(entityFactory, typeMapper) ; <nl> - this . valueObjectFactory = valueObjectFactory ; <nl> - if (!isRegisterd(clazz)) { <nl> + if (!isRegistered(clazz)) { <nl> - if (isRegisterd(clazz) && !isManaged(clazz)) { <nl> + if (isRegistered(clazz) && !isManaged(clazz)) { <nl> - @Deprecated <nl> - public void registerEntity(Class<?> entityClass) { <nl> - registerEntity(new EntityDefinition(entityClass)) ; <nl> - } <nl> - public void registerEntity(EntityDefinition def) { <nl> + public void register(ManagedClassDefinition def) { <nl> - if (isRegisterd(def)) { <nl> + if (isRegistered(def)) { <nl> - typeMapper . registerEntityReferenceType(def . getClazz()) ; <nl> - entityDefinitions . add(def) ; <nl> - } <nl> - public void registerValueObject(Class<?> valueObjectClass) { <nl> - Validate . argumentIsNotNull(valueObjectClass) ; <nl> - if (isRegisterd(valueObjectClass)) { <nl> - return ; //already managed <nl> + if (def instanceof EntityDefinition) { <nl> + typeMapper . registerEntityReferenceType(def . getClazz()) ; <nl> - typeMapper . registerValueObjectType(valueObjectClass) ; <nl> + if (def instanceof  ValueObjectDefinition) { <nl> + typeMapper . registerValueObjectType(def . getClazz()) ; <nl> + } <nl> + managedClassDefinitions . add(def) ; <nl> - private boolean isRegisterd(Class<?> managedClass) { <nl> - return typeMapper . isMapped(managedClass) ; <nl> + private boolean isRegistered(ManagedClassDefinition def) { <nl> + return managedClassDefinitions . contains(def) ; <nl> - private boolean isRegisterd(EntityDefinition def) { <nl> - return entityDefinitions . contains(def) ; <nl> + private boolean isRegistered(Class clazz) { <nl> + for (ManagedClassDefinition def : managedClassDefinitions) { <nl> + if (def . getClazz() == clazz){ <nl> + return true ; <nl> + } <nl> + } <nl> + return false ; <nl> - for (EntityDefinition entityDef : entityDefinitions) { <nl> - manageEntity(entityDef) ; <nl> - } <nl> - for (ValueObjectType voType : typeMapper . getMappedValueObjectTypes()) { <nl> - manageValueObject(voType . getBaseJavaType()) ; <nl> + for (ManagedClassDefinition def : managedClassDefinitions) { <nl> + if (def instanceof  EntityDefinition) { <nl> + manageEntity((EntityDefinition)def) ; <nl> + } <nl> + if (def instanceof  ValueObjectDefinition) { <nl> + manageValueObject((ValueObjectDefinition)def) ; <nl> + } <nl> - private void manageValueObject(Class classToManage) { <nl> - managedClasses . add(valueObjectFactory . create(classToManage)) ; <nl> + private void manageValueObject(ValueObjectDefinition voDef) { <nl> + managedClasses . add(new ValueObject(voDef . getClazz())) ; <nl>",
        "commit_message": "simplify valueobjects bootstrap thanks to common definition with entity ( managedclassdefinition )",
        "what": "simplify valueobjects bootstrap thanks to common definition with entity (managedclassdefinition)",
        "why": "improve code organization and maintainability",
        "check": "1"
    },
    {
        "commit_time": "2012-05-20 22:33:19+03:00",
        "diff": "mmm CoreProxy . java <nl> ppp CoreProxy . java <nl> + import java . util . List ; <nl> + import net . minecraft . src . AxisAlignedBB ; <nl> - for (int j = 0 ; j < w . playerEntities . size() ; j++) { <nl> - EntityPlayerMP player = (EntityPlayerMP)w . playerEntities . get(j) ; <nl> - if (Math . abs(player . posX x) <= maxDistance <nl> - && Math . abs(player . posY y) <= maxDistance <nl> - && Math . abs(player . posZ z) <= maxDistance) <nl> - player . playerNetServerHandler . sendPacket(packet) ; <nl> + List<EntityPlayerMP> players = w . getEntitiesWithinAABB(EntityPlayerMP . class, AxisAlignedBB . getBoundingBoxFromPool(x - maxDistance, y - maxDistance, z - maxDistance, x maxDistance, y maxDistance, z maxDistance)) ; <nl> + for (EntityPlayerMP player: players) { <nl> + player . playerNetServerHandler . sendPacket(packet) ; <nl>",
        "commit_message": "use getentitieswithinaabb instead of get all the player of the world for sendtoplayers .",
        "what": "use getentitieswithinaabb instead of get all the player of the world",
        "why": "for sendtoplayers",
        "check": "0"
    },
    {
        "commit_time": "2015-06-25 17:21:08+00:00",
        "diff": "mmm Weight . java <nl> ppp Weight . java <nl> + import org . apache . lucene . index . LeafReader ; <nl>",
        "commit_message": "added import statement for LeafReader from Lucene library to enable functionality for handling index leaf readers in the Weight class",
        "what": "added import statement for LeafReader from Lucene library",
        "why": "enable functionality for handling index leaf readers in the Weight class",
        "check": "1"
    },
    {
        "commit_time": "2016-06-30 10:37:44-07:00",
        "diff": "mmm UIEvent . java <nl> ppp UIEvent . java <nl>  <nl>",
        "commit_message": "updated UIEvent class with new event handling methods to improve event processing efficiency and maintainability",
        "what": "updated UIEvent class with new event handling methods",
        "why": "improve event processing efficiency and maintainability",
        "check": "1"
    },
    {
        "commit_time": "2023-01-25 18:17:17+00:00",
        "diff": "mmm AtomParsers . java <nl> ppp AtomParsers . java <nl> + import androidx . media3 . extractor . mp4 . Atom . LeafAtom ; <nl> + LeafAtom stsd = stbl . getLeafAtomOfType(Atom . TYPE_stsd) ; <nl> + if (stsd == null) { <nl> + throw ParserException . createForMalformedContainer( <nl> + Malformed sample table (stbl) missing sample description (stsd),  null) ; <nl> + } <nl> - checkNotNull(stbl . getLeafAtomOfType(Atom . TYPE_stsd)) . data, <nl> + stsd . data, <nl>",
        "commit_message": "throw a parserexception instead of a nullpointerexception if the sample table ( stbl ) be miss a required sample description ( stsd ) .",
        "what": "throw a ParserException instead of a NullPointerException if the sample table (stbl) is missing a required sample description (stsd)",
        "why": "to improve error handling when a required sample description is absent",
        "check": "1"
    },
    {
        "commit_time": "2018-06-18 22:45:36+09:00",
        "diff": "mmm tensorflow . java <nl> ppp tensorflow . java <nl> + infoMap . put(new Info(TF_Buffer::data) . javaText(public native @Const Pointer data() ; public native TF_Buffer data(Pointer data) ;)) ; <nl> mmm tensorflow . java <nl> ppp tensorflow . java <nl> - public TensorShape(Pointer p) { super(p) ; } <nl> - public TensorShape(long size) { super((Pointer)null) ; allocateArray(size) ; } <nl> - private native void allocateArray(long size) ; <nl> - @Override public TensorShape position(long position) { <nl> - return (TensorShape)super . position(position) ; <nl> - } <nl> + public TensorShape(Pointer p) { super(p) ; } <nl> + public TensorShape(long size) { super((Pointer)null) ; allocateArray(size) ; } <nl> + private native void allocateArray(long size) ; <nl> + @Override public TensorShape position(long position) { <nl> + return (TensorShape)super . position(position) ; <nl> + } <nl> - public AsyncOpKernel(Pointer p) { super(p) ; }  // Lift OpKernel constructors .  <nl> + public AsyncOpKernel(Pointer p) { super(p) ; } <nl> - @MemberGetter public native @Const Pointer data() ; <nl> + public native @Const Pointer data() ; public native TF_Buffer data(Pointer data) ; <nl>",
        "commit_message": "* make it possible to set the  tf_buffer : :data  field for c api of tensorflow",
        "what": "make it possible to set the tf_buffer::data field for C API of TensorFlow",
        "why": "enhance functionality of TensorFlow's C API",
        "check": "1"
    },
    {
        "commit_time": "2016-04-07 19:35:49+00:00",
        "diff": "mmm GridSizeMigrationTask . java <nl> ppp GridSizeMigrationTask . java <nl> - gridSizeSteps . add(new Point(2, 3)) ; <nl> + gridSizeSteps . add(new Point(3, 2)) ; <nl> - gridSizeSteps . add(new Point(3, 4)) ; <nl> + gridSizeSteps . add(new Point(4, 3)) ; <nl> - gridSizeSteps . add(new Point(5, 6)) ; <nl> + gridSizeSteps . add(new Point(6, 5)) ; <nl>",
        "commit_message": "updated grid size points in GridSizeMigrationTask.java to adjust grid configurations for optimal alignment",
        "what": "updated grid size points in GridSizeMigrationTask.java",
        "why": "adjust grid configurations for optimal alignment",
        "check": "1"
    },
    {
        "commit_time": "2004-03-29 23:20:13+00:00",
        "diff": "mmm GermanAnalyzer . java <nl> ppp GermanAnalyzer . java <nl> - der, die, das, dass, da, <nl> + der, die, das, dass, da, <nl> - als, fr, von, mit, <nl> + als, fr, von, mit, <nl>",
        "commit_message": "updated GermanAnalyzer to correct the umlaut character and improve German language support to ensure accurate representation of German characters and enhance text processing capabilities",
        "what": "updated GermanAnalyzer to correct the umlaut character and improve German language support",
        "why": "ensure accurate representation of German characters and enhance text processing capabilities",
        "check": "1"
    },
    {
        "commit_time": "2019-10-01 13:15:55+01:00",
        "diff": "mmm ReplicationSession . java <nl> ppp ReplicationSession . java <nl> - channelUri . put(CommonContext . SESSION_ID_PARAM_NAME, Integer . toString((int)srcReplaySessionId)) ; <nl> - channelUri . put(CommonContext . REJOIN_PARAM_NAME, false) ; <nl> - final String channel = channelUri . toString() ; <nl> + final String channel = new ChannelUriStringBuilder() <nl> +  . media(channelUri . media()) <nl> +  . alias(channelUri) <nl> +  . endpoint(channelUri) <nl> +  . controlMode(CommonContext . MDC_CONTROL_MODE_MANUAL) <nl> +  . rejoin(false) <nl> +  . sessionId((int)srcReplaySessionId) <nl> +  . build() ; <nl>",
        "commit_message": "[ java ] setup replication subscription with manual mdc control .",
        "what": "setup replication subscription with manual mdc control",
        "why": "[java] indicates the context or focus area of the changes",
        "check": "0"
    },
    {
        "commit_time": "2016-03-04 09:07:48-06:00",
        "diff": "mmm TimeLineCursorAdapter . java <nl> ppp TimeLineCursorAdapter . java <nl> + import java . util . ArrayList ; <nl> + import java . util . List ; <nl> - private Video video = null ; <nl> + private List<Video> videos = new ArrayList<>() ; <nl> - if (video != null) { <nl> - video . playCurrentVideo() ; <nl> + for (Video v : videos) { <nl> + v . playCurrentVideo() ; <nl> - if (video != null) { <nl> - video . stopOnScroll() ; <nl> + for (Video v : videos) { <nl> + v . stopOnScroll() ; <nl> - if (video != null) { <nl> - video . releaseVideo() ; <nl> - video = null ; <nl> + for (Video v : videos) { <nl> + v . releaseVideo() ; <nl> + videos . clear() ; <nl> - if (video != null && holder . tweetId == video . tweetId) { <nl> - releaseVideo() ; <nl> + for (int i = 0 ; i < videos . size() ; i++) { <nl> + if (holder . tweetId == videos . get(i) . tweetId) { <nl> + videos . get(i) . releaseVideo() ; <nl> + videos . remove(i) ; <nl> + i-- ; <nl> + } <nl> - video = new Video(holder . videoView, holder . tweetId, holder . gifUrl) ; <nl> + videos . add(new Video(holder . videoView, holder . tweetId, holder . gifUrl)) ; <nl>",
        "commit_message": "replace a single Video instance with a List of Video instances to enable handling multiple videos efficiently within the adapter",
        "what": "replace a single Video instance with a List of Video instances",
        "why": "enable handling multiple videos efficiently within the adapter",
        "check": "1"
    },
    {
        "commit_time": "2015-07-15 14:05:09+03:00",
        "diff": "mmm DebugFonts . java <nl> ppp DebugFonts . java <nl>  <nl>",
        "commit_message": "8080953 : [ test_bug ] test java/awt/fontclass/debugfonts.java fails due to wrongly type bugid",
        "what": "test java/awt/fontclass/debugfonts.java fails due to wrongly type bugid",
        "why": "fix the issue related to the bug id",
        "check": "1"
    },
    {
        "commit_time": "2018-04-02 10:19:08-07:00",
        "diff": "mmm AbstractApplicationBuilder . java <nl> ppp AbstractApplicationBuilder . java <nl> - @Override <nl> - @Deprecated <nl> - public BUILDER withComponent(String key, Class<?> injectableClass) { <nl> - requireNonNulls(key, injectableClass) ; <nl> - injectorBuilder . withComponent(injectableClass) ; <nl> - return self() ; <nl> - } <nl>",
        "commit_message": "runtime-parent : remove depricated method from appbuilder , fix # 304",
        "what": "remove deprecated method from appbuilder",
        "why": "fix #304",
        "check": "1"
    },
    {
        "commit_time": "2013-05-31 15:46:27-04:00",
        "diff": "mmm RegisteredClient . java <nl> ppp RegisteredClient . java <nl> - private Date expiresAt ; <nl> - private Date issuedAt ; <nl> + private Date clientSecretExpiresAt ; <nl> + private Date clientIdIssuedAt ; <nl> - public Date getExpiresAt() { <nl> - return expiresAt ; <nl> + public Date getClientSecretExpiresAt() { <nl> + return clientSecretExpiresAt ; <nl> - public void setExpiresAt(Date expiresAt) { <nl> - this . expiresAt = expiresAt ; <nl> + public void setClientSecretExpiresAt(Date expiresAt) { <nl> + this . clientSecretExpiresAt = expiresAt ; <nl> - public Date getIssuedAt() { <nl> - return issuedAt ; <nl> + public Date getClientIdIssuedAt() { <nl> + return clientIdIssuedAt ; <nl> - public void setIssuedAt(Date issuedAt) { <nl> - this . issuedAt = issuedAt ; <nl> + public void setClientIdIssuedAt(Date issuedAt) { <nl> + this . clientIdIssuedAt = issuedAt ; <nl> mmm ClientDetailsEntityJsonProcessor . java <nl> ppp ClientDetailsEntityJsonProcessor . java <nl> - rc . setIssuedAt(getAsDate(o, issued_at)) ; <nl> - rc . setExpiresAt(getAsDate(o, expires_at)) ; <nl> + rc . setClientIdIssuedAt(getAsDate(o, client_id_issued_at)) ; <nl> + rc . setClientSecretExpiresAt(getAsDate(o, client_secret_expires_at)) ; <nl> - if (c . getExpiresAt() == null) { <nl> - o . addProperty(expires_at, 0) ; // TODO: do we want to let secrets expire? <nl> + if (c . getClientSecretExpiresAt() == null) { <nl> + o . addProperty(client_secret_expires_at, 0) ; // TODO: do we want to let secrets expire? <nl> - o . addProperty(expires_at, c . getExpiresAt() . getTime() / 1000L) ; <nl> + o . addProperty(client_secret_expires_at, c . getClientSecretExpiresAt() . getTime() / 1000L) ; <nl> - if (c . getIssuedAt() != null) { <nl> - o . addProperty(issued_at, c . getIssuedAt() . getTime() / 1000L) ; <nl> + if (c . getClientIdIssuedAt() != null) { <nl> + o . addProperty(client_id_issued_at, c . getClientIdIssuedAt() . getTime() / 1000L) ; <nl> - o . addProperty(issued_at, c . getCreatedAt() . getTime() / 1000L) ; <nl> + o . addProperty(client_id_issued_at, c . getCreatedAt() . getTime() / 1000L) ; <nl>",
        "commit_message": "replaced fields and methods for expiration and issuance dates in RegisteredClient Java files to enhance clarity and specificity regarding client secret and client ID expiration handling",
        "what": "replaced fields and methods for expiration and issuance dates in RegisteredClient Java files",
        "why": "enhance clarity and specificity regarding client secret and client ID expiration handling",
        "check": "1"
    },
    {
        "commit_time": "2022-02-22 17:07:09+00:00",
        "diff": "mmm DefaultAnalyticsCollectorTest . java <nl> ppp DefaultAnalyticsCollectorTest . java <nl> + -    // Verify that AnalyticsCollector forwards all Player . Listener methods to AnalyticsListener .  <nl> + if (method . isSynthetic()) { <nl> + continue ; <nl> + } <nl>",
        "commit_message": "fix defaultanalyticscollectortest failure when run with jacoco",
        "what": "fix defaultanalyticscollectortest failure",
        "why": "when run with jacoco",
        "check": "0"
    },
    {
        "commit_time": "2019-10-21 14:49:37+03:00",
        "diff": "mmm SelenideElement . java <nl> ppp SelenideElement . java <nl> - import org . openqa . selenium . internal . WrapsElement ; <nl> + import org . openqa . selenium . internal . WrapsElement ; <nl> - SelenideElement execute(Command<SelenideElement> command) ; <nl> + <ReturnType> ReturnType execute(Command<ReturnType> command) ; <nl> mmm Execute . java <nl> ppp Execute . java <nl> - public class Execute implements Command<SelenideElement> { <nl> + public class Execute<ReturnType> implements Command<ReturnType> { <nl> + @SuppressWarnings(unchecked) <nl> - public SelenideElement execute(SelenideElement proxy, WebElementSource locator, Object[] args) { <nl> - Command command = (Command) args[0] ; <nl> + public ReturnType execute(SelenideElement proxy, WebElementSource locator, Object[] args) { <nl> + Command<ReturnType> command = (Command<ReturnType>) args[0] ; <nl> - command . execute(proxy, locator, args) ; <nl> + return command . execute(proxy, locator, args) ; <nl> - return proxy ; <nl> mmm SelenideMethodsTest . java <nl> ppp SelenideMethodsTest . java <nl> - final Replace replace = new Replace() ; <nl> - $(#username) . scrollTo() . execute(replace . withValue(custom value)) . pressEnter() ; <nl> + Replace replace = Replace . withValue(custom value) ; <nl> + Command<Void> doubleClick = new DoubleClick() ; <nl> + $(#username) . scrollTo() . execute(replace) . pressEnter() . execute(doubleClick) ; <nl> + static class DoubleClick implements Command<Void> { <nl> + @Override <nl> + public Void execute(SelenideElement proxy, WebElementSource locator, Object[] args) { <nl> + locator . driver() . actions() . doubleClick(locator . findAndAssertElementIsInteractable()) . perform() ; <nl> + return null ; <nl> + } <nl> + } <nl> - private String value ; <nl> + private final String replacement ; <nl> + Replace(String replacement) { <nl> + this . replacement = replacement ; <nl> + } <nl> - Replace withValue(String value) { <nl> - this . value = value ; <nl> - return this ; <nl> + public static Replace withValue(String value) { <nl> + return new Replace(value) ; <nl> - proxy . sendKeys(value) ; <nl> + proxy . sendKeys(replacement) ; <nl>",
        "commit_message": "# 1000 make  $ .execute ( command )  generic : it now can return any value , or even be void .",
        "what": "make  $.execute(command)  generic: it now can return any value, or even be void",
        "why": "enhance flexibility of the method's return type",
        "check": "1"
    },
    {
        "commit_time": "2023-04-27 16:54:28+02:00",
        "diff": "mmm FileHistoryCache . java <nl> ppp FileHistoryCache . java <nl> - public void fillLastHistoryEntries(List<DirectoryEntry> entries) { <nl> + public boolean fillLastHistoryEntries(List<DirectoryEntry> entries) { <nl> - return ; <nl> + return false ; <nl> + boolean ret = true ; <nl> + ret = false ; <nl> + break ; <nl> + ret = false ; <nl> + break ; <nl> + if (!ret) { <nl> + entries . forEach(e -> e . setDate(null)) ; <nl> + entries . forEach(e -> e . setDescription(null)) ; <nl> + } <nl> + return ret ; <nl> mmm HistoryCache . java <nl> ppp HistoryCache . java <nl> - void fillLastHistoryEntries(List<DirectoryEntry> entries) throws CacheException ; <nl> + boolean fillLastHistoryEntries(List<DirectoryEntry> entries) throws CacheException ; <nl> mmm HistoryGuru . java <nl> ppp HistoryGuru . java <nl> - historyCache . fillLastHistoryEntries(entries) ; <nl> - return false ; <nl> + return !historyCache . fillLastHistoryEntries(entries) ; <nl> mmm FileHistoryCacheTest . java <nl> ppp FileHistoryCacheTest . java <nl> - import java . util . ArrayList ; <nl> + import java . util . stream . Collectors ; <nl> - void testGetLastHistoryEntries() throws Exception { <nl> + void testFillLastHistoryEntries() throws Exception { <nl> - List<DirectoryEntry> directoryEntries = new ArrayList<>() ; <nl> - for (File file : files) { <nl> - directoryEntries . add(new DirectoryEntry(file)) ; <nl> - } <nl> + List<DirectoryEntry> directoryEntries = Arrays . stream(files) . map(DirectoryEntry::new) .  <nl> + collect(Collectors . toList()) ; <nl> - spyCache . fillLastHistoryEntries(directoryEntries) ; <nl> + assertTrue(spyCache . fillLastHistoryEntries(directoryEntries)) ; <nl> + assertEquals(directoryEntries . size() - 3, <nl> + (int) directoryEntries . stream() . filter(e -> e . getDate() != null) . count()) ; <nl> + assertEquals(directoryEntries . size(), <nl> + (int) directoryEntries . stream() . filter(e -> e . getDescription() != null) . count()) ; <nl> + cache . clear(repository) ; <nl> + } <nl> + @Test <nl> + void testFillLastHistoryEntriesAllOrNothing() throws Exception { <nl> + File repositoryRoot = new File(repositories . getSourceRoot(), git) ; <nl> + Repository repository = RepositoryFactory . getRepository(repositoryRoot) ; <nl> + File subFile = new File(repositoryRoot, file . txt) ; <nl> + assertFalse(subFile . exists()) ; <nl> + assertTrue(subFile . createNewFile()) ; <nl> + FileHistoryCache spyCache = Mockito . spy(cache) ; <nl> + spyCache . clear(repository) ; <nl> + History historyToStore = repository . getHistory(repositoryRoot) ; <nl> + spyCache . store(historyToStore, repository) ; <nl> + File[] files = repositoryRoot . listFiles() ; <nl> + assertNotNull(files) ; <nl> + assertTrue(files . length > 0) ; <nl> + List<DirectoryEntry> directoryEntries = Arrays . stream(files) . map(DirectoryEntry::new) .  <nl> + collect(Collectors . toList()) ; <nl> + assertFalse(spyCache . fillLastHistoryEntries(directoryEntries)) ; <nl> + assertEquals(0, (int) directoryEntries . stream() . filter(e -> e . getDate() != null) . count()) ; <nl> + assertEquals(0, (int) directoryEntries . stream() . filter(e -> e . getDescription() != null) . count()) ; <nl>",
        "commit_message": "use the all-or-nothing semantics for fill directory entry ( # 4324 )",
        "what": "use the all-or-nothing semantics for fill directory entry",
        "why": "related to issue #4324",
        "check": "1"
    },
    {
        "commit_time": "2023-11-23 17:42:33+08:00",
        "diff": "mmm CommonParameter . java <nl> ppp CommonParameter . java <nl> + public boolean isRpcReflectionServiceEnable ; <nl> + @Getter <nl> + @Setter <nl> mmm Constant . java <nl> ppp Constant . java <nl> + public static final String NODE_RPC_REFLECTION_SERVICE = node . rpc . reflectionService ; <nl> mmm Args . java <nl> ppp Args . java <nl> + PARAMETER . isRpcReflectionServiceEnable = <nl> + config . hasPath(Constant . NODE_RPC_REFLECTION_SERVICE) <nl> + && config . getBoolean(Constant . NODE_RPC_REFLECTION_SERVICE) ; <nl> mmm RpcApiService . java <nl> ppp RpcApiService . java <nl> + import io . grpc . protobuf . services . ProtoReflectionService ; <nl> + if (parameter . isRpcReflectionServiceEnable()) { <nl> + serverBuilder . addService(ProtoReflectionService . newInstance()) ; <nl> + } <nl> mmm RpcApiServiceOnPBFT . java <nl> ppp RpcApiServiceOnPBFT . java <nl> + import io . grpc . protobuf . services . ProtoReflectionService ; <nl> + if (args . isRpcReflectionServiceEnable()) { <nl> + serverBuilder . addService(ProtoReflectionService . newInstance()) ; <nl> + } <nl> mmm RpcApiServiceOnSolidity . java <nl> ppp RpcApiServiceOnSolidity . java <nl> + import io . grpc . protobuf . services . ProtoReflectionService ; <nl> + if (parameter . isRpcReflectionServiceEnable()) { <nl> + serverBuilder . addService(ProtoReflectionService . newInstance()) ; <nl> + } <nl> mmm ArgsTest . java <nl> ppp ArgsTest . java <nl> + Assert . assertTrue(Args . getInstance() . isRpcReflectionServiceEnable()) ; <nl>",
        "commit_message": "added RPC reflection service configuration to enable dynamic service discovery to enhance the server's capabilities for gRPC reflection support based on configuration",
        "what": "added RPC reflection service configuration to enable dynamic service discovery",
        "why": "enhance the server's capabilities for gRPC reflection support based on configuration",
        "check": "1"
    },
    {
        "commit_time": "2016-04-21 23:18:14+02:00",
        "diff": "mmm Request . java <nl> ppp Request . java <nl> + import org . apache . commons . lang3 . StringUtils ; <nl> - if (subtitleHttpHeader != null && ! . equals(subtitleHttpHeader)) { <nl> + if (isNotBlank(subtitleHttpHeader)) { <nl> - if (sub != null) { <nl> + if (sub != null && sub . isExternal()) { <nl> mmm RequestV2 . java <nl> ppp RequestV2 . java <nl> + import org . apache . commons . lang3 . StringUtils ; <nl> - if (subtitleHttpHeader != null && ! . equals(subtitleHttpHeader)) { <nl> + if (isNotBlank(subtitleHttpHeader)) { <nl> - if (sub != null) { <nl> + if (sub != null && sub . isExternal()) { <nl>",
        "commit_message": "replaced string checks with StringUtils methods for better readability to enhance code clarity and maintainability by using utility methods",
        "what": "replaced string checks with StringUtils methods for better readability",
        "why": "enhance code clarity and maintainability by using utility methods",
        "check": "1"
    },
    {
        "commit_time": "2021-11-04 20:19:47+07:00",
        "diff": "mmm AbstractStreamEx . java <nl> ppp AbstractStreamEx . java <nl> + import static one . util . streamex . Internals . IMMUTABLE_TO_LIST ; <nl> - @SuppressWarnings(unchecked) <nl> + return IMMUTABLE_TO_LIST ? toImmutableList() : toMutableList() ; <nl> + } <nl> + @SuppressWarnings(unchecked) <nl> + public List<T> toMutableList() { <nl> - return context . terminate(() -> finisher . apply(toList())) ; <nl> - return finisher . apply(toList()) ; <nl> + return context . terminate(() -> finisher . apply(toMutableList())) ; <nl> + return finisher . apply(toMutableList()) ; <nl> + return IMMUTABLE_TO_LIST ? toImmutableSet() : toMutableSet() ; <nl> + } <nl> + public Set<T> toMutableSet() { <nl> - Set<T> result = toSet() ; <nl> + Set<T> result = toMutableSet() ; <nl> - return context . terminate(() -> finisher . apply(toSet())) ; <nl> - return finisher . apply(toSet()) ; <nl> + return context . terminate(() -> finisher . apply(toMutableSet())) ; <nl> + return finisher . apply(toMutableSet()) ; <nl> mmm Internals . java <nl> ppp Internals . java <nl> + boolean IMMUTABLE_TO_LIST = isImmutableToSetToList() ; <nl> + static boolean isImmutableToSetToList() { <nl> + try { <nl> + return Boolean . parseBoolean(System . getProperty(streamex . default . immutable, false)) ; <nl> + } catch (SecurityException e) { <nl> + return false ; <nl> + } <nl> + } <nl> mmm TestHelpers . java <nl> ppp TestHelpers . java <nl> - List<Integer> order = IntStreamEx . ofIndices(spliterators) . boxed() . toList() ; <nl> + List<Integer> order = IntStreamEx . ofIndices(spliterators) . boxed() . toMutableList() ; <nl> -  . toList() ; <nl> +  . toMutableList() ; <nl> mmm StreamExTest . java <nl> ppp StreamExTest . java <nl> - public void testToList() { <nl> - List<Integer> list = StreamEx . of(1, 2, 3) . toList() ; <nl> + public void testToMutableList() { <nl> + List<Integer> list = StreamEx . of(1, 2, 3) . toMutableList() ; <nl> - List<Integer> list2 = StreamEx . of(4, 5, 6) . parallel() . toList() ; <nl> + List<Integer> list2 = StreamEx . of(4, 5, 6) . parallel() . toMutableList() ; <nl> + @Test <nl> + public void testToMutableSet() { <nl> + Set<Integer> set = StreamEx . of(1, 2, 3) . toMutableSet() ; <nl> + set . add(4) ; <nl> + assertEquals(new HashSet<>(Arrays . asList(1, 2, 3, 4)), set) ; <nl> + } <nl> - try { <nl> - list . add(0) ; <nl> - fail(added) ; <nl> - } catch (UnsupportedOperationException e) { <nl> - } <nl> - try { <nl> - list . set(0, 0) ; <nl> - fail(set) ; <nl> - } catch (UnsupportedOperationException e) { <nl> - } <nl> + assertThrows(UnsupportedOperationException . class, () -> list . add(0)) ; <nl> + assertThrows(UnsupportedOperationException . class, () -> list . set(0, 0)) ; <nl> - try { <nl> - set . add(-1) ; <nl> - fail(added) ; <nl> - } catch (UnsupportedOperationException e) { <nl> - } <nl> + assertThrows(UnsupportedOperationException . class, () -> set . add(-1)) ; <nl>",
        "commit_message": "[ # 244 ] make tolist ( ) /toset ( ) immutable to align with jdk 16 tolist ( )",
        "what": "make tolist() / toset() immutable",
        "why": "align with jdk 16 tolist()",
        "check": "1"
    },
    {
        "commit_time": "2009-11-18 17:36:46+03:00",
        "diff": "mmm SynthTableUI . java <nl> ppp SynthTableUI . java <nl> - if (alternateColor != null && row % 2 == 0) { <nl> + if (alternateColor != null && row % 2 != 0) { <nl> mmm DefaultTableCellRenderer . java <nl> ppp DefaultTableCellRenderer . java <nl> - if (alternateColor != null && row % 2 == 0) <nl> + if (alternateColor != null && row % 2 != 0) { <nl> + } <nl>",
        "commit_message": "updated row coloring logic to alternate colors on odd rows instead of even rows to correct the display of alternate row colors for improved readability",
        "what": "updated row coloring logic to alternate colors on odd rows instead of even rows",
        "why": "correct the display of alternate row colors for improved readability",
        "check": "1"
    },
    {
        "commit_time": "2015-08-17 11:32:06-07:00",
        "diff": "mmm DefaultGraphWalker . java <nl> ppp DefaultGraphWalker . java <nl> - if (nodeOutput != null) { <nl> + if (nodeOutput != null && getDispatchedList() . contains(nd)) { <nl> mmm ASTNode . java <nl> ppp ASTNode . java <nl> - rootNode . astStr = new StringBuffer() ; <nl> - rootNode . toStringTree(rootNode) ; <nl> - rootNode . isValidASTStr = true ; <nl> + if (!rootNode . isValidASTStr) { <nl> + rootNode . astStr = new StringBuffer() ; <nl> + rootNode . toStringTree(rootNode) ; <nl> + rootNode . isValidASTStr = true ; <nl> + } <nl> - getRootNodeWithValidASTStr(false) ; <nl> - ASTNode rootNode = (ASTNode)this . getRootNodeWithValidASTStr(true) ; <nl> + getRootNodeWithValidASTStr(true) ; <nl>",
        "commit_message": "added condition to check if the node is in the dispatched list before processing nodeOutput and ensured AST string generation occurs only if it's invalid to improve code efficiency and prevent unnecessary re-generation of valid AST strings",
        "what": "added condition to check if the node is in the dispatched list before processing nodeOutput and ensured AST string generation occurs only if it's invalid",
        "why": "improve code efficiency and prevent unnecessary re-generation of valid AST strings",
        "check": "1"
    },
    {
        "commit_time": "2021-06-09 20:31:52+08:00",
        "diff": "mmm HadoopInputFormatCommonBase . java <nl> ppp HadoopInputFormatCommonBase . java <nl> - import java . lang . reflect . InvocationTargetException ; <nl> - import java . lang . reflect . Method ; <nl> - Method getCredentialsMethod = null ; <nl> - for (Method m : ugi . getClass() . getMethods()) { <nl> - if (m . getName() . equals(getCredentials)) { <nl> - getCredentialsMethod = m ; <nl> - break ; <nl> - } <nl> - } <nl> - if (getCredentialsMethod == null) { <nl> - return null ; <nl> - } else { <nl> - try { <nl> - return (Credentials) getCredentialsMethod . invoke(ugi) ; <nl> - } catch (InvocationTargetException | IllegalAccessException e) { <nl> - throw new RuntimeException( <nl> - Unable to get credentials from UserGroupInformation .  This is only supported by Hadoop 2 . 2 . 0+) ; <nl> - } <nl> - } <nl> + return ugi . getCredentials() ; <nl>",
        "commit_message": "[ flink-22919 ] remove support for hadoop1.x in hadoopinputformatcommonbase.getcredentialsfromugi",
        "what": "remove support for hadoop1.x in hadoopinputformatcommonbase.getcredentialsfromugi",
        "why": "improve compatibility with newer Hadoop versions",
        "check": "1"
    },
    {
        "commit_time": "2014-04-11 12:10:08-07:00",
        "diff": "mmm JdbcTest . java <nl> ppp JdbcTest . java <nl> - assertEquals(5, driverMinorVersion) ; <nl> + assertTrue(driverMinorVersion >= 5) ; // will work for the next few releases <nl>",
        "commit_message": "up minor version ahead of release . for the version sanity-check , redefine sanity .",
        "what": "up minor version ahead of release",
        "why": "for the version sanity-check, redefine sanity",
        "check": "1"
    },
    {
        "commit_time": "2012-04-06 17:15:09+04:00",
        "diff": "mmm CPlatformWindow . java <nl> ppp CPlatformWindow . java <nl> + setMinimumSize(1, 1) ; // the method ignores its arguments <nl> + Rectangle bounds = peer . getBounds() ; <nl> + setBounds(bounds . x, bounds . y, bounds . width, bounds . height) ; <nl>",
        "commit_message": "added minimum size constraint and updated bounds for CPlatformWindow to ensure proper resizing behavior for the platform window",
        "what": "added minimum size constraint and updated bounds for CPlatformWindow",
        "why": "ensure proper resizing behavior for the platform window",
        "check": "1"
    },
    {
        "commit_time": "2005-01-17 09:51:40+00:00",
        "diff": "mmm PGConnection . java <nl> ppp PGConnection . java <nl>  <nl> mmm PGRefCursorResultSet . java <nl> ppp PGRefCursorResultSet . java <nl>  <nl>",
        "commit_message": "updated PGConnection and PGRefCursorResultSet files to improve connection handling and enhance cursor result processing",
        "what": "updated PGConnection and PGRefCursorResultSet files",
        "why": "improve connection handling and enhance cursor result processing",
        "check": "1"
    },
    {
        "commit_time": "2014-11-06 16:33:04+01:00",
        "diff": "mmm MainApp . java <nl> ppp MainApp . java <nl>  <nl> mmm OCFile . java <nl> ppp OCFile . java <nl>  <nl> mmm UploadDbObject . java <nl> ppp UploadDbObject . java <nl> - import android . os . Parcel ; <nl> - import android . os . Parcelable ; <nl> - import android . util . Log ; <nl> - public class UploadDbObject  implements Serializable{ <nl> + public class UploadDbObject implements Serializable { <nl> -  ; <nl> +  ; <nl> - Log . e(TAG, SUCCESS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!) ; <nl> mmm FileUploadService . java <nl> ppp FileUploadService . java <nl> - import java . io . ByteArrayInputStream ; <nl> - import java . io . ByteArrayOutputStream ; <nl> - import java . io . ObjectInputStream ; <nl> - import java . io . ObjectOutputStream ; <nl> - import android . util . Base64 ; <nl> - import android . util . Log ; <nl> + @SuppressWarnings(unused) <nl> - LOCAL_BEHAVIOUR_COPY(0), LOCAL_BEHAVIOUR_MOVE(1), LOCAL_BEHAVIOUR_FORGET(2) ; <nl> + LOCAL_BEHAVIOUR_COPY(0), <nl> + LOCAL_BEHAVIOUR_MOVE(1), <nl> + LOCAL_BEHAVIOUR_FORGET(2) ; <nl> mmm UploadFileOperation . java <nl> ppp UploadFileOperation . java <nl> + -            if (!mOriginalStoragePath . equals(expectedPath) && mLocalBehaviour == FileUploadService . LocalBehaviour . LOCAL_BEHAVIOUR_COPY) { <nl> + if (!mOriginalStoragePath . equals(expectedPath) <nl> + && mLocalBehaviour == FileUploadService . LocalBehaviour . LOCAL_BEHAVIOUR_COPY) { <nl> mmm UploadFilesActivity . java <nl> ppp UploadFilesActivity . java <nl> - import com . actionbarsherlock . internal . view . menu . ActionMenuItemView ; <nl> - import com . owncloud . android . ui . dialog . IndeterminateProgressDialog ; <nl> + import com . owncloud . android . ui . dialog . IndeterminateProgressDialog ; <nl> mmm Uploader . java <nl> ppp Uploader . java <nl> + import android . annotation . SuppressLint ; <nl> - public void uploadFiles() { <nl> + @SuppressLint(NewApi) <nl> + public void uploadFiles() { <nl> mmm FileStorageUtils . java <nl> ppp FileStorageUtils . java <nl>  <nl>",
        "commit_message": "removed unused imports and formatted some lines in various Java files to improve code readability and maintainability",
        "what": "removed unused imports and formatted some lines in various Java files",
        "why": "improve code readability and maintainability",
        "check": "1"
    },
    {
        "commit_time": "2013-08-13 01:56:34+01:00",
        "diff": "mmm Bind . java <nl> ppp Bind . java <nl> - public static <A,B,C> Iterable<C> findVals3(final NavigableSet<Fun . Tuple3<A,B,C>> secondaryKeys, final A a, final B b) { <nl> + public static <A,B,C> Iterable<C> findVals3(final NavigableSet<Fun . Tuple3<A,B,C>> secondaryKeys, <nl> + final A a, final B b) { <nl> - Fun . t3(a,b,Fun . HI()) // HI is upper bound everything is smaller then HI <nl> + Fun . t3(a,b==null?Fun . HI():b,Fun . HI()) // HI is upper bound everything is smaller then HI <nl> - Fun . t4(a, b,c, null), //NULL represents lower bound, everything is larger than null <nl> - Fun . t4(a,b,c,Fun . HI()) // HI is upper bound everything is smaller then HI <nl> + Fun . t4(a,b,c, null), //NULL represents lower bound, everything is larger than null <nl> + Fun . t4(a,b==null?Fun . HI():b,c==null?Fun . HI():c,Fun . HI()) // HI is upper bound everything is smaller then HI <nl>",
        "commit_message": "modified the findVals3 method to handle null values for parameter b and c appropriately to improve robustness and prevent potential null pointer exceptions",
        "what": "modified the findVals3 method to handle null values for parameter b and c appropriately",
        "why": "improve robustness and prevent potential null pointer exceptions",
        "check": "1"
    },
    {
        "commit_time": "2016-07-25 12:15:02+05:30",
        "diff": "mmm IndexFingerprint . java <nl> ppp IndexFingerprint . java <nl> - private long maxInHash ; <nl> + private long maxVersionsUsedInHash ; <nl> - public long getMaxInHash() { <nl> - return maxInHash ; <nl> + public long getMaxVersionsUsedInHash() { <nl> + return maxVersionsUsedInHash ; <nl> - f . maxInHash = Math . max(v, f . maxInHash) ; <nl> + f . maxVersionsUsedInHash = Math . max(v, f . maxVersionsUsedInHash) ; <nl> - cmp = Long . compare(f1 . maxInHash, f2 . maxInHash) ; <nl> + cmp = Long . compare(f1 . maxVersionsUsedInHash, f2 . maxVersionsUsedInHash) ; <nl> - map . put(maxInHash, maxInHash) ; <nl> + map . put(maxVersionsUsedInHash, maxVersionsUsedInHash) ; <nl> - f . maxInHash = getLong(o, maxInHash, -1) ; <nl> + f . maxVersionsUsedInHash = getLong(o, maxVersionsUsedInHash, -1) ; <nl>",
        "commit_message": "rename maxInHash to maxVersionsUsedInHash and update corresponding methods and references to improve clarity and accuracy in representing the maximum versions used in the hash",
        "what": "rename maxInHash to maxVersionsUsedInHash and update corresponding methods and references",
        "why": "improve clarity and accuracy in representing the maximum versions used in the hash",
        "check": "1"
    },
    {
        "commit_time": "2022-06-28 04:16:33+00:00",
        "diff": "mmm SpeechClient . java <nl> ppp SpeechClient . java <nl> + import com . google . api . core . BetaApi ; <nl> + @BetaApi <nl> mmm SpeechClient . java <nl> ppp SpeechClient . java <nl> + @BetaApi <nl> mmm SyncDeleteCustomClass . java <nl> ppp SyncDeleteCustomClass . java <nl> + import com . google . protobuf . Empty ; <nl> mmm SyncDeleteCustomClassCustomclassname . java <nl> ppp SyncDeleteCustomClassCustomclassname . java <nl> + import com . google . protobuf . Empty ; <nl> mmm SyncDeleteCustomClassString . java <nl> ppp SyncDeleteCustomClassString . java <nl> + import com . google . protobuf . Empty ; <nl> mmm SyncDeletePhraseSet . java <nl> ppp SyncDeletePhraseSet . java <nl> + import com . google . protobuf . Empty ; <nl> mmm SyncDeletePhraseSetPhrasesetname . java <nl> ppp SyncDeletePhraseSetPhrasesetname . java <nl> + import com . google . protobuf . Empty ; <nl> mmm SyncDeletePhraseSetString . java <nl> ppp SyncDeletePhraseSetString . java <nl> + import com . google . protobuf . Empty ; <nl> mmm SyncLongRunningRecognizeRecognitionconfigRecognitionaudio . java <nl> ppp SyncLongRunningRecognizeRecognitionconfigRecognitionaudio . java <nl>  <nl> mmm SyncCreateCustomClassLocationnameCustomclassString . java <nl> ppp SyncCreateCustomClassLocationnameCustomclassString . java <nl>  <nl> mmm SyncCreateCustomClassStringCustomclassString . java <nl> ppp SyncCreateCustomClassStringCustomclassString . java <nl>  <nl> mmm SyncCreatePhraseSetLocationnamePhrasesetString . java <nl> ppp SyncCreatePhraseSetLocationnamePhrasesetString . java <nl>  <nl> mmm SyncDeleteCustomClass . java <nl> ppp SyncDeleteCustomClass . java <nl> + import com . google . protobuf . Empty ; <nl> mmm SyncDeleteCustomClassCustomclassname . java <nl> ppp SyncDeleteCustomClassCustomclassname . java <nl> + import com . google . protobuf . Empty ; <nl> mmm SyncDeleteCustomClassString . java <nl> ppp SyncDeleteCustomClassString . java <nl> + import com . google . protobuf . Empty ; <nl> mmm SyncDeletePhraseSet . java <nl> ppp SyncDeletePhraseSet . java <nl> + import com . google . protobuf . Empty ; <nl> mmm SyncDeletePhraseSetPhrasesetname . java <nl> ppp SyncDeletePhraseSetPhrasesetname . java <nl> + import com . google . protobuf . Empty ; <nl> mmm SyncDeletePhraseSetString . java <nl> ppp SyncDeletePhraseSetString . java <nl> + import com . google . protobuf . Empty ; <nl> mmm SyncLongRunningRecognizeRecognitionconfigRecognitionaudio . java <nl> ppp SyncLongRunningRecognizeRecognitionconfigRecognitionaudio . java <nl>  <nl>",
        "commit_message": "fix : update gapic-generator-java with mock service generation fix ( # 902 )",
        "what": "update gapic-generator-java with mock service generation fix",
        "why": "fix issue #902",
        "check": "1"
    },
    {
        "commit_time": "2018-03-25 12:03:23+03:00",
        "diff": "mmm PlainSelect . java <nl> ppp PlainSelect . java <nl> + private boolean sqlNoCacheFlag = false ; <nl> + if (sqlNoCacheFlag) { <nl> + sql . append(SQL_NO_CACHE) . append( ) ; <nl> + } <nl> + public void setMySqlSqlNoCache(boolean sqlNoCacheFlagSet) { <nl> + this . sqlNoCacheFlag = sqlNoCacheFlagSet ; <nl> + } <nl> + public boolean getMySqlSqlNoCache() { <nl> + return this . sqlNoCacheFlag ; <nl> + } <nl> mmm SelectDeParser . java <nl> ppp SelectDeParser . java <nl> + if (plainSelect . getMySqlSqlNoCache()) { <nl> + buffer . append(SQL_NO_CACHE) . append( ) ; <nl> + } <nl> mmm SelectTest . java <nl> ppp SelectTest . java <nl> + public void testSqlNoCache() throws JSQLParserException { <nl> + String stmt = SELECT SQL_NO_CACHE sales . date FROM sales ; <nl> + assertSqlCanBeParsedAndDeparsed(stmt) ; <nl> + } <nl>",
        "commit_message": "added SQL_NO_CACHE functionality in PlainSelect for MySQL queries to enhance query performance by allowing users to specify caching preferences",
        "what": "added SQL_NO_CACHE functionality in PlainSelect for MySQL queries",
        "why": "enhance query performance by allowing users to specify caching preferences",
        "check": "1"
    },
    {
        "commit_time": "2023-08-18 11:24:07+02:00",
        "diff": "mmm TableDetailsView . java <nl> ppp TableDetailsView . java <nl> + import java . util . HashSet ; <nl> + import java . util . Set ; <nl> + Set<Column> fks = new HashSet<>() ; <nl> + table . associations . forEach(a -> { <nl> + a . createSourceToDestinationKeyMapping() . keySet() . forEach(c -> fks . add(c)) ; <nl> + }) ; <nl> - if (table . primaryKey != null) { <nl> + fks . forEach(c -> { <nl> + if (c . name != null) { <nl> + renderConsumer . put(c . name,  <nl> + label -> { <nl> + label . setForeground(Color . blue) ; <nl> + label . setIcon(emptyIcon) ; <nl> + } <nl> + ) ; <nl> + } <nl> + }) ; <nl> + if (table . primaryKey != null) { <nl> + } else if (fks . contains(column)) { <nl> + label . setForeground(Color . blue) ; <nl> mmm SQLConsole . java <nl> ppp SQLConsole . java <nl> - status . numStatements++ ; <nl> - localStatus . numStatements++ ; <nl> - UISettings . s3++ ; <nl> - status . updateView(false) ; <nl> + status . updateView(false) ; <nl> + if (!isCommentOnly(sqlStatement)) { <nl> + status . numStatements++ ; <nl> + localStatus . numStatements++ ; <nl> + UISettings . s3++ ; <nl> + } <nl> - status . numStatements-- ; <nl>",
        "commit_message": "added foreign key label rendering in TableDetailsView and adjusted SQL statement tracking in SQLConsole to improve UI feedback for foreign keys and ensure accurate statement counting in SQL operations",
        "what": "added foreign key label rendering in TableDetailsView and adjusted SQL statement tracking in SQLConsole",
        "why": "improve UI feedback for foreign keys and ensure accurate statement counting in SQL operations",
        "check": "1"
    },
    {
        "commit_time": "2020-02-11 16:29:00-08:00",
        "diff": "mmm DerInputBuffer . java <nl> ppp DerInputBuffer . java <nl> - if (buf[pos] == ' . ' || buf[pos] == ',') { <nl> + if (generalized && (buf[pos] == ' . ' || buf[pos] == ',')) { <nl> + if (len == 0) { <nl> + throw new IOException(Parse  type + <nl> +  time, empty fractional part) ; <nl> + } <nl> + len-- ; <nl> + if (len == 0) { <nl> + throw new IOException(Parse  type + <nl> +  time, invalid fractional part) ; <nl> + } <nl> - len -= precision ; <nl> + if (len != 5) { <nl> + throw new IOException(Parse  type  time, invalid offset) ; <nl> + } <nl> + if (len != 5) { <nl> + throw new IOException(Parse  type  time, invalid offset) ; <nl> + } <nl> + if (len != 1) { <nl> + throw new IOException(Parse  type  time, invalid format) ; <nl> + } <nl>",
        "commit_message": "added additional validation checks for fractional part and offset lengths in DerInputBuffer.java to improve error handling for parsing time formats",
        "what": "added additional validation checks for fractional part and offset lengths in DerInputBuffer.java",
        "why": "improve error handling for parsing time formats",
        "check": "1"
    },
    {
        "commit_time": "2011-04-26 12:52:22+00:00",
        "diff": "mmm GroupDetailPanel . java <nl> ppp GroupDetailPanel . java <nl> + typeCombobox . setNullSelectionAllowed(false) ; <nl> + typeCombobox . setInvalidAllowed(false) ; <nl> + if (nameTextField . getValue() != null) { <nl> + } <nl>",
        "commit_message": "ui : fix npe when save a group without a name",
        "what": "fix npe when save a group without a name",
        "why": "prevent issues when saving a group without specifying a name",
        "check": "1"
    },
    {
        "commit_time": "2020-01-21 15:11:34-08:00",
        "diff": "mmm SelectAstNode . java <nl> ppp SelectAstNode . java <nl> + } else if (_recordLimit != -1) { <nl> + groupBy . setTopN(_recordLimit) ; <nl> mmm Pql2CompilerTest . java <nl> ppp Pql2CompilerTest . java <nl> + @Test <nl> + public void testGroupByTopLimitBehavior() { <nl> + boolean previousFailOnConversionErrorValue = Pql2Compiler . FAIL_ON_CONVERSION_ERROR ; <nl> + Pql2Compiler . FAIL_ON_CONVERSION_ERROR = false ; <nl> + BrokerRequest brokerRequest = <nl> + COMPILER . compileToBrokerRequest(select count(*) from myTable group by dimA top 200) ; <nl> + Assert . assertEquals(brokerRequest . getGroupBy() . getTopN(), 200) ; <nl> + brokerRequest = <nl> + COMPILER . compileToBrokerRequest(select count(*) from myTable group by dimA limit 300) ; <nl> + Assert . assertEquals(brokerRequest . getGroupBy() . getTopN(), 300) ; <nl> + brokerRequest = <nl> + COMPILER . compileToBrokerRequest(select count(*) from myTable group by dimA) ; <nl> + Assert . assertEquals(brokerRequest . getGroupBy() . getTopN(), 10) ; <nl> + brokerRequest = <nl> + COMPILER . compileToBrokerRequest(select count(*) from myTable group by dimA top 200 LIMIT 300) ; <nl> + Assert . assertEquals(brokerRequest . getGroupBy() . getTopN(), 200) ; <nl> + Pql2Compiler . FAIL_ON_CONVERSION_ERROR = previousFailOnConversionErrorValue ; <nl> + } <nl>",
        "commit_message": "make pql use limit n if top n be not set ( # 4999 )",
        "what": "make pql use limit n if top n be not set",
        "why": "to address issue #4999",
        "check": "1"
    },
    {
        "commit_time": "2005-10-19 15:21:18+00:00",
        "diff": "deleted file <nl> mmm LayoutUtil . java <nl> - package org . xhtmlrenderer . layout ; <nl> - import org . xhtmlrenderer . css . constants . CSSName ; <nl> - import org . xhtmlrenderer . css . constants . IdentValue ; <nl> - import org . xhtmlrenderer . css . newmatch . CascadedStyle ; <nl> - import org . xhtmlrenderer . render . Box ; <nl> - public class LayoutUtil { <nl> - public static IdentValue getDisplay( CascadedStyle style ) { <nl> - IdentValue display = style . getIdent( CSSName . DISPLAY ) ; <nl> - return ( isFloated( style ) ? IdentValue . BLOCK : display ) ; <nl> - } <nl> - public static boolean isOutsideNormalFlow( Box box ) { <nl> - if ( box . fixed ) { <nl> - return true ; <nl> - } <nl> - if ( box . absolute ) { <nl> - return true ; <nl> - } <nl> - if ( box . floated ) { <nl> - return true ; <nl> - } <nl> - return false ; <nl> - } <nl> - public static boolean isFixed( CascadedStyle style ) { <nl> - IdentValue position = getPosition( style ) ; <nl> - return position != null && position == IdentValue . FIXED ; <nl> - } <nl> - public static IdentValue getPosition( CascadedStyle style ) { <nl> - if ( style == null ) { <nl> - return null ; <nl> - }//TODO: this should not be necessary? <nl> - IdentValue position = style . getIdent( CSSName . POSITION ) ; <nl> - return position ; <nl> - } <nl> - public static boolean isFloated( CascadedStyle style ) { <nl> - if ( style == null ) { <nl> - return false ; <nl> - }//TODO: this should be unnecessary? <nl> - IdentValue floatVal = style . getIdent( CSSName . FLOAT ) ; <nl> - return ( floatVal == IdentValue . LEFT || floatVal == IdentValue . RIGHT ) ; <nl> - } <nl> - } <nl>",
        "commit_message": "deleted the LayoutUtil.java file to remove unused utility class to streamline codebase",
        "what": "deleted the LayoutUtil.java file",
        "why": "remove unused utility class to streamline codebase",
        "check": "1"
    },
    {
        "commit_time": "2023-09-26 11:08:57-07:00",
        "diff": "mmm HomePage . java <nl> ppp HomePage . java <nl> - import org . hamcrest . Matchers ; <nl> - import static org . hamcrest . MatcherAssert . assertThat ; <nl> + import static org . hamcrest . Matchers . containsString ; <nl> - assertThat(driver . getPageSource(), Matchers . containsString(Where to?)) ; <nl> + validatePageSource(driver, containsString(Where to?)) ; <nl> mmm Page . java <nl> ppp Page . java <nl> + protected static void validatePageSource(WebDriver driver, Matcher matcher) { <nl> + assertThat(driver . getPageSource(), matcher) ; <nl> + } <nl> mmm PasscodePage . java <nl> ppp PasscodePage . java <nl> + import org . hamcrest . Matcher ; <nl> - assertThat(driver . getPageSource(), containsString(Temporary Authentication Code)) ; <nl> + validatePageSource(driver, containsString(Temporary Authentication Code) ) ; <nl>",
        "commit_message": "refactor page source validation into a reusable method to improve code readability and reduce duplication in page validation logic",
        "what": "refactor page source validation into a reusable method",
        "why": "improve code readability and reduce duplication in page validation logic",
        "check": "1"
    },
    {
        "commit_time": "2019-08-29 13:44:35+01:00",
        "diff": "mmm RestTemplateExchangeTagsTests . java <nl> ppp RestTemplateExchangeTagsTests . java <nl> - void outcomeTagIsClientErrorWhenResponseIsNonStandardInKnownSeries() throws IOException { <nl> + void outcomeTagIsClientErrorWhenResponseIsNonStandardInClientSeries() throws IOException { <nl> mmm WebClientExchangeTagsTests . java <nl> ppp WebClientExchangeTagsTests . java <nl> - void outcomeTagIsClientErrorWhenResponseIsNonStandardInKnownSeries() { <nl> + void outcomeTagIsClientErrorWhenResponseIsNonStandardInClientSeries() { <nl>",
        "commit_message": "polish improve handling of non-standard status code in resttemplate metric",
        "what": "improve handling of non-standard status code in resttemplate metric",
        "why": "polish",
        "check": "0"
    },
    {
        "commit_time": "2022-03-14 12:52:36-07:00",
        "diff": "mmm NiFiRegistrySecurityConfig . java <nl> ppp NiFiRegistrySecurityConfig . java <nl> - import org . springframework . security . config . annotation . web . builders . WebSecurity ; <nl> - import javax . servlet . ServletException ; <nl> - private AnonymousIdentityFilter anonymousAuthenticationFilter = new AnonymousIdentityFilter() ; <nl> + private final AnonymousIdentityFilter anonymousAuthenticationFilter = new AnonymousIdentityFilter() ; <nl> - @Override <nl> - public void configure(WebSecurity webSecurity) throws Exception { <nl> - webSecurity . ignoring() . antMatchers( /access/token, /access/token/kerberos, <nl> - /access/oidc/exchange, /access/oidc/callback, /access/oidc/request, /access/token/identity-provider ) ; <nl> - } <nl> +  . antMatchers( <nl> + /access/token, <nl> + /access/token/identity-provider, <nl> + /access/token/kerberos, <nl> + /access/oidc/callback, <nl> + /access/oidc/exchange, <nl> + /access/oidc/request <nl> + ) . permitAll() <nl> - private IdentityFilter x509AuthenticationFilter() throws Exception { <nl> + private IdentityFilter x509AuthenticationFilter() { <nl> - private IdentityFilter jwtAuthenticationFilter() throws Exception { <nl> + private IdentityFilter jwtAuthenticationFilter() { <nl> - throws IOException, ServletException { <nl> + throws IOException { <nl>",
        "commit_message": "nifi-9796 this close # 5866 . update registry security configuration to avoid warning",
        "what": "update registry security configuration",
        "why": "avoid warning",
        "check": "1"
    },
    {
        "commit_time": "2022-09-09 03:47:10+00:00",
        "diff": "mmm VMInspectionOptions . java <nl> ppp VMInspectionOptions . java <nl> - private static final String MONITORING_ALLOWED_VALUES = ' + MONITORING_HEAPDUMP_NAME + ', ' + MONITORING_JFR_NAME + ', ' + MONITORING_JVMSTAT_NAME + ', or ' + MONITORING_ALL_NAME + ' ; <nl> + private static final String MONITORING_ALLOWED_VALUES = ' MONITORING_HEAPDUMP_NAME ', ' MONITORING_JFR_NAME ', ' MONITORING_JVMSTAT_NAME ', or ' MONITORING_ALL_NAME + <nl> + ' (defaults to ' MONITORING_ALL_NAME ' if no argument is provided) ; <nl> - @APIOption(name = ENABLE_MONITORING_OPTION) // <nl> + @APIOption(name = ENABLE_MONITORING_OPTION, defaultValue = MONITORING_ALL_NAME) // <nl>",
        "commit_message": "[ gr-40860 ] allow -- enable-monitoring to be use without argument .",
        "what": "allow  --enable-monitoring  to be used without argument",
        "why": "improve usability by allowing the option to be used without requiring an argument",
        "check": "1"
    },
    {
        "commit_time": "2015-05-19 12:10:09+03:00",
        "diff": "mmm Legend . java <nl> ppp Legend . java <nl> + private int[] mExtraColors ; <nl> + private String[] mExtraLabels ; <nl> + public int[] getExtraColors() { <nl> + return mExtraColors ; <nl> + } <nl> + public void setExtraColors(List<Integer> colors) { <nl> + this . mExtraColors = Utils . convertIntegers(colors) ; <nl> + } <nl> + public String[] getExtraLabels() { <nl> + return mExtraLabels ; <nl> + } <nl> + public void setExtraLabels(String[] labels) { <nl> + this . mExtraLabels = labels ; <nl> + } <nl> mmm LegendRenderer . java <nl> ppp LegendRenderer . java <nl> + import java . util . Collections ; <nl> + if (mLegend . getExtraColors() != null && mLegend . getExtraLabels() != null) { <nl> + for (int color : mLegend . getExtraColors()) <nl> + colors . add(color) ; <nl> + Collections . addAll(labels, mLegend . getExtraLabels()) ; <nl> + } <nl>",
        "commit_message": "added extra colors and labels functionality to Legend class to enhance customization options for legends in the application",
        "what": "added extra colors and labels functionality to Legend class",
        "why": "enhance customization options for legends in the application",
        "check": "1"
    },
    {
        "commit_time": "2010-02-08 10:38:52+00:00",
        "diff": "mmm FlowJob . java <nl> ppp FlowJob . java <nl> + state = this . flow . getState(getName()+ . +stepName) ;\r <nl> + if (state instanceof StepHolder) {\r <nl> + return ((StepHolder) state) . getStep() ;\r <nl> + } <nl> mmm FlowJobTests . java <nl> ppp FlowJobTests . java <nl> + @Test\r <nl> + public void testGetStepExistsWithPrefix() throws Exception {\r <nl> + SimpleFlow flow = new SimpleFlow(job) ;\r <nl> + List<StateTransition> transitions = new ArrayList<StateTransition>() ;\r <nl> + transitions . add(StateTransition . createStateTransition(new StepState(job . step, new StubStep(step)), end0)) ;\r <nl> + transitions . add(StateTransition . createEndStateTransition(new EndState(FlowExecutionStatus . COMPLETED, end0))) ;\r <nl> + flow . setStateTransitions(transitions) ;\r <nl> + flow . afterPropertiesSet() ;\r <nl> + job . setFlow(flow) ;\r <nl> + job . setName(flow . getName()) ;\r <nl> + job . afterPropertiesSet() ;\r <nl> + Step step = job . getStep(step) ;\r <nl> + assertNotNull(step) ;\r <nl> + assertEquals(step, step . getName()) ;\r <nl> + } <nl>",
        "commit_message": "added step retrieval functionality based on flow state and created a corresponding unit test to ensure the ability to retrieve steps accurately from the flow while validating correct behavior through testing",
        "what": "added step retrieval functionality based on flow state and created a corresponding unit test",
        "why": "ensure the ability to retrieve steps accurately from the flow while validating correct behavior through testing",
        "check": "1"
    },
    {
        "commit_time": "2017-05-04 19:23:02-07:00",
        "diff": "mmm CheckTokenEndpointIntegrationTests . java <nl> ppp CheckTokenEndpointIntegrationTests . java <nl> + if (response . getHeaders() . containsKey(Set-Cookie)) { <nl> + for (String cookie : response . getHeaders() . get(Set-Cookie)) { <nl> + int nameLength = cookie . indexOf('=') ; <nl> + cookies . addCookie(new BasicClientCookie(cookie . substring(0, nameLength), cookie . substring(nameLength+1))) ; <nl> + } <nl> + } <nl> mmm ClientAdminEndpointsIntegrationTests . java <nl> ppp ClientAdminEndpointsIntegrationTests . java <nl> + import java . util . List ; <nl> + import static java . util . stream . Collectors . toList ; <nl> + private List<Approval> approvalList ; <nl> - serverRunning . getRestTemplate() . exchange(serverRunning . getUrl(/approvals?filter={filter}), <nl> + serverRunning . getRestTemplate() . exchange(serverRunning . getUrl(/approvals), <nl> - new HttpEntity<Object>(headers), <nl> + new HttpEntity<>(headers), <nl> - return approvals . getBody() ; <nl> + approvalList = Arrays . asList(approvals . getBody()) . stream() . filter(a -> clientId . equals(a . getClientId())) . collect(toList()) ; <nl> + return approvalList . toArray(new Approval[0]) ; <nl> mmm SamlLoginWithLocalIdpIT . java <nl> ppp SamlLoginWithLocalIdpIT . java <nl> - spZone = IntegrationTestUtils . createZoneOrUpdateSubdomain(identityClient, baseUrl, spZoneId, spZoneId, config) ; <nl> + spZone = IntegrationTestUtils . createZoneOrUpdateSubdomain(identityClient, baseUrl, spZoneId, spZoneId, spZone . getConfig()) ; <nl> - spZone = IntegrationTestUtils . createZoneOrUpdateSubdomain(identityClient, baseUrl, spZoneId, spZoneId, config) ; <nl> + spZone = IntegrationTestUtils . createZoneOrUpdateSubdomain(identityClient, baseUrl, spZoneId, spZoneId, spZone . getConfig()) ; <nl>",
        "commit_message": "added cookie handling in CheckTokenEndpointIntegrationTests and updated approval filtering in ClientAdminEndpointsIntegrationTests to ensure proper management of session cookies and improve approval retrieval based on client ID",
        "what": "added cookie handling in CheckTokenEndpointIntegrationTests and updated approval filtering in ClientAdminEndpointsIntegrationTests",
        "why": "ensure proper management of session cookies and improve approval retrieval based on client ID",
        "check": "1"
    },
    {
        "commit_time": "2018-07-04 10:24:58+03:00",
        "diff": "mmm Throttler . java <nl> ppp Throttler . java <nl> - Object lockOnSync = null ; <nl> + Object lockOnSync = this ; <nl> - lockOnSync = new Integer(currentThrottleRate . intValue()) ; <nl> - } else { <nl> - lockOnSync = this ; <nl> + lockOnSync = key ; <nl> - throttleRate = newThrottle ; <nl> + throttleRate = newThrottle ; <nl>",
        "commit_message": "camel-6840 - use right lock while calculate and set max request per period when group throttle use",
        "what": "use right lock while calculate and set max request per period",
        "why": "when group throttle use",
        "check": "1"
    },
    {
        "commit_time": "2005-07-16 12:17:48+00:00",
        "diff": "mmm AbstractJdbc3Statement . java <nl> ppp AbstractJdbc3Statement . java <nl> - import org . postgresql . core . Oid ; <nl> + public void registerOutParameter( int parameterIndex, int sqlType ) throws SQLException <nl> + { <nl> + switch( sqlType ) <nl> + { <nl> + case Types . BOOLEAN: <nl> + sqlType = Types . BIT ; <nl> + break ; <nl> + default: <nl> + } <nl> + super . registerOutParameter(parameterIndex, sqlType, !adjustIndex ) ; <nl> + } <nl> + public void registerOutParameter(int parameterIndex, int sqlType, <nl> + int scale) throws SQLException <nl> + { <nl> + registerOutParameter(parameterIndex, sqlType ) ; <nl> + } <nl> mmm Jdbc3CallableStatement . java <nl> ppp Jdbc3CallableStatement . java <nl> - import java . io . InputStream ; <nl> - import java . io . Reader ; <nl> - import java . math . BigDecimal ; <nl> - import java . util . Calendar ; <nl> - public void registerOutParameter( int parameterIndex, int sqlType ) throws SQLException <nl> - { <nl> - switch( sqlType ) <nl> - { <nl> - case Types . BOOLEAN: <nl> - sqlType = Types . BIT ; <nl> - break ; <nl> - default: <nl> - } <nl> - super . registerOutParameter(parameterIndex, sqlType, !adjustIndex ) ; <nl> - } <nl> - public void registerOutParameter(int parameterIndex, int sqlType, <nl> - int scale) throws SQLException <nl> - { <nl> - registerOutParameter(parameterIndex, sqlType ) ; <nl> - } <nl>",
        "commit_message": "added new methods to register OUT parameters for BOOLEAN types in AbstractJdbc3Statement to enhance type handling for OUT parameters in JDBC calls",
        "what": "added new methods to register OUT parameters for BOOLEAN types in AbstractJdbc3Statement",
        "why": "enhance type handling for OUT parameters in JDBC calls",
        "check": "1"
    },
    {
        "commit_time": "2013-12-24 17:16:54+01:00",
        "diff": "mmm ResultValidatorImpl . java <nl> ppp ResultValidatorImpl . java <nl> - if (!verifyEventEquality(expectedEvent, actualEvent)) { <nl> + if (!verifyEventEquality(expectedEvent, actualEvent . getPayload())) { <nl> mmm FixtureTest_RegularParams . java <nl> ppp FixtureTest_RegularParams . java <nl> +  . expectStoredEvents(new MyEvent(aggregateId, 4)) <nl> +  . expectPublishedEvents(new MyEvent(aggregateId, 4)) <nl>",
        "commit_message": "fix payload verification issue in expectstoredevents",
        "what": "fix payload verification issue",
        "why": "in expectstoredevents",
        "check": "1"
    },
    {
        "commit_time": "2020-09-11 20:38:50-05:00",
        "diff": "mmm HashChain . java <nl> ppp HashChain . java <nl> - return (new ArrayList<E>(this)) . iterator() ; <nl> + if (firstItem == null || isEmpty()) { <nl> + return emptyIterator() ; <nl> + } else { <nl> + return (new ArrayList<E>(this)) . iterator() ; <nl> + } <nl> - public Iterator<E> snapshotIterator(E item) { <nl> - List<E> l = new ArrayList<E>(map . size()) ; <nl> - for (Iterator<E> it = new LinkIterator<E>(item) ; it . hasNext() ;) { <nl> - E next = it . next() ; <nl> - l . add(next) ; <nl> + public Iterator<E> snapshotIterator(E from) { <nl> + if (from == null || firstItem == null || isEmpty()) { <nl> + return emptyIterator() ; <nl> + } else { <nl> + ArrayList<E> l = new ArrayList<E>(map . size()) ; <nl> + for (Iterator<E> it = new LinkIterator<E>(from) ; it . hasNext() ;) { <nl> + E next = it . next() ; <nl> + l . add(next) ; <nl> + } <nl> + return l . iterator() ; <nl> - return l . iterator() ; <nl> - public synchronized Iterator<E> iterator(E item) { <nl> - if (firstItem == null || isEmpty()) { <nl> + public synchronized Iterator<E> iterator(E from) { <nl> + if (from == null || firstItem == null || isEmpty()) { <nl> - return new LinkIterator<E>(item) ; <nl> + return new LinkIterator<E>(from) ; <nl> - if (firstItem == null || isEmpty()) { <nl> + if (head == null || firstItem == null || isEmpty()) { <nl> - } else if (head != null && this . getPredOf(head) == tail) { <nl> + } else if (this . getPredOf(head) == tail) { <nl>",
        "commit_message": "fix bug introduce by early commit and use emptyiterator more",
        "what": "fix bug introduced by early commit and use empty iterator more",
        "why": "improve code stability and performance",
        "check": "1"
    },
    {
        "commit_time": "2018-05-07 15:43:52-07:00",
        "diff": "mmm AndroidDescriptionsProvider . java <nl> ppp AndroidDescriptionsProvider . java <nl> - new RobolectricTestDescription(javaConfig, defaultAndroidCompilerFactory), <nl> + new RobolectricTestDescription( <nl> + toolchainProvider, javaConfig, defaultAndroidCompilerFactory), <nl> mmm RobolectricTestDescription . java <nl> ppp RobolectricTestDescription . java <nl> + import com . facebook . buck . cxx . toolchain . CxxPlatform ; <nl> + import com . facebook . buck . cxx . toolchain . CxxPlatforms ; <nl> + import com . facebook . buck . jvm . java . toolchain . JavaCxxPlatformProvider ; <nl> + import com . facebook . buck . rules . ImplicitDepsInferringDescription ; <nl> + import com . google . common . collect . ImmutableCollection ; <nl> - public class RobolectricTestDescription implements Description<RobolectricTestDescriptionArg> { <nl> + public class RobolectricTestDescription <nl> + implements Description<RobolectricTestDescriptionArg>, <nl> + ImplicitDepsInferringDescription<RobolectricTestDescriptionArg> { <nl> + private final ToolchainProvider toolchainProvider ; <nl> - JavaBuckConfig javaBuckConfig, AndroidLibraryCompilerFactory compilerFactory) { <nl> + ToolchainProvider toolchainProvider, <nl> + JavaBuckConfig javaBuckConfig, <nl> + AndroidLibraryCompilerFactory compilerFactory) { <nl> + this . toolchainProvider = toolchainProvider ; <nl> + private CxxPlatform getCxxPlatform(RobolectricTestDescriptionArg args) { <nl> + return args . getDefaultCxxPlatform() <nl> +  . map( <nl> + toolchainProvider <nl> +  . getByName(CxxPlatformsProvider . DEFAULT_NAME, CxxPlatformsProvider . class) <nl> +  . getCxxPlatforms() <nl> + ::getValue) <nl> +  . orElse( <nl> + toolchainProvider <nl> +  . getByName(JavaCxxPlatformProvider . DEFAULT_NAME, JavaCxxPlatformProvider . class) <nl> +  . getDefaultJavaCxxPlatform()) ; <nl> + } <nl> - ToolchainProvider toolchainProvider = context . getToolchainProvider() ; <nl> - toolchainProvider <nl> -  . getByName(CxxPlatformsProvider . DEFAULT_NAME, CxxPlatformsProvider . class) <nl> -  . getDefaultCxxPlatform()) ; <nl> + getCxxPlatform(args)) ; <nl> + @Override <nl> + public void findDepsForTargetFromConstructorArgs( <nl> + BuildTarget buildTarget, <nl> + CellPathResolver cellRoots, <nl> + RobolectricTestDescriptionArg constructorArg, <nl> + ImmutableCollection . Builder<BuildTarget> extraDepsBuilder, <nl> + ImmutableCollection . Builder<BuildTarget> targetGraphOnlyDepsBuilder) { <nl> + if (constructorArg . getUseCxxLibraries() . orElse(false)) { <nl> + targetGraphOnlyDepsBuilder . addAll( <nl> + CxxPlatforms . getParseTimeDeps(getCxxPlatform(constructorArg))) ; <nl> + } <nl> + } <nl> mmm RobolectricTestBuilder . java <nl> ppp RobolectricTestBuilder . java <nl> + import com . facebook . buck . cxx . toolchain . CxxPlatformUtils ; <nl> + import com . facebook . buck . jvm . java . toolchain . JavaCxxPlatformProvider ; <nl> - super(new RobolectricTestDescription(javaBuckConfig, DEFAULT_ANDROID_COMPILER_FACTORY), target) ; <nl> + super( <nl> + new RobolectricTestDescription( <nl> + createToolchainProviderForRobolectricTest(), <nl> + javaBuckConfig, <nl> + DEFAULT_ANDROID_COMPILER_FACTORY), <nl> + target) ; <nl> - new RobolectricTestDescription(DEFAULT_JAVA_CONFIG, DEFAULT_ANDROID_COMPILER_FACTORY), <nl> + new RobolectricTestDescription( <nl> + createToolchainProviderForRobolectricTest(), <nl> + DEFAULT_JAVA_CONFIG, <nl> + DEFAULT_ANDROID_COMPILER_FACTORY), <nl> - new RobolectricTestDescription(javaBuckConfig, DEFAULT_ANDROID_COMPILER_FACTORY), <nl> + new RobolectricTestDescription( <nl> + createToolchainProviderForRobolectricTest(), <nl> + javaBuckConfig, <nl> + DEFAULT_ANDROID_COMPILER_FACTORY), <nl> +  . withToolchain( <nl> + JavaCxxPlatformProvider . DEFAULT_NAME, <nl> + JavaCxxPlatformProvider . of(CxxPlatformUtils . DEFAULT_PLATFORM)) <nl>",
        "commit_message": "updated RobolectricTestDescription to include ToolchainProvider and refactor related methods to improve dependency management and integration with toolchain configurations for C++ libraries",
        "what": "updated RobolectricTestDescription to include ToolchainProvider and refactor related methods",
        "why": "improve dependency management and integration with toolchain configurations for C++ libraries",
        "check": "1"
    },
    {
        "commit_time": "2023-01-05 10:33:07-08:00",
        "diff": "mmm HasJavaVersion . java <nl> ppp HasJavaVersion . java <nl> - protected TreeVisitor<?, ExecutionContext> getVisitor() { <nl> + public TreeVisitor<?, ExecutionContext> getVisitor() { <nl> mmm HasSourceSet . java <nl> ppp HasSourceSet . java <nl> - protected TreeVisitor<?, ExecutionContext> getVisitor() { <nl> + public TreeVisitor<?, ExecutionContext> getVisitor() { <nl>",
        "commit_message": "changed access modifier of the getVisitor method from protected to public in HasJavaVersion.java and HasSourceSet.java to allow broader accessibility of the method for external usage",
        "what": "changed access modifier of the getVisitor method from protected to public in HasJavaVersion.java and HasSourceSet.java",
        "why": "allow broader accessibility of the method for external usage",
        "check": "1"
    },
    {
        "commit_time": "2024-02-22 11:28:31+01:00",
        "diff": "mmm DeadLetterQueueWriterAgeRetentionTest . java <nl> ppp DeadLetterQueueWriterAgeRetentionTest . java <nl> - private static boolean isWindows() { <nl> - return System . getProperty(os . name) . startsWith(Windows) ; <nl> - } <nl> - assumeThat(isWindows(), is(not(true))) ; <nl> + Instant beforeWriteEntry = Instant . now() ; <nl> + Awaitility . await(Let the time flow a little so that last write is recognized to be in the past) <nl> +  . atMost(Duration . ofSeconds(1)) <nl> +  . until(() -> Instant . now() . isAfter(beforeWriteEntry)) ; <nl>",
        "commit_message": "fix fail dlq test due to time schedule ( # 15960 )",
        "what": "fix fail dlq test due to time schedule",
        "why": "prevent test failures associated with time scheduling issues",
        "check": "1"
    },
    {
        "commit_time": "2022-03-18 00:40:12+00:00",
        "diff": "deleted file <nl> mmm RawObjectExtractor . java <nl> - package com . oracle . truffle . tools . agentscript . impl ; <nl> - import com . oracle . truffle . api . interop . InteropLibrary ; <nl> - import com . oracle . truffle . api . interop . TruffleObject ; <nl> - import com . oracle . truffle . api . library . ExportLibrary ; <nl> - import com . oracle . truffle . api . library . ExportMessage ; <nl> - import org . graalvm . polyglot . Value ; <nl> - @SuppressWarnings({static-method}) <nl> - @ExportLibrary(InteropLibrary . class) <nl> - final class RawObjectExtractor implements TruffleObject { <nl> - private Object obj ; <nl> - private RawObjectExtractor() { <nl> - } <nl> - static Object toRaw(Value v) { <nl> - if (v . getContext() == null) { <nl> - return v . as(Object . class) ; <nl> - } <nl> - final RawObjectExtractor extractor = new RawObjectExtractor() ; <nl> - v . getContext() . asValue(extractor) . execute(v) ; <nl> - return extractor . obj ; <nl> - } <nl> - @ExportMessage <nl> - static boolean isExecutable(RawObjectExtractor obj) { <nl> - return obj != null ; <nl> - } <nl> - @ExportMessage <nl> - Object execute(Object[] args) { <nl> - return this . obj = args[0] ; <nl> - } <nl> - } <nl>",
        "commit_message": "[ gr-37484 ] removed rawobjectextractor , which have no usage now .",
        "what": "removed rawobjectextractor",
        "why": "which have no usage now",
        "check": "1"
    },
    {
        "commit_time": "2018-11-26 21:27:40+01:00",
        "diff": "mmm LightStateConverter . java <nl> ppp LightStateConverter . java <nl> - return ColorMode . XY . equals(lightState . getColorMode()) ? fromXYtoHSBType(lightState) <nl> - : fromHSBtoHSBType(lightState) ; <nl> + boolean isInXYMode = ColorMode . XY . equals(lightState . getColorMode()) && lightState . getXY() != null ; <nl> + return isInXYMode ? fromXYtoHSBType(lightState) : fromHSBtoHSBType(lightState) ; <nl>",
        "commit_message": "prevent npe if xy field be null ( # 6566 )",
        "what": "prevent npe if xy field be null",
        "why": "address potential null pointer exception issue",
        "check": "1"
    },
    {
        "commit_time": "2022-01-19 11:34:31-05:00",
        "diff": "mmm ConnectionFactoryImpl . java <nl> ppp ConnectionFactoryImpl . java <nl>  <nl>",
        "commit_message": "doc : document timezone reversal from posix to iso ( # 2413 )",
        "what": "document timezone reversal from posix to iso",
        "why": "relates to issue #2413",
        "check": "1"
    },
    {
        "commit_time": "2017-11-02 07:09:26+00:00",
        "diff": "mmm ShowSignature . java <nl> ppp ShowSignature . java <nl> - int contentLen = sigDict . getString(COSName . CONTENTS) . length() * 2 + 2 ; <nl> + int contentLen = contents . getString() . length() * 2 2 ; <nl> - COSString certString = (COSString) sigDict . getDictionaryObject( <nl> - COSName . CONTENTS) ; <nl> - byte[] certData = certString . getBytes() ; <nl> + byte[] certData = contents . getBytes() ; <nl> - COSString certString = (COSString) sigDict . getDictionaryObject( <nl> - COSName . getPDFName(Cert)) ; <nl> + COSString certString = (COSString) sigDict . getDictionaryObject(COSName . CERT) ; <nl> + if (certString == null) <nl> + { <nl> + System . err . println(The /Cert certificate string is missing in the signature dictionary) ; <nl> + return ; <nl> + } <nl>",
        "commit_message": "pdfbox-3017 : simplify code , avoid npe",
        "what": "simplify code",
        "why": "avoid npe",
        "check": "1"
    },
    {
        "commit_time": "2021-06-18 18:59:12+08:00",
        "diff": "mmm GrpcPlugin . java <nl> ppp GrpcPlugin . java <nl> - exchange . getAttributes() . put(Constants . GRPC_RPC_RESULT, ret . getResults()) ; <nl> + exchange . getAttributes() . put(Constants . RPC_RESULT, ret . getResults()) ; <nl>",
        "commit_message": "updated constant used for storing RPC results from GRPC_RPC_RESULT to RPC_RESULT to standardize naming convention for consistency and clarity",
        "what": "updated constant used for storing RPC results from GRPC_RPC_RESULT to RPC_RESULT",
        "why": "standardize naming convention for consistency and clarity",
        "check": "1"
    },
    {
        "commit_time": "2020-08-30 12:48:58+02:00",
        "diff": "mmm HikariModule . java <nl> ppp HikariModule . java <nl> + private Object metricRegistry ; <nl> + private Object healthCheckRegistry ; <nl> + public HikariModule metricRegistry(Object metricRegistry) { <nl> + this . metricRegistry = metricRegistry ; <nl> + return this ; <nl> + } <nl> + public HikariModule healthCheckRegistry(Object healthCheckRegistry) { <nl> + this . healthCheckRegistry = healthCheckRegistry ; <nl> + return this ; <nl> + } <nl> + if (metricRegistry != null) hikari . setMetricRegistry(metricRegistry) ; <nl> + if (healthCheckRegistry != null) hikari . setHealthCheckRegistry(healthCheckRegistry) ; <nl>",
        "commit_message": "added metricRegistry and healthCheckRegistry fields along with their corresponding setter methods in HikariModule to enhance monitoring and health check capabilities for the Hikari connection pool",
        "what": "added metricRegistry and healthCheckRegistry fields along with their corresponding setter methods in HikariModule",
        "why": "enhance monitoring and health check capabilities for the Hikari connection pool",
        "check": "1"
    },
    {
        "commit_time": "2020-02-13 22:43:20+01:00",
        "diff": "mmm JsonPathExpression . java <nl> ppp JsonPathExpression . java <nl> - case resulttype: <nl> - case resultType: <nl> - setResultType(PropertyConfigurerSupport . property(camelContext, Class . class, value)) ; <nl> - return true ; <nl> - case suppressexceptions: <nl> - case suppressExceptions: <nl> - setSuppressExceptions(PropertyConfigurerSupport . property(camelContext, Boolean . class, value)) ; <nl> - return true ; <nl> - case allowsimple: <nl> - case allowSimple: <nl> - setAllowSimple(PropertyConfigurerSupport . property(camelContext, Boolean . class, value)) ; <nl> - return true ; <nl> - case alloweasypredicate: <nl> - case allowEasyPredicate: <nl> - setAllowEasyPredicate(PropertyConfigurerSupport . property(camelContext, Boolean . class, value)) ; <nl> - return true ; <nl> - case writeasstring: <nl> - case writeAsString: <nl> - setWriteAsString(PropertyConfigurerSupport . property(camelContext, Boolean . class, value)) ; <nl> - return true ; <nl> - case headername: <nl> - case headerName: <nl> - setHeaderName(PropertyConfigurerSupport . property(camelContext, String . class, value)) ; <nl> - return true ; <nl> - default: <nl> - return false ; <nl> + case resulttype: <nl> + case resultType: <nl> + setResultType(PropertyConfigurerSupport . property(camelContext, Class . class, value)) ; <nl> + return true ; <nl> + case suppressexceptions: <nl> + case suppressExceptions: <nl> + setSuppressExceptions(PropertyConfigurerSupport . property(camelContext, Boolean . class, value)) ; <nl> + return true ; <nl> + case allowsimple: <nl> + case allowSimple: <nl> + setAllowSimple(PropertyConfigurerSupport . property(camelContext, Boolean . class, value)) ; <nl> + return true ; <nl> + case alloweasypredicate: <nl> + case allowEasyPredicate: <nl> + setAllowEasyPredicate(PropertyConfigurerSupport . property(camelContext, Boolean . class, value)) ; <nl> + return true ; <nl> + case writeasstring: <nl> + case writeAsString: <nl> + setWriteAsString(PropertyConfigurerSupport . property(camelContext, Boolean . class, value)) ; <nl> + return true ; <nl> + case headername: <nl> + case headerName: <nl> + setHeaderName(PropertyConfigurerSupport . property(camelContext, String . class, value)) ; <nl> + return true ; <nl> + default: <nl> + return false ; <nl>",
        "commit_message": "camel-jsonpath fixed switch/cases indentation see camel-14540",
        "what": "fixed switch/cases indentation",
        "why": "see camel-14540",
        "check": "0"
    },
    {
        "commit_time": "2017-12-15 15:14:32+01:00",
        "diff": "mmm CoreOptions . java <nl> ppp CoreOptions . java <nl> -  . defaultValue(java .  ;org . apache . flink .  ;javax . annotation ;org . slf4j ;org . apache . log4j ;org . apache . logging . log4j ;ch . qos . logback) ; <nl> +  . defaultValue(java .  ;scala .  ;org . apache . flink .  ;javax . annotation ;org . slf4j ;org . apache . log4j ;org . apache . logging . log4j ;ch . qos . logback) ; <nl>",
        "commit_message": "[ flink-8264 ] [ core ] add 'scala . ' to the 'parent-first ' classloading pattern .",
        "what": "add 'scala .' to the 'parent-first' classloading pattern",
        "why": "improve classloading behavior",
        "check": "1"
    },
    {
        "commit_time": "2012-09-10 18:46:16+02:00",
        "diff": "mmm HttpExchange . java <nl> ppp HttpExchange . java <nl> + private volatile Throwable failure ; <nl> + public boolean failed() <nl> + { <nl> + return failure != null ; <nl> + } <nl> + public void failed(Throwable failure) <nl> + { <nl> + this . failure = failure ; <nl> + } <nl> mmm HttpReceiver . java <nl> ppp HttpReceiver . java <nl> - private volatile boolean failed ; <nl> - if (!failed) <nl> + HttpExchange exchange = connection . getExchange() ; <nl> + if (exchange != null && !exchange . failed()) <nl> - failed = false ; <nl> - failed = true ; <nl> + exchange . failed(failure) ; <nl>",
        "commit_message": "added failure tracking methods in HttpExchange and updated HttpReceiver to utilize these methods to enhance error handling capabilities in the HTTP exchange process",
        "what": "added failure tracking methods in HttpExchange and updated HttpReceiver to utilize these methods",
        "why": "enhance error handling capabilities in the HTTP exchange process",
        "check": "1"
    },
    {
        "commit_time": "2017-05-03 14:53:01+02:00",
        "diff": "mmm Display . java <nl> ppp Display . java <nl> - if (fullScreen && newLines . size() == oldLines . size() && canScroll) { <nl> + if ((fullScreen || newLines . size() >= rows) && newLines . size() == oldLines . size() && canScroll) { <nl>",
        "commit_message": "updated fullscreen condition to allow scrolling when new lines meet row limit to improve user experience by enabling scrolling in fullscreen mode when content exceeds visible area",
        "what": "updated fullscreen condition to allow scrolling when new lines meet row limit",
        "why": "improve user experience by enabling scrolling in fullscreen mode when content exceeds visible area",
        "check": "1"
    },
    {
        "commit_time": "2018-03-02 23:40:58+05:30",
        "diff": "mmm LatLng . java <nl> ppp LatLng . java <nl> + import android . net . Uri ;\r <nl> + public Uri getGmmIntentUri() {\r <nl> + return Uri . parse(geo:0,0?q= latitude , longitude) ;\r <nl> + } <nl> mmm Place . java <nl> ppp Place . java <nl> + public boolean hasWikipediaLink() { <nl> + return !(siteLinks == null || Uri . EMPTY . equals(siteLinks . getWikipediaLink())) ; <nl> + } <nl> + public boolean hasWikidataLink() { <nl> + return !(siteLinks == null || Uri . EMPTY . equals(siteLinks . getWikidataLink())) ; <nl> + } <nl> + public boolean hasCommonsLink() { <nl> + return !(siteLinks == null || Uri . EMPTY . equals(siteLinks . getCommonsLink())) ; <nl> + } <nl>",
        "commit_message": "added methods to get URI intents for maps and to check for existing site links in the Place class to improve functionality of location handling and enhance link accessibility in the Place object",
        "what": "added methods to get URI intents for maps and to check for existing site links in the Place class",
        "why": "improve functionality of location handling and enhance link accessibility in the Place object",
        "check": "1"
    },
    {
        "commit_time": "2017-06-23 16:32:08+02:00",
        "diff": "mmm JDTTreeBuilder . java <nl> ppp JDTTreeBuilder . java <nl> + import spoon . reflect . reference . CtReference ; <nl> - context . enter(references . <Throwable>getTypeReference(singleTypeReference . resolvedType), singleTypeReference) ; <nl> + if (singleTypeReference . resolvedType == null) { <nl> + CtTypeReference typeReference = factory . Type() . createReference(singleTypeReference . toString()) ; <nl> + CtReference ref = references . getDeclaringReferenceFromImports(singleTypeReference . getLastToken()) ; <nl> + references . setPackageOrDeclaringType(typeReference, ref) ; <nl> + context . enter(typeReference, singleTypeReference) ; <nl> + } else { <nl> + context . enter(references . <Throwable>getTypeReference(singleTypeReference . resolvedType), singleTypeReference) ; <nl> + } <nl> mmm ExceptionTest . java <nl> ppp ExceptionTest . java <nl> + import spoon . reflect . code . CtCatch ; <nl> + import spoon . reflect . code . CtCatchVariable ; <nl> + import spoon . reflect . visitor . filter . TypeFilter ; <nl> + import java . util . List ; <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertNotNull ; <nl> + @Test <nl> + public void testUnionCatchExceptionInsideLambdaInNoClasspath() { <nl> + Launcher launcher = new Launcher() ; <nl> + launcher . addInputResource( . /src/test/resources/noclasspath/UnionCatch . java) ; <nl> + launcher . getEnvironment() . setNoClasspath(true) ; <nl> + launcher . buildModel() ; <nl> + List<CtCatch> catches = launcher . getFactory() . getModel() . getElements(new TypeFilter<>(CtCatch . class)) ; <nl> + assertEquals(2, catches . size()) ; <nl> + CtCatchVariable variable1 = catches . get(0) . getParameter() ; // inside a lambda <nl> + CtCatchVariable variable2 = catches . get(1) . getParameter() ; // outside the lambda <nl> + assertEquals(variable1 . getMultiTypes(), variable2 . getMultiTypes()) ; <nl> + } <nl> new file <nl> ppp UnionCatch . java <nl> + package spoon . test . exceptions . testclasses ; <nl> + import java . io . IOException ; <nl> + import java . io . Reader ; <nl> + import java . io . StringReader ; <nl> + import java . util . function . Function ; <nl> + import toto . NbpOperator ; <nl> + public class UnionCatch { <nl> + public void toto() { <nl> + bla((NbpOperator) t -> { <nl> + try { <nl> + Reader reader = new StringReader(machin) ; <nl> + int i = -1 ; <nl> + while (reader . ready()) { <nl> + i = reader . read() ; <nl> + } <nl> + return i ; <nl> + } catch (IOException | NullPointerException e) { <nl> + System . out . printf(Error) ; <nl> + return 0 ; <nl> + } <nl> + }) ; <nl> + try { <nl> + Reader reader = new StringReader(machin) ; <nl> + int i = -1 ; <nl> + while (reader . ready()) { <nl> + i = reader . read() ; <nl> + } <nl> + return i ; <nl> + } catch (IOException | NullPointerException e) { <nl> + System . out . printf(Error) ; <nl> + return 0 ; <nl> + } <nl> + } <nl> + } <nl>",
        "commit_message": "fix : fix npe with union catch inside lambda in noclasspath ( # 1416 )",
        "what": "fix npe with union catch inside lambda",
        "why": "in noclasspath ( # 1416 )",
        "check": "1"
    },
    {
        "commit_time": "2007-03-08 01:43:46+00:00",
        "diff": "mmm IdentValue . java <nl> ppp IdentValue . java <nl> + public boolean isDependentOnFontSize() { <nl> + return false ; <nl> + } <nl> mmm DerivedValue . java <nl> ppp DerivedValue . java <nl> + public boolean isDependentOnFontSize() { <nl> + return false ; <nl> + } <nl> mmm FSDerivedValue . java <nl> ppp FSDerivedValue . java <nl> + boolean isDependentOnFontSize() ; <nl> mmm LengthValue . java <nl> ppp LengthValue . java <nl> + public boolean isDependentOnFontSize() { <nl> + return _lengthPrimitiveType == CSSPrimitiveValue . CSS_EXS || <nl> + _lengthPrimitiveType == CSSPrimitiveValue . CSS_EMS ; <nl> + } <nl> mmm RectPropertySet . java <nl> ppp RectPropertySet . java <nl> + import org . xhtmlrenderer . css . style . FSDerivedValue ; <nl> - isAbs = style . isLengthOrNumber(sideProperties[i]) && style . hasAbsoluteUnit(sideProperties[i]) ; <nl> + FSDerivedValue value = style . valueByName(sideProperties[i]) ; <nl> + isAbs =  <nl> + (value instanceof LengthValue || value instanceof NumberValue) && <nl> + value . hasAbsoluteUnit() &&  <nl> + ! value . isDependentOnFontSize() ; <nl>",
        "commit_message": "do n't cache rectangle with em or ex dimension . they be n't constant ( even ignore dpi related issue )",
        "what": "do not cache rectangle with em or ex dimension",
        "why": "they aren't constant (even ignore dpi related issue)",
        "check": "1"
    },
    {
        "commit_time": "2023-01-02 16:09:18-05:00",
        "diff": "mmm DataTable . java <nl> ppp DataTable . java <nl> + Class<Row> type ; <nl> - ctx . computeMessage(ExecutionContext . DATA_TABLES, row, HashMap::new, (extract, allExtracts) -> { <nl> + ctx . computeMessage(ExecutionContext . DATA_TABLES, row, HashMap::new, (extract, allDataTables) -> { <nl> - List<Row> extractsOfType = (List<Row>) allExtracts . computeIfAbsent(DataTable . this, c -> new ArrayList<>()) ; <nl> - extractsOfType . add(row) ; <nl> - return allExtracts ; <nl> + List<Row> dataTablesOfType = (List<Row>) allDataTables . computeIfAbsent(DataTable . this, c -> new ArrayList<>()) ; <nl> + dataTablesOfType . add(row) ; <nl> + return allDataTables ; <nl> mmm FindParseFailures . java <nl> ppp FindParseFailures . java <nl> - DataTable<ParseExceptionRow> failures = new DataTable<>(Parse failures, A list of files that failed to parse . ) ; <nl> + DataTable<ParseExceptionRow> failures = new DataTable<>(ParseExceptionRow . class, Parse failures, A list of files that failed to parse . ) ; <nl> mmm RecipeRun . java <nl> ppp RecipeRun . java <nl> - public <E> List<E> getDataTable(DataTable<E> dataTableType) { <nl> + public <E> List<E> getDataTable(DataTable<E> dataTable) { <nl> - return (List<E>) dataTables . get(dataTableType) ; <nl> + return (List<E>) dataTables . get(dataTable) ; <nl> mmm DataTableTest . java <nl> ppp DataTableTest . java <nl> - DataTable<Word> wordTable = new DataTable<>(Words, Each word in the text . ) ; <nl> + DataTable<Word> wordTable = new DataTable<>(Word . class, Words, Each word in the text . ) ; <nl> mmm RecipeSpec . java <nl> ppp RecipeSpec . java <nl> - import com . fasterxml . jackson . core . type . TypeReference ; <nl> - if (ex . isEmpty()) { <nl> - assertThat(expect) . isEmpty() ; <nl> - } else { <nl> - StringWriter writer = new StringWriter() ; <nl> - CsvMapper mapper = new CsvMapper() ; <nl> - Class<?> rowType = ex . iterator() . next() . getClass() ; <nl> - CsvSchema schema = mapper . schemaFor(rowType) . withHeader() ; <nl> - mapper . writerFor(rowType) . with(schema) . writeValues(writer) . writeAll(ex) ; <nl> - assertThat(writer . toString()) . isEqualTo(expect) ; <nl> - } <nl> + StringWriter writer = new StringWriter() ; <nl> + CsvMapper mapper = new CsvMapper() ; <nl> + CsvSchema schema = mapper . schemaFor(dataTable . getType()) . withHeader() ; <nl> + mapper . writerFor(dataTable . getType()) . with(schema) . writeValues(writer) . writeAll(ex) ; <nl> + assertThat(writer . toString()) . isEqualTo(expect) ; <nl>",
        "commit_message": "updated DataTable instantiation to include class type parameters for improved type safety and clarity to enhances code readability and maintains consistency across DataTable usage",
        "what": "updated DataTable instantiation to include class type parameters for improved type safety and clarity",
        "why": "enhances code readability and maintains consistency across DataTable usage",
        "check": "1"
    },
    {
        "commit_time": "2018-12-18 19:20:59+01:00",
        "diff": "mmm FlinkJobServerDriverTest . java <nl> ppp FlinkJobServerDriverTest . java <nl> + } catch (Throwable t) { <nl> + System . setErr(oldOut) ; <nl> + throw t ; <nl>",
        "commit_message": "[ beam-6263 ] restore stderr on exception to print the error",
        "what": "restore stderr on exception to print the error",
        "why": "to improve error visibility during exceptions",
        "check": "1"
    },
    {
        "commit_time": "2014-10-25 17:11:25-07:00",
        "diff": "mmm MissingBackpressureException . java <nl> ppp MissingBackpressureException . java <nl>  <nl>",
        "commit_message": "new and improve javadocs for missingbackpressureexception ( # 1800 )",
        "what": "new and improve javadocs for missingbackpressureexception",
        "why": "enhances documentation clarity for issue #1800",
        "check": "1"
    },
    {
        "commit_time": "2021-08-05 16:07:04-07:00",
        "diff": "mmm JdtUtils . java <nl> ppp JdtUtils . java <nl> + import java . util . HashMap ; <nl> - import java . util . Hashtable ; <nl> - @SuppressWarnings(JdkObsolete) <nl> - private static Map<ITypeBinding, DeclaredTypeDescriptor> <nl> - cachedDeclaredTypeDescriptorByTypeBinding = new Hashtable<>() ; <nl> - if (cachedDeclaredTypeDescriptorByTypeBinding . containsKey(typeBinding)) { <nl> - return cachedDeclaredTypeDescriptorByTypeBinding . get(typeBinding) ; <nl> + DeclaredTypeDescriptor cachedTypeDescriptor = getCachedTypeDescriptor(typeBinding) ; <nl> + if (cachedTypeDescriptor != null) { <nl> + return cachedTypeDescriptor ; <nl> - cachedDeclaredTypeDescriptorByTypeBinding . put(typeBinding, typeDescriptor) ; <nl> + putTypeDescriptorInCache(typeBinding, typeDescriptor) ; <nl> + private static final ThreadLocal<Map<ITypeBinding, DeclaredTypeDescriptor>> <nl> + cachedDeclaredTypeDescriptorByTypeBinding = ThreadLocal . withInitial(HashMap::new) ; <nl> + private static DeclaredTypeDescriptor getCachedTypeDescriptor(ITypeBinding typeBinding) { <nl> + return cachedDeclaredTypeDescriptorByTypeBinding . get() . get(typeBinding) ; <nl> + } <nl> + private static void putTypeDescriptorInCache( <nl> + ITypeBinding typeBinding, DeclaredTypeDescriptor typeDescriptor) { <nl> + cachedDeclaredTypeDescriptorByTypeBinding . get() . put(typeBinding, typeDescriptor) ; <nl> + } <nl>",
        "commit_message": "make typedescriptor cache threadlocal to avoid memory leak .",
        "what": "make typedescriptor cache threadlocal",
        "why": "avoid memory leak",
        "check": "1"
    },
    {
        "commit_time": "2014-11-07 08:48:21+02:00",
        "diff": "mmm HazelcastInstanceImpl . java <nl> ppp HazelcastInstanceImpl . java <nl> - public final class HazelcastInstanceImpl <nl> + public class HazelcastInstanceImpl <nl>",
        "commit_message": "make hazelcastinstanceimpl non-final to be able to mock",
        "what": "make hazelcastinstanceimpl non-final",
        "why": "to be able to mock",
        "check": "1"
    },
    {
        "commit_time": "2017-05-26 15:15:43-04:00",
        "diff": "mmm ContributionsActivity . java <nl> ppp ContributionsActivity . java <nl> - contributionsList . setAdapter(new ContributionsListAdapter(this, cursor, 0)) ; <nl> + contributionsList . setAdapter(new ContributionsListAdapter(getApplicationContext(), cursor, 0)) ; <nl> mmm ContributionsListAdapter . java <nl> ppp ContributionsListAdapter . java <nl> - import android . app . Activity ; <nl> + import android . view . LayoutInflater ; <nl> - private Activity activity ; <nl> - public ContributionsListAdapter(Activity activity, Cursor c, int flags) { <nl> - super(activity, c, flags) ; <nl> - this . activity = activity ; <nl> + public ContributionsListAdapter(Context context, Cursor c, int flags) { <nl> + super(context, c, flags) ; <nl> - View parent = activity . getLayoutInflater() . inflate(R . layout . layout_contribution, viewGroup, false) ; <nl> + View parent = LayoutInflater . from(context) . inflate(R . layout . layout_contribution, viewGroup, false) ; <nl>",
        "commit_message": "updated ContributionsActivity to use getApplicationContext() instead of the Activity context to enhance context management and prevent potential memory leaks",
        "what": "updated ContributionsActivity to use getApplicationContext() instead of the Activity context",
        "why": "enhance context management and prevent potential memory leaks",
        "check": "1"
    },
    {
        "commit_time": "2012-10-04 19:52:09-04:00",
        "diff": "mmm Test7194254 . java <nl> ppp Test7194254 . java <nl>  <nl>",
        "commit_message": "renamed Test7194254.java files to standardize file naming for clarity",
        "what": "renamed Test7194254.java files",
        "why": "standardize file naming for clarity",
        "check": "1"
    },
    {
        "commit_time": "2017-03-03 18:40:07+03:00",
        "diff": "mmm Bucket4j . java <nl> ppp Bucket4j . java <nl> + - * Entry point of bucket4j library <nl> mmm BucketNotFoundException . java <nl> ppp BucketNotFoundException . java <nl>  <nl> mmm RecoveryStrategy . java <nl> ppp RecoveryStrategy . java <nl> + -    THROW_BUCKET_NOT_FOUND_EXCEPTION ; <nl> + THROW_BUCKET_NOT_FOUND_EXCEPTION <nl> mmm JCacheBucketBuilder . java <nl> ppp JCacheBucketBuilder . java <nl> + - * Created by vladimir . bukhtoyarov on 03 . 03 . 2017 .  <nl> mmm JCacheCommand . java <nl> ppp JCacheCommand . java <nl>  <nl> mmm JCacheProxy . java <nl> ppp JCacheProxy . java <nl>  <nl> mmm LocalBucketBuilder . java <nl> ppp LocalBucketBuilder . java <nl> + - * Created by vladimir . bukhtoyarov on 03 . 03 . 2017 .  <nl>",
        "commit_message": "added entries and corrected exception handling in the Bucket4j library to enhance functionality and ensure proper error management in the application",
        "what": "added entries and corrected exception handling in the Bucket4j library",
        "why": "enhance functionality and ensure proper error management in the application",
        "check": "1"
    },
    {
        "commit_time": "2021-05-05 14:49:20+01:00",
        "diff": "mmm DistinctErrorLog . java <nl> ppp DistinctErrorLog . java <nl> - final long timestampMs = clock . time() ; <nl> + final long timestampMs ; <nl> + timestampMs = clock . time() ; <nl>",
        "commit_message": "move read of clock to inside lock for distincterrorlog .",
        "what": "move read of clock to inside lock",
        "why": "for distincterrorlog",
        "check": "1"
    },
    {
        "commit_time": "2016-12-28 17:12:21+00:00",
        "diff": "mmm UserParameters . java <nl> ppp UserParameters . java <nl>  <nl> mmm UserParametersGui . java <nl> ppp UserParametersGui . java <nl> + private JButton moveRowUpButton ; <nl> + private JButton moveRowDownButton ; <nl> - paramTable . setSelectionMode(ListSelectionModel . SINGLE_SELECTION) ; <nl> + paramTable . setSelectionMode(ListSelectionModel . MULTIPLE_INTERVAL_SELECTION) ; <nl> + moveRowUpButton = new JButton(JMeterUtils . getResString(up)) ; // $NON-NLS-1$ <nl> + moveRowDownButton = new JButton(JMeterUtils . getResString(down)) ; // $NON-NLS-1$ <nl> + buttonPanel . add(moveRowUpButton) ; <nl> + buttonPanel . add(moveRowDownButton) ; <nl> + moveRowUpButton . addActionListener(new MoveRowUpAction()) ; <nl> + moveRowDownButton . addActionListener(new MoveRowDownAction()) ; <nl> - int rowSelected = paramTable . getSelectedRow() ; <nl> - if (rowSelected >= 0) { <nl> - tableModel . removeRow(rowSelected) ; <nl> + int[] rowsSelected = paramTable . getSelectedRows() ; <nl> + if (rowsSelected . length > 0) { <nl> + for (int i = rowsSelected . length - 1 ; i >= 0 ; i--) { <nl> + tableModel . removeRow(rowsSelected[i]) ; <nl> + } <nl> - else { <nl> - int rowToSelect = rowSelected ; <nl> - if (rowSelected >= tableModel . getRowCount()) { <nl> - rowToSelect = rowSelected 1 ; <nl> - } <nl> - paramTable . setRowSelectionInterval(rowToSelect, rowToSelect) ; <nl> - } <nl> + private class MoveRowUpAction implements ActionListener { <nl> + @Override <nl> + public void actionPerformed(ActionEvent e) { <nl> + int[] rowsSelected = paramTable . getSelectedRows() ; <nl> + GuiUtils . stopTableEditing(paramTable) ; <nl> + if (rowsSelected . length > 0 && rowsSelected[0] > 0) { <nl> + for (int rowSelected : rowsSelected) { <nl> + tableModel . moveRow(rowSelected, rowSelected 1, rowSelected - 1) ; <nl> + } <nl> + for (int rowSelected : rowsSelected) { <nl> + paramTable . addRowSelectionInterval(rowSelected - 1, rowSelected - 1) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + private class MoveRowDownAction implements ActionListener { <nl> + @Override <nl> + public void actionPerformed(ActionEvent e) { <nl> + int[] rowsSelected = paramTable . getSelectedRows() ; <nl> + GuiUtils . stopTableEditing(paramTable) ; <nl> + if (rowsSelected . length > 0 && rowsSelected[rowsSelected . length - 1] < paramTable . getRowCount() - 1) { <nl> + for (int i = rowsSelected . length - 1 ; i >= 0 ; i--) { <nl> + int rowSelected = rowsSelected[i] ; <nl> + tableModel . moveRow(rowSelected, rowSelected 1, rowSelected 1) ; <nl> + } <nl> + for (int rowSelected : rowsSelected) { <nl> + paramTable . addRowSelectionInterval(rowSelected 1, rowSelected 1) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl>",
        "commit_message": "bug 60154 - user parameter gui : allow row to be move up & down in the list",
        "what": "allow row to be move up & down in the list",
        "why": "bug 60154 - user parameter gui",
        "check": "1"
    },
    {
        "commit_time": "2018-07-03 11:19:34-07:00",
        "diff": "mmm DefaultOnDiskBuildInfo . java <nl> ppp DefaultOnDiskBuildInfo . java <nl> - return ImmutableSortedMap . copyOf(buildInfoStore . getAllMetadata(buildTarget)) ; <nl> + ImmutableSortedMap<String, String> metadata = <nl> + ImmutableSortedMap . copyOf(buildInfoStore . getAllMetadata(buildTarget)) ; <nl> + Preconditions . checkState( <nl> + metadata . containsKey(BuildInfo . MetadataKey . ORIGIN_BUILD_ID), <nl> + Cache artifact for build target %s is missing metadata %s . , <nl> + buildTarget, <nl> + BuildInfo . MetadataKey . ORIGIN_BUILD_ID) ; <nl> + return metadata ; <nl> mmm DefaultOnDiskBuildInfoIntegrationTest . java <nl> ppp DefaultOnDiskBuildInfoIntegrationTest . java <nl> + import com . facebook . buck . core . build . engine . buildinfo . BuildInfo . MetadataKey ; <nl> + recorder . addBuildMetadata(MetadataKey . ORIGIN_BUILD_ID, build-id) ; <nl> + MetadataKey . ORIGIN_BUILD_ID, <nl> + build-id, <nl> mmm DefaultOnDiskBuildInfoTest . java <nl> ppp DefaultOnDiskBuildInfoTest . java <nl> + import org . junit . Rule ; <nl> + import org . junit . rules . ExpectedException ; <nl> + @Rule public ExpectedException thrown = ExpectedException . none() ; <nl> + @Test <nl> + public void testGetMetadataForArtifactRequiresOriginBuildId() throws IOException { <nl> + ProjectFilesystem projectFilesystem = new FakeProjectFilesystem() ; <nl> + projectFilesystem . writeContentsToPath( <nl> + Not A Valid Rule Key, <nl> + Paths . get(buck-out/bin/foo/bar/ . baz/metadata/build, BuildInfo . MetadataKey . RULE_KEY)) ; <nl> + BuildTarget buildTarget = BuildTargetFactory . newInstance(//foo/bar:baz) ; <nl> + DefaultOnDiskBuildInfo onDiskBuildInfo = <nl> + new DefaultOnDiskBuildInfo( <nl> + buildTarget, projectFilesystem, new FilesystemBuildInfoStore(projectFilesystem)) ; <nl> + thrown . expect(IllegalStateException . class) ; <nl> + thrown . expectMessage( <nl> + Cache artifact for build target //foo/bar:baz is missing metadata ORIGIN_BUILD_ID) ; <nl> + onDiskBuildInfo . getMetadataForArtifact() ; <nl> + } <nl>",
        "commit_message": "check build artifact to have origin_build_id before upload",
        "what": "check build artifact to have origin_build_id before upload",
        "why": "ensures the correct build identifier is used during the upload process",
        "check": "1"
    },
    {
        "commit_time": "2021-03-02 08:14:54-05:00",
        "diff": "mmm StatementCancelState . java <nl> ppp StatementCancelState . java <nl> - IDLE, <nl> - IN_QUERY, <nl> - CANCELING, <nl> - CANCELLED <nl> + IDLE, <nl> + IN_QUERY, <nl> + CANCELING, <nl> + CANCELLED <nl>",
        "commit_message": "removed redundant lines for statement states in StatementCancelState.java to improve code clarity by eliminating unnecessary repetition",
        "what": "removed redundant lines for statement states in StatementCancelState.java",
        "why": "improve code clarity by eliminating unnecessary repetition",
        "check": "1"
    },
    {
        "commit_time": "2022-02-26 09:49:58+00:00",
        "diff": "mmm PlaybackController . java <nl> ppp PlaybackController . java <nl> - userPreferences . getValue() . get(UserPreferences . Companion . getLiveTvDirectPlayEnabled()) <nl> + userPreferences . getValue() . get(UserPreferences . Companion . getLiveTvDirectPlayEnabled()), <nl> + userPreferences . getValue() . get(UserPreferences . Companion . getAc3Enabled()) <nl> - ProfileHelper . addAc3Streaming(internalProfile, true) ; <nl> - if (mVideoManager . isNativeMode() && !isLiveTv && ContainerTypes . TS . equals(mCurrentStreamInfo . getContainer())) { <nl> + Timber . d(Seek method - native) ; <nl> + mPlaybackState = PlaybackState . SEEKING ; <nl> + if (mVideoManager . seekTo(pos) < 0) { <nl> + pause() ; <nl> - Timber . d(Seek method native) ; <nl> - mPlaybackState = PlaybackState . SEEKING ; <nl> - if (mVideoManager . seekTo(pos) < 0) { <nl> - Utils . showToast(mFragment . getContext(), mFragment . getString(R . string . seek_error)) ; <nl> - pause() ; <nl> - } else { <nl> - mVideoManager . play() ; <nl> - mPlaybackState = PlaybackState . PLAYING ; <nl> - if (mFragment != null) mFragment . setFadingEnabled(true) ; <nl> - startReportLoop() ; <nl> - } <nl> + mVideoManager . play() ; <nl> + mPlaybackState = PlaybackState . PLAYING ; <nl> + if (mFragment != null) mFragment . setFadingEnabled(true) ; <nl> + startReportLoop() ; <nl> mmm VideoManager . java <nl> ppp VideoManager . java <nl> + import com . google . android . exoplayer2 . extractor . DefaultExtractorsFactory ; <nl> + import com . google . android . exoplayer2 . extractor . ts . TsExtractor ; <nl> + import com . google . android . exoplayer2 . source . DefaultMediaSourceFactory ; <nl> + DefaultExtractorsFactory defaultExtractorsFactory = new DefaultExtractorsFactory() . setTsExtractorTimestampSearchBytes(TsExtractor . DEFAULT_TIMESTAMP_SEARCH_BYTES * 3) ; <nl> + exoPlayerBuilder . setMediaSourceFactory(new DefaultMediaSourceFactory(context, defaultExtractorsFactory)) ; <nl>",
        "commit_message": "updated PlaybackController to include additional user preferences and improved error handling during seeking to enhance playback stability and provide more options for user configuration",
        "what": "updated PlaybackController to include additional user preferences and improved error handling during seeking",
        "why": "enhance playback stability and provide more options for user configuration",
        "check": "1"
    },
    {
        "commit_time": "2016-03-29 21:58:56+01:00",
        "diff": "mmm GenericContainer . java <nl> ppp GenericContainer . java <nl> + super . close() ; <nl>",
        "commit_message": "ensure that resultcallbacktemplate close ( ) method be fire so that stream be close along with container . ref # 94 , # 96",
        "what": "ensure that resultcallbacktemplate close() method be fire",
        "why": "so that stream be close along with container",
        "check": "1"
    },
    {
        "commit_time": "2020-01-02 08:01:58+00:00",
        "diff": "mmm HotSpotSuitesProvider . java <nl> ppp HotSpotSuitesProvider . java <nl>  <nl> mmm IdentityHashCodeNode . java <nl> ppp IdentityHashCodeNode . java <nl> + public ValueNode object() { <nl> + return object ; <nl> + } <nl> mmm MonitorSnippets . java <nl> ppp MonitorSnippets . java <nl> - import static org . graalvm . compiler . hotspot . GraalHotSpotVMConfig . INJECTED_OPTIONVALUES ; <nl> - import static org . graalvm . compiler . hotspot . GraalHotSpotVMConfig . INJECTED_VMCONFIG ; <nl> + import static org . graalvm . compiler . hotspot . GraalHotSpotVMConfigBase . INJECTED_OPTIONVALUES ; <nl> + import static org . graalvm . compiler . hotspot . GraalHotSpotVMConfigBase . INJECTED_VMCONFIG ; <nl> - @ConstantParameter boolean trace, @ConstantParameter Counters counters) { <nl> + @ConstantParameter boolean trace, @ConstantParameter Counters counters, @ConstantParameter boolean biasable) { <nl> - if (useBiasedLocking(INJECTED_VMCONFIG)) { <nl> + if (biasable && useBiasedLocking(INJECTED_VMCONFIG)) { <nl> - @ConstantParameter Counters counters) { <nl> + @ConstantParameter Counters counters, @ConstantParameter boolean biasable) { <nl> - if (useBiasedLocking(INJECTED_VMCONFIG)) { <nl> + if (biasable && useBiasedLocking(INJECTED_VMCONFIG)) { <nl> + args . addConst(biasable, monitorenterNode . isBiasable()) ; <nl> + args . addConst(biasable, monitorexitNode . isBiasable()) ; <nl> mmm AccessMonitorNode . java <nl> ppp AccessMonitorNode . java <nl> + public void disableBiasedLocking() { <nl> + this . biasable = false ; <nl> + } <nl> + public boolean isBiasable() { <nl> + return biasable ; <nl> + } <nl> + protected boolean biasable = true ; <nl> - protected AccessMonitorNode(NodeClass<? extends AccessMonitorNode> c, ValueNode object, MonitorIdNode monitorId) { <nl> + protected AccessMonitorNode(NodeClass<? extends AccessMonitorNode> c, ValueNode object, MonitorIdNode monitorId, boolean biasable) { <nl> + this . biasable = biasable ; <nl> + protected AccessMonitorNode(NodeClass<? extends AccessMonitorNode> c, ValueNode object, MonitorIdNode monitorId) { <nl> + this(c, object, monitorId, true) ; <nl> + } <nl> mmm RawMonitorEnterNode . java <nl> ppp RawMonitorEnterNode . java <nl> + public RawMonitorEnterNode(ValueNode object, ValueNode hub, MonitorIdNode monitorId, boolean biasable) { <nl> + super(TYPE, object, monitorId, biasable) ; <nl> + assert ((ObjectStamp) object . stamp(NodeView . DEFAULT)) . nonNull() ; <nl> + this . hub = hub ; <nl> + } <nl> mmm DefaultJavaLoweringProvider . java <nl> ppp DefaultJavaLoweringProvider . java <nl> - RawMonitorEnterNode rawMonitorEnter = graph . add(new RawMonitorEnterNode(object, hub, monitorEnter . getMonitorId())) ; <nl> + RawMonitorEnterNode rawMonitorEnter = graph . add(new RawMonitorEnterNode(object, hub, monitorEnter . getMonitorId(), monitorEnter . isBiasable())) ; <nl>",
        "commit_message": "[ gr-12021 ] allow monitor lower to avoid emit a biased locking path if bias locking for an object be not possible .",
        "what": "allow monitor lower to avoid emit a biased locking path",
        "why": "if bias locking for an object be not possible",
        "check": "1"
    },
    {
        "commit_time": "2017-01-09 11:52:30+01:00",
        "diff": "mmm I18nInterceptor . java <nl> ppp I18nInterceptor . java <nl> - synchronized (session) { <nl> + String sessionId = ServletActionContext . getRequest() . getSession() . getId() ; <nl> + synchronized (sessionId . intern()) { <nl> - synchronized (session) { <nl> + String sessionId = ServletActionContext . getRequest() . getSession() . getId() ; <nl> + synchronized (sessionId . intern()) { <nl> mmm TokenInterceptor . java <nl> ppp TokenInterceptor . java <nl> - synchronized (session) { <nl> + synchronized (session . getId() . intern()) { <nl>",
        "commit_message": "ww-4730 us session.getid ( ) .intern ( ) to properly lock down session",
        "what": "us session.getid ( ) .intern ( ) to properly lock down session",
        "why": "to properly lock down session",
        "check": "1"
    },
    {
        "commit_time": "2021-10-20 10:58:46+02:00",
        "diff": "mmm AbstractSpecificCompilationDTO . java <nl> ppp AbstractSpecificCompilationDTO . java <nl> - fields . removeIf(e -> e . getName() . equals(field . getName())) ; <nl> + fields . removeIf(e -> e . getClass() . equals(field . getClass()) &&  e . getName() . equals(field . getName())) ; <nl> new file <nl> ppp MiningModelSummedTest . java <nl> + package org . kie . pmml . mining . tests ; <nl> + import java . util . Arrays ; <nl> + import java . util . Collection ; <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + import org . assertj . core . api . Assertions ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + import org . junit . runners . Parameterized ; <nl> + import org . kie . api . pmml . PMML4Result ; <nl> + import org . kie . pmml . api . runtime . PMMLRuntime ; <nl> + import org . kie . pmml . models . tests . AbstractPMMLTest ; <nl> + @RunWith(Parameterized . class) <nl> + public class MiningModelSummedTest extends AbstractPMMLTest { <nl> + private static final String FILE_NAME = MiningModelSummed . pmml ; <nl> + private static final String MODEL_NAME = MiningModelSummed ; <nl> + private static final String TARGET_FIELD = result ; <nl> + private final String INPUT1 = input1 ; <nl> + private final String INPUT2 = input2 ; <nl> + private final String INPUT3 = input3 ; <nl> + private double input1 ; <nl> + private double input2 ; <nl> + private double input3 ; <nl> + private static PMMLRuntime pmmlRuntime ; <nl> + private double expectedResult ; <nl> + public MiningModelSummedTest(double input1, <nl> + double input2, <nl> + double input3, <nl> + double expectedResult) { <nl> + this . input1 = input1 ; <nl> + this . input2 = input2 ; <nl> + this . input3 = input3 ; <nl> + this . expectedResult = expectedResult ; <nl> + } <nl> + @BeforeClass <nl> + public static void setupClass() { <nl> + pmmlRuntime = getPMMLRuntime(FILE_NAME) ; <nl> + } <nl> + @Parameterized . Parameters <nl> + public static Collection<Object[]> data() { <nl> + return Arrays . asList(new Object[][]{ <nl> + {200 . 0, -1 . 0, 2 . 0, -299 . 0}, <nl> + }) ; <nl> + } <nl> + @Test <nl> + public void testMiningModelSummed() throws Exception { <nl> + final Map<String, Object> inputData = new HashMap<>() ; <nl> + inputData . put(INPUT1, input1) ; <nl> + inputData . put(INPUT2, input2) ; <nl> + inputData . put(INPUT3, input3) ; <nl> + PMML4Result pmml4Result = evaluate(pmmlRuntime, inputData, MODEL_NAME) ; <nl> + Assertions . assertThat(pmml4Result . getResultVariables() . get(TARGET_FIELD)) . isNotNull() ; <nl> + Assertions . assertThat(pmml4Result . getResultVariables() . get(TARGET_FIELD)) . isEqualTo(expectedResult) ; <nl> + } <nl> + } <nl>",
        "commit_message": "[ rhdm-1834 ] fix compilation of miningmodels with duplicated field name . add test ( # 3935 )",
        "what": "fix compilation of miningmodels with duplicated field name; add test",
        "why": "to address issue [rhdm-1834] and enhance code reliability (#3935)",
        "check": "1"
    },
    {
        "commit_time": "2020-09-21 17:20:51-07:00",
        "diff": "mmm AbsSwipeUpHandler . java <nl> ppp AbsSwipeUpHandler . java <nl> - () -> mDeviceState . getRotationTouchHelper() .  <nl> - onEndTargetCalculated(mGestureState . getEndTarget(), <nl> - mActivityInterface)) ; <nl> + () -> { <nl> + mDeviceState . getRotationTouchHelper() <nl> +  . onEndTargetCalculated(mGestureState . getEndTarget(), <nl> + mActivityInterface) ; <nl> + mRecentsView . onGestureEndTargetCalculated(mGestureState . getEndTarget()) ; <nl> + }) ; <nl> mmm FallbackRecentsView . java <nl> ppp FallbackRecentsView . java <nl> + import static com . android . quickstep . GestureState . GestureEndTarget . RECENTS ; <nl> + import com . android . quickstep . GestureState ; <nl> - public void onGestureAnimationEnd() { <nl> - super . onGestureAnimationEnd() ; <nl> - if (mHomeTaskInfo != null) { <nl> + public void onGestureEndTargetCalculated(GestureState . GestureEndTarget endTarget) { <nl> + super . onGestureEndTargetCalculated(endTarget) ; <nl> + if (mHomeTaskInfo != null && endTarget == RECENTS) { <nl> mmm RecentsView . java <nl> ppp RecentsView . java <nl> + import com . android . quickstep . GestureState ; <nl> + public void onGestureEndTargetCalculated(GestureState . GestureEndTarget endTarget) { <nl> + } <nl>",
        "commit_message": "refactor gesture handling methods to introduce onGestureEndTargetCalculated for better encapsulation to enhance functionality by adding handling for RECENTS end target in gesture processing",
        "what": "refactor gesture handling methods to introduce onGestureEndTargetCalculated for better encapsulation",
        "why": "enhance functionality by adding handling for RECENTS end target in gesture processing",
        "check": "1"
    },
    {
        "commit_time": "2019-09-28 23:21:09+00:00",
        "diff": "mmm InstallShortcutReceiver . java <nl> ppp InstallShortcutReceiver . java <nl> + if (data == null) { <nl> + Log . e(TAG, Can't construct WorkspaceItemInfo with null data) ; <nl> + return null ; <nl> + } <nl>",
        "commit_message": "added null check for data in InstallShortcutReceiver.java to prevent crashes when constructing WorkspaceItemInfo with null data",
        "what": "added null check for data in InstallShortcutReceiver.java",
        "why": "prevent crashes when constructing WorkspaceItemInfo with null data",
        "check": "1"
    },
    {
        "commit_time": "2023-09-19 21:23:59-07:00",
        "diff": "mmm AwsV4FamilyHttpSigner . java <nl> ppp AwsV4FamilyHttpSigner . java <nl> + import software . amazon . awssdk . http . auth . spi . signer . HttpSigner ; <nl> + import software . amazon . awssdk . identity . spi . Identity ; <nl> - public interface AwsV4FamilyHttpSigner { <nl> + public interface AwsV4FamilyHttpSigner<T extends Identity> extends HttpSigner<T> { <nl> mmm AwsV4HttpSigner . java <nl> ppp AwsV4HttpSigner . java <nl> - public interface AwsV4HttpSigner extends AwsV4FamilyHttpSigner, HttpSigner<AwsCredentialsIdentity> { <nl> + public interface AwsV4HttpSigner extends AwsV4FamilyHttpSigner<AwsCredentialsIdentity> { <nl> mmm AwsV4aHttpSigner . java <nl> ppp AwsV4aHttpSigner . java <nl> - public interface AwsV4aHttpSigner extends AwsV4FamilyHttpSigner, HttpSigner<AwsCredentialsIdentity> { <nl> + public interface AwsV4aHttpSigner extends AwsV4FamilyHttpSigner<AwsCredentialsIdentity> { <nl>",
        "commit_message": "make awsv4familyhttpsigner a sub-type of httpsigner ( # 4451 )",
        "what": "make awsv4familyhttpsigner a sub-type of httpsigner",
        "why": "improve code organization and maintainability",
        "check": "1"
    },
    {
        "commit_time": "2018-01-25 14:33:12+02:00",
        "diff": "new file <nl> ppp SessionContainsTransactionTest . java <nl> + package com . vladmihalcea . book . hpjp . hibernate . transaction ; <nl> + import com . vladmihalcea . book . hpjp . util . AbstractTest ; <nl> + import org . hibernate . Session ; <nl> + import org . jboss . logging . Logger ; <nl> + import org . junit . Test ; <nl> + import javax . persistence . Entity ; <nl> + import javax . persistence . EntityManager ; <nl> + import javax . persistence . EntityTransaction ; <nl> + import javax . persistence . Id ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + public class SessionContainsTransactionTest extends AbstractTest { <nl> + @Override <nl> + protected Class<?>[] entities() { <nl> + return new Class<?>[]{ <nl> + Post . class <nl> + } ; <nl> + } <nl> + @Test <nl> + public void testSessionContains() { <nl> + EntityManager entityManager = null ; <nl> + EntityTransaction txn = null ; <nl> + try { <nl> + entityManager = entityManagerFactory() . createEntityManager() ; <nl> + txn = entityManager . getTransaction() ; <nl> + txn . begin() ; <nl> + Post person = new Post(1L, High-Performance Java Persistence) ; <nl> + entityManager . persist(person) ; <nl> + txn . commit() ; <nl> + txn = entityManager . getTransaction() ; <nl> + txn . begin() ; <nl> + assertTrue(entityManager . contains(person)) ; <nl> + txn . commit() ; <nl> + } catch (RuntimeException e) { <nl> + if (txn != null && txn . isActive()) { <nl> + txn . rollback() ; <nl> + } <nl> + throw e ; <nl> + } finally { <nl> + if (entityManager != null) { <nl> + entityManager . close() ; <nl> + } <nl> + } <nl> + } <nl> + @Entity(name = Post) <nl> + public static class Post { <nl> + @Id <nl> + private Long id ; <nl> + private String name ; <nl> + public Post() { <nl> + } <nl> + public Post(long id, String name) { <nl> + this . id = id ; <nl> + this . name = name ; <nl> + } <nl> + public Long getId() { <nl> + return id ; <nl> + } <nl> + public String getName() { <nl> + return name ; <nl> + } <nl> + } <nl> + } <nl>",
        "commit_message": "add test to prove that session span be not influence by transaction management",
        "what": "add test to prove that session span be not influence by transaction management",
        "why": "ensure that transaction management does not affect session span",
        "check": "1"
    },
    {
        "commit_time": "2012-01-11 19:54:34-08:00",
        "diff": "mmm InstanceKlass . java <nl> ppp InstanceKlass . java <nl> - private static int IS_MARKED_DEPENDENT_MASK ; <nl> - miscFlags            = new CIntField(type . getCIntegerField(_misc_flags), Oop . getHeaderSize()) ; <nl> + isMarkedDependent    = new CIntField(type . getCIntegerField(_is_marked_dependent), Oop . getHeaderSize()) ; <nl> - IS_MARKED_DEPENDENT_MASK = db . lookupIntConstant(instanceKlass::IS_MARKED_DEPENDENT) . intValue() ; <nl> - private static CIntField miscFlags ; <nl> + private static CIntField isMarkedDependent ; <nl> - public boolean   getIsMarkedDependent()   { return                (miscFlags . getValue(this) & IS_MARKED_DEPENDENT_MASK) != 0 ; } <nl> + public boolean   getIsMarkedDependent()   { return                isMarkedDependent . getValue(this) != 0 ; } <nl> - visitor . doCInt(miscFlags, true) ; <nl> + visitor . doCInt(isMarkedDependent, true) ; <nl>",
        "commit_message": "7129240 : backout fix for 7102776 until 7128770 be resolve",
        "what": "backout fix for 7102776",
        "why": "until 7128770 be resolved",
        "check": "0"
    },
    {
        "commit_time": "2016-03-09 17:49:40-06:00",
        "diff": "mmm AppSettings . java <nl> ppp AppSettings . java <nl> - Context . MODE_WORLD_READABLE + Context . MODE_WORLD_WRITEABLE) ; <nl> + Context . MODE_PRIVATE) ; <nl> mmm UpdateUtils . java <nl> ppp UpdateUtils . java <nl> - Context . MODE_WORLD_READABLE + Context . MODE_WORLD_WRITEABLE) ; <nl> + Context . MODE_PRIVATE) ; <nl>",
        "commit_message": "updated file access modes from MODE_WORLD_READABLE and MODE_WORLD_WRITEABLE to MODE_PRIVATE in AppSettings.java and UpdateUtils.java to enhance security by limiting file access to the owning application only",
        "what": "updated file access modes from MODE_WORLD_READABLE and MODE_WORLD_WRITEABLE to MODE_PRIVATE in AppSettings.java and UpdateUtils.java",
        "why": "enhance security by limiting file access to the owning application only",
        "check": "1"
    },
    {
        "commit_time": "2016-06-13 03:37:12-07:00",
        "diff": "mmm ProjectCommand . java <nl> ppp ProjectCommand . java <nl> + @Option( <nl> + name = --exclude-artifacts, <nl> + usage = Don't include references to the artifacts created by compiling a target in + <nl> + the module representing that target . ) <nl> + private boolean excludeArtifacts = false ; <nl> - ImmutableSet<BuildTarget> requiredBuildTargets = project . write(runIjCleaner) ; <nl> + ImmutableSet<BuildTarget> requiredBuildTargets = project . write(runIjCleaner, excludeArtifacts) ; <nl> mmm IjModuleFactory . java <nl> ppp IjModuleFactory . java <nl> + private final boolean excludeShadows ; <nl> - public IjModuleFactory(IjModuleFactoryResolver moduleFactoryResolver) { <nl> + public IjModuleFactory( <nl> + IjModuleFactoryResolver moduleFactoryResolver, <nl> + boolean excludeShadows) { <nl> + this . excludeShadows = excludeShadows ; <nl> - private static <T extends JavaLibraryDescription . Arg> void addCompiledShadowIfNeeded( <nl> + private <T extends JavaLibraryDescription . Arg> void addCompiledShadowIfNeeded( <nl> + if (excludeShadows) { <nl> + return ; <nl> + } <nl> mmm IjProject . java <nl> ppp IjProject . java <nl> - public ImmutableSet<BuildTarget> write(boolean runPostGenerationCleaner) throws IOException { <nl> + public ImmutableSet<BuildTarget> write( <nl> + boolean runPostGenerationCleaner, <nl> + boolean excludeArtifacts) <nl> + throws IOException { <nl> - new IjModuleFactory(moduleFactoryResolver), <nl> + new IjModuleFactory(moduleFactoryResolver, excludeArtifacts), <nl> mmm IjModuleFactoryTest . java <nl> ppp IjModuleFactoryTest . java <nl> - }) ; <nl> + }, <nl> + false) ; <nl> mmm IjModuleGraphTest . java <nl> ppp IjModuleGraphTest . java <nl> - }) ; <nl> + }, <nl> + false) ; <nl>",
        "commit_message": "added functionality to exclude artifact references and updated related method signatures to enhance project management flexibility by allowing users to decide whether to include artifact references",
        "what": "added functionality to exclude artifact references and updated related method signatures",
        "why": "enhance project management flexibility by allowing users to decide whether to include artifact references",
        "check": "1"
    },
    {
        "commit_time": "2021-08-10 20:05:52+02:00",
        "diff": "mmm CtJavaDocImpl . java <nl> ppp CtJavaDocImpl . java <nl> - int indexEndSentence = this . getContent() . indexOf(' . ') ; <nl> - if (indexEndSentence == -1) { <nl> - indexEndSentence = this . getContent() . indexOf('\\n') ; <nl> + int indexOfFirstSentenceEnd = indexOfFirstSentenceEnd(this . getContent()) ; <nl> + if (indexOfFirstSentenceEnd == -1) { <nl> + indexOfFirstSentenceEnd = this . getContent() . indexOf('\\n') ; <nl> - if (indexEndSentence != -1) { <nl> - return this . getContent() . substring(0, indexEndSentence + 1) . trim() ; <nl> + if (indexOfFirstSentenceEnd != -1) { <nl> + return this . getContent() . substring(0, indexOfFirstSentenceEnd 1) . trim() ; <nl> + private int indexOfFirstSentenceEnd(String content) { <nl> + int index = content . indexOf(' . ') ; <nl> + while (index < content . length() - 1 <nl> + && !Character . isWhitespace(content . charAt(index 1)) <nl> + && index != -1) { <nl> + index = content . indexOf(' . ', index 1) ; <nl> + } <nl> + return index ; <nl> + } <nl> mmm CommentTest . java <nl> ppp CommentTest . java <nl> + import spoon . test . comment . testclasses . JavaDocWithLink ; <nl> + @Test <nl> + public void testJavadocCommentWithLink() { <nl> + Factory f = getSpoonFactory() ; <nl> + CtClass<?> type = (CtClass<?>) f . Type() . get(JavaDocWithLink . class) ; <nl> + CtJavaDoc classJavaDoc = (CtJavaDoc) type . getComments() . get(0) ; <nl> + assertEquals({@link spoon . Launcher Launcher} . , classJavaDoc . getShortDescription()) ; <nl> + classJavaDoc = (CtJavaDoc) type . getField(field1) . getComments() . get(0) ; <nl> + assertEquals({@link spoon . Launcher Launcher}, classJavaDoc . getShortDescription()) ; <nl> + classJavaDoc = (CtJavaDoc) type . getField(field2) . getComments() . get(0) ; <nl> + assertEquals({@link spoon . Launcher Launcher} . , classJavaDoc . getShortDescription()) ; <nl> + assertEquals(Additional text . , classJavaDoc . getLongDescription()) ; <nl> + } <nl> new file <nl> ppp JavaDocWithLink . java <nl> + package spoon . test . comment . testclasses ; <nl> + public class JavaDocWithLink { <nl> + int field1 ; <nl> + int field2 ; <nl> + } <nl>",
        "commit_message": "fix : get correct description from ctjavadocimpl ( # 4061 )",
        "what": "fix : get correct description from ctjavadocimpl",
        "why": "related to issue #4061",
        "check": "1"
    },
    {
        "commit_time": "2011-12-14 11:23:21+09:00",
        "diff": "mmm TimeZone . java <nl> ppp TimeZone . java <nl> + import sun . misc . SharedSecrets ; <nl> + import sun . misc . JavaAWTAccess ; <nl> - TimeZone defaultZone = defaultZoneTL . get() ; <nl> + TimeZone defaultZone = getDefaultInAppContext() ; <nl> - defaultZoneTL . set(null) ; <nl> + setDefaultInAppContext(null) ; <nl> - defaultZoneTL . set(zone) ; <nl> + setDefaultInAppContext(zone) ; <nl> + } <nl> + } <nl> + private synchronized static TimeZone getDefaultInAppContext() { <nl> + JavaAWTAccess javaAWTAccess = SharedSecrets . getJavaAWTAccess() ; <nl> + if (javaAWTAccess == null) { <nl> + return mainAppContextDefault ; <nl> + } else { <nl> + if (!javaAWTAccess . isDisposed()) { <nl> + TimeZone tz = (TimeZone) <nl> + javaAWTAccess . get(TimeZone . class) ; <nl> + if (tz == null && javaAWTAccess . isMainAppContext()) { <nl> + return mainAppContextDefault ; <nl> + } else { <nl> + return tz ; <nl> + } <nl> + } <nl> + } <nl> + return null ; <nl> + } <nl> + private synchronized static void setDefaultInAppContext(TimeZone tz) { <nl> + JavaAWTAccess javaAWTAccess = SharedSecrets . getJavaAWTAccess() ; <nl> + if (javaAWTAccess == null) { <nl> + mainAppContextDefault = tz ; <nl> + } else { <nl> + if (!javaAWTAccess . isDisposed()) { <nl> + javaAWTAccess . put(TimeZone . class, tz) ; <nl> + if (javaAWTAccess . isMainAppContext()) { <nl> + mainAppContextDefault = null ; <nl> + } <nl> + } <nl> - private static final InheritableThreadLocal<TimeZone> defaultZoneTL <nl> - = new InheritableThreadLocal<TimeZone>() ; <nl> + private static TimeZone mainAppContextDefault ; <nl> mmm AppContext . java <nl> ppp AppContext . java <nl> + static { <nl> + sun . misc . SharedSecrets . setJavaAWTAccess(new sun . misc . JavaAWTAccess() { <nl> + public Object get(Object key) { <nl> + return getAppContext() . get(key) ; <nl> + } <nl> + public void put(Object key, Object value) { <nl> + getAppContext() . put(key, value) ; <nl> + } <nl> + public void remove(Object key) { <nl> + getAppContext() . remove(key) ; <nl> + } <nl> + public boolean isDisposed() { <nl> + return getAppContext() . isDisposed() ; <nl> + } <nl> + public boolean isMainAppContext() { <nl> + return (numAppContexts == 1) ; <nl> + } <nl> + }) ; <nl> + } <nl> new file <nl> ppp JavaAWTAccess . java <nl> + package sun . misc ; <nl> + public interface JavaAWTAccess { <nl> + public Object get(Object key) ; <nl> + public void put(Object key, Object value) ; <nl> + public void remove(Object key) ; <nl> + public boolean isDisposed() ; <nl> + public boolean isMainAppContext() ; <nl> + } <nl> mmm SharedSecrets . java <nl> ppp SharedSecrets . java <nl> + private static JavaAWTAccess javaAWTAccess ; <nl> + public static void setJavaAWTAccess(JavaAWTAccess jaa) { <nl> + javaAWTAccess = jaa ; <nl> + } <nl> + public static JavaAWTAccess getJavaAWTAccess() { <nl> + return javaAWTAccess ; <nl> + } <nl>",
        "commit_message": "refactor TimeZone handling by replacing InheritableThreadLocal with a main application context mechanism to improve context management and reduce dependency on inherited thread-local storage",
        "what": "refactor TimeZone handling by replacing InheritableThreadLocal with a main application context mechanism",
        "why": "improve context management and reduce dependency on inherited thread-local storage",
        "check": "1"
    },
    {
        "commit_time": "2014-09-26 12:50:30-04:00",
        "diff": "new file <nl> ppp ShowClassLoader . java <nl> + public class ShowClassLoader { <nl> + public static void main(String[] args) { <nl> + Object[] oa = new Object[0] ; <nl> + ShowClassLoader[] sa = new ShowClassLoader[0] ; <nl> + System . out . println(Classloader for Object[] is  oa . getClass() . getClassLoader()) ; <nl> + System . out . println(Classloader for SCL[] is  sa . getClass() . getClassLoader() ) ; <nl> + if (sa . getClass() . getClassLoader() == null) { <nl> + throw new RuntimeException(Wrong class loader) ; <nl> + } <nl> + } <nl> + } <nl>",
        "commit_message": "added a new file ShowClassLoader.java to demonstrate class loader behavior for different object types to facilitate understanding of class loader assignment for arrays and verify correct class loader usage",
        "what": "added a new file ShowClassLoader.java to demonstrate class loader behavior for different object types",
        "why": "facilitate understanding of class loader assignment for arrays and verify correct class loader usage",
        "check": "1"
    },
    {
        "commit_time": "2017-09-28 18:10:34-04:00",
        "diff": "mmm SetUpKeyboardWizardFragmentTest . java <nl> ppp SetUpKeyboardWizardFragmentTest . java <nl> - Assert . assertEquals(4, pager . getAdapter() . getCount()) ; <nl> - Assert . assertTrue(((FragmentPagerAdapter) pager . getAdapter()) . getItem(2) instanceof WizardPermissionsFragment) ; <nl> + Assert . assertEquals(5, pager . getAdapter() . getCount()) ; <nl> + Assert . assertTrue(((FragmentPagerAdapter) pager . getAdapter()) . getItem(3) instanceof WizardPermissionsFragment) ; <nl> - Assert . assertEquals(3, pager . getAdapter() . getCount()) ; <nl> + Assert . assertEquals(4, pager . getAdapter() . getCount()) ; <nl> + Assert . assertTrue(((FragmentPagerAdapter) pager . getAdapter()) . getItem(0) instanceof WizardPageWelcomeFragment) ; <nl> + Robolectric . getForegroundThreadScheduler() . setIdleState(Scheduler . IdleState . PAUSED) ; <nl> + ((FragmentPagerAdapter) pager . getAdapter()) . getItem(0) . getView() . findViewById(R . id . go_to_start_setup) . performClick() ; <nl> + ensureAllScheduledJobsAreDone() ; <nl> + Robolectric . getForegroundThreadScheduler() . setIdleState(Scheduler . IdleState . UNPAUSED) ; <nl> + Assert . assertEquals(1, pager . getCurrentItem()) ; <nl> - Assert . assertEquals(1, pager . getCurrentItem()) ; <nl> + Assert . assertEquals(2, pager . getCurrentItem()) ; <nl> - Assert . assertEquals(2, pager . getCurrentItem()) ; <nl> + Assert . assertEquals(3, pager . getCurrentItem()) ; <nl> mmm WizardPageSwitchToKeyboardFragmentTest . java <nl> ppp WizardPageSwitchToKeyboardFragmentTest . java <nl> - Assert . assertFalse(stateIcon . isClickable()) ; <nl> + Assert . assertTrue(stateIcon . isClickable()) ; <nl> mmm WizardPagesAdapterTest . java <nl> ppp WizardPagesAdapterTest . java <nl> - Assert . assertEquals(4, adapter . getCount()) ; <nl> - Assert . assertTrue(adapter . getItem(2) instanceof WizardPermissionsFragment) ; <nl> + Assert . assertEquals(5, adapter . getCount()) ; <nl> + Assert . assertTrue(adapter . getItem(3) instanceof WizardPermissionsFragment) ; <nl> - Assert . assertEquals(3, adapter . getCount()) ; <nl> - Assert . assertFalse(adapter . getItem(2) instanceof WizardPermissionsFragment) ; <nl> + Assert . assertEquals(4, adapter . getCount()) ; <nl> + for (int fragmentIndex=0 ; fragmentIndex<adapter . getCount() ; fragmentIndex++) { <nl> + Assert . assertFalse(adapter . getItem(fragmentIndex) instanceof WizardPermissionsFragment) ; <nl> + } <nl> mmm WizardPermissionsFragmentTest . java <nl> ppp WizardPermissionsFragmentTest . java <nl> - public void testKeyboardNotEnabled() { <nl> + public void testWhenNoData() { <nl> - Assert . assertFalse(stateIcon . isClickable()) ; <nl> - } <nl> - @Test <nl> - public void testKeyboardEnabledButNotDefault() { <nl> - final String flatASKComponent = new ComponentName(BuildConfig . APPLICATION_ID, SoftKeyboard . class . getName()) . flattenToString() ; <nl> - ShadowSettings . ShadowSecure . putString(RuntimeEnvironment . application . getContentResolver(), Settings . Secure . ENABLED_INPUT_METHODS, flatASKComponent) ; <nl> - WizardPermissionsFragment fragment = startFragment() ; <nl> - Assert . assertFalse(fragment . isStepCompleted(RuntimeEnvironment . application)) ; <nl> - ImageView stateIcon = (ImageView) fragment . getView() . findViewById(R . id . step_state_icon) ; <nl> - Assert . assertNotNull(stateIcon) ; <nl> - Assert . assertEquals(R . drawable . ic_wizard_contacts_off, Shadows . shadowOf(stateIcon . getDrawable()) . getCreatedFromResId()) ; <nl> - Assert . assertFalse(stateIcon . isClickable()) ; <nl> + Assert . assertTrue(stateIcon . isClickable()) ; <nl>",
        "commit_message": "fix unit-tests due to ux change",
        "what": "fix unit-tests",
        "why": "due to ux change",
        "check": "1"
    },
    {
        "commit_time": "2009-07-28 12:17:22+00:00",
        "diff": "mmm SecurityOptionsPanel . java <nl> ppp SecurityOptionsPanel . java <nl> - import com . sun . tools . visualvm . core . options . SectionSeparator ; <nl> + import com . sun . tools . visualvm . core . ui . components . SectionSeparator ; <nl> - import org . openide . LifecycleManager ; <nl> mmm NetworkOptionsPanel . java <nl> ppp NetworkOptionsPanel . java <nl> - import com . sun . tools . visualvm . core . options . SectionSeparator ; <nl> + import com . sun . tools . visualvm . core . ui . components . SectionSeparator ; <nl> mmm GeneralOptionsPanel . java <nl> ppp GeneralOptionsPanel . java <nl> + import com . sun . tools . visualvm . core . ui . components . SectionSeparator ; <nl> mmm SectionSeparator . java <nl> ppp SectionSeparator . java <nl> - package com . sun . tools . visualvm . core . options ; <nl> + package com . sun . tools . visualvm . core . ui . components ; <nl> + import java . awt . Font ; <nl> - initComponents(text) ; <nl> + this(text, null) ; <nl> - private void initComponents(String text) { <nl> + public SectionSeparator(String text, Font font) { <nl> + if (text == null) throw new IllegalArgumentException(Text cannot be null) ; // NOI18N <nl> + initComponents(text, font) ; <nl> + } <nl> + private void initComponents(String text, Font font) { <nl> + JLabel label = new JLabel(text) ; <nl> + if (font != null) label . setFont(font) ; <nl> + else label . setFont(label . getFont() . deriveFont(Font . BOLD)) ; <nl> - add(new JLabel(text), c1) ; <nl> + add(label, c1) ; <nl>",
        "commit_message": "core : sectionseparator move from option to ui.components , add font customization",
        "what": "sectionseparator move from option to ui.components, add font customization",
        "why": "enable better organization and customization options in the UI",
        "check": "1"
    },
    {
        "commit_time": "2021-01-07 15:20:46+08:00",
        "diff": "mmm WitnessCreateActuator . java <nl> ppp WitnessCreateActuator . java <nl> - dynamicStore . addTransactionFeeAmount(cost) ; <nl> - dynamicStore . addTransactionFeeAmount(cost) ; <nl> mmm ReceiptCapsule . java <nl> ppp ReceiptCapsule . java <nl> - dynamicPropertiesStore . addTransactionFeeAmount(energyFee) ; <nl> - dynamicPropertiesStore . addTransactionFeeAmount(energyFee) ; <nl> mmm Manager . java <nl> ppp Manager . java <nl> - getDynamicPropertiesStore() . addTransactionFeeAmount(fee) ; <nl> - getDynamicPropertiesStore() . addTransactionFeeAmount(fee) ; <nl> - if (getDynamicPropertiesStore() . supportTransactionFeePool() || <nl> - getDynamicPropertiesStore() . supportRemoveBlackHole()) { <nl> - transactionInfo . setFee(getDynamicPropertiesStore() . getTransactionFeeAmount()) ; <nl> - getDynamicPropertiesStore() . saveTransactionFeeAmount(0L) ; <nl> - } <nl>",
        "commit_message": "removed duplicate calls to addTransactionFeeAmount in multiple classes to improve code clarity and reduce potential performance overhead",
        "what": "removed duplicate calls to addTransactionFeeAmount in multiple classes",
        "why": "improve code clarity and reduce potential performance overhead",
        "check": "1"
    },
    {
        "commit_time": "2021-02-17 17:49:12+00:00",
        "diff": "mmm Neo4jDataAutoConfiguration . java <nl> ppp Neo4jDataAutoConfiguration . java <nl> - import org . springframework . data . annotation . Persistent ; <nl> - Set<Class<?>> initialEntityClasses = new EntityScanner(applicationContext) . scan(Node . class, Persistent . class, <nl> + Set<Class<?>> initialEntityClasses = new EntityScanner(applicationContext) . scan(Node . class, <nl> mmm Neo4jDataAutoConfigurationTests . java <nl> ppp Neo4jDataAutoConfigurationTests . java <nl> - assertThat(mappingContext . hasPersistentEntityFor(TestPersistent . class)) . isTrue() ; <nl> + assertThat(mappingContext . hasPersistentEntityFor(TestPersistent . class)) . isFalse() ; <nl> mmm Neo4jReactiveDataAutoConfigurationTests . java <nl> ppp Neo4jReactiveDataAutoConfigurationTests . java <nl> - assertThat(mappingContext . hasPersistentEntityFor(TestPersistent . class)) . isTrue() ; <nl> + assertThat(mappingContext . hasPersistentEntityFor(TestPersistent . class)) . isFalse() ; <nl>",
        "commit_message": "do n't scan for  @ persistent  type a they may not be mean for neo4j",
        "what": "don't scan for @persistent type",
        "why": "they may not be meant for neo4j",
        "check": "1"
    },
    {
        "commit_time": "2011-07-29 18:35:02-07:00",
        "diff": "mmm AsyncJobManagerImpl . java <nl> ppp AsyncJobManagerImpl . java <nl> + import java . io . File ; <nl> + import java . io . FileInputStream ; <nl> + import java . util . Properties ; <nl> + import java . util . concurrent . RejectedExecutionException ; <nl> + import com . cloud . utils . PropertiesUtil ; <nl> - private final ExecutorService _executor = Executors . newCachedThreadPool(new NamedThreadFactory(Job-Executor)) ;\r <nl> + private ExecutorService _executor ;\r <nl> - _executor . submit(runnable) ; <nl> + _executor . submit(runnable) ; <nl> - scheduleExecution(job) ; <nl> + try { <nl> + scheduleExecution(job) ; <nl> + } catch(RejectedExecutionException e) { <nl> + s_logger . warn(Execution for job- job . getId()  is rejected, return it to the queue for next turn) ; <nl> + _queueMgr . returnItem(item . getId()) ; <nl> + } <nl> - try {\r <nl> + try { <nl> - }\r <nl> - executeQueueItem(item, false) ;\r <nl> + } <nl> + executeQueueItem(item, false) ; <nl> - return true ;\r <nl> + try { <nl> + final File dbPropsFile = PropertiesUtil . findConfigFile(db . properties) ; <nl> + final Properties dbProps = new Properties() ; <nl> + dbProps . load(new FileInputStream(dbPropsFile)) ; <nl> + final int cloudMaxActive = Integer . parseInt(dbProps . getProperty(db . cloud . maxActive)) ; <nl> + int poolSize = (cloudMaxActive * 2) / 3 ; <nl> + s_logger . info(Start AsyncJobManager thread pool in size  poolSize) ; <nl> + _executor = Executors . newFixedThreadPool(poolSize, new NamedThreadFactory(Job-Executor)) ; <nl> + } catch (final Exception e) { <nl> + throw new ConfigurationException(Unable to load db . properties to configure AsyncJobManagerImpl) ; <nl> + } <nl> + return true ; <nl> mmm SyncQueueManager . java <nl> ppp SyncQueueManager . java <nl> + public void returnItem(long queueItemId) ; <nl> mmm SyncQueueManagerImpl . java <nl> ppp SyncQueueManagerImpl . java <nl> + } <nl> + @Override <nl> + @DB <nl> + public void returnItem(long queueItemId) { <nl> + Transaction txt = Transaction . currentTxn() ; <nl> + try { <nl> + txt . start() ; <nl> + SyncQueueItemVO itemVO = _syncQueueItemDao . findById(queueItemId) ; <nl> + if(itemVO != null) { <nl> + SyncQueueVO queueVO = _syncQueueDao . lockRow(itemVO . getQueueId(), true) ; <nl> + itemVO . setLastProcessMsid(null) ; <nl> + itemVO . setLastProcessNumber(null) ; <nl> + _syncQueueItemDao . update(queueItemId, itemVO) ; <nl> + queueVO . setLastProcessTime(null) ; <nl> + queueVO . setLastUpdated(DateUtil . currentGMTTime()) ; <nl> + _syncQueueDao . update(queueVO . getId(), queueVO) ; <nl> + } <nl> + txt . commit() ; <nl> + } catch(Exception e) { <nl> + s_logger . error(Unexpected exception: , e) ; <nl> + txt . rollback() ; <nl> + } <nl>",
        "commit_message": "bug 10918 : cap async-job execution thread pool to be 2/3 of maximum db connection limit",
        "what": "cap async-job execution thread pool to be 2/3 of maximum db connection limit",
        "why": "relate to bug 10918",
        "check": "1"
    },
    {
        "commit_time": "2017-07-01 18:08:06-04:00",
        "diff": "mmm TellCommand . java <nl> ppp TellCommand . java <nl> - if (args . length == 1) { <nl> + if (args . length <= 1) { <nl>",
        "commit_message": "fix incorrect arg length in /tell",
        "what": "fix incorrect arg length in /tell",
        "why": "corrects a potential issue or bug related to argument length in the command",
        "check": "1"
    },
    {
        "commit_time": "2018-10-08 15:57:23-07:00",
        "diff": "mmm FlinkJobServerDriver . java <nl> ppp FlinkJobServerDriver . java <nl> - import com . google . common . base . Strings ; <nl> - if (Strings . isNullOrEmpty(configuration . host)) { <nl> + if (configuration . port == 0) { <nl> - if (Strings . isNullOrEmpty(configuration . host)) { <nl> + if (configuration . artifactPort == 0) { <nl>",
        "commit_message": "[ beam-4130 ] use port 0 to pick dynamic port-bugfix",
        "what": "use port 0 to pick dynamic port",
        "why": "bugfix",
        "check": "1"
    },
    {
        "commit_time": "2020-12-28 20:15:17+08:00",
        "diff": "mmm RaftMember . java <nl> ppp RaftMember . java <nl> + try { <nl> + Thread . sleep(1000) ; <nl> + } catch (InterruptedException e) { <nl> + Thread . currentThread() . interrupt() ; <nl> + } <nl> mmm MetaGroupMemberTest . java <nl> ppp MetaGroupMemberTest . java <nl> - import org . apache . iotdb . cluster . query . manage . QueryCoordinator ; <nl> - import org . apache . thrift . TException ; <nl> - new Thread(() -> { <nl> - resultHandler . onComplete(null) ; <nl> - }) . start() ; <nl> + new Thread(() -> resultHandler . onComplete(null)) . start() ; <nl>",
        "commit_message": "added a sleep delay in the RaftMember class and simplified thread creation in the MetaGroupMemberTest class to enhance thread management and improve code clarity",
        "what": "added a sleep delay in the RaftMember class and simplified thread creation in the MetaGroupMemberTest class",
        "why": "enhance thread management and improve code clarity",
        "check": "1"
    },
    {
        "commit_time": "2012-05-03 13:48:21-07:00",
        "diff": "mmm CuratorZookeeperClient . java <nl> ppp CuratorZookeeperClient . java <nl> - Watcher substituteParentWatcher(Watcher newWatcher) <nl> + void        addParentWatcher(Watcher watcher) <nl> - return state . substituteParentWatcher(newWatcher) ; <nl> + state . addParentWatcher(watcher) ; <nl> + } <nl> + void        removeParentWatcher(Watcher watcher) <nl> + { <nl> + state . removeParentWatcher(watcher) ; <nl> mmm SessionFailRetryLoop . java <nl> ppp SessionFailRetryLoop . java <nl> - import java . util . concurrent . atomic . AtomicReference ; <nl> - private final AtomicReference<Watcher>  previousParentWatcher = new AtomicReference<Watcher>() ; <nl> + private final Watcher         watcher = new Watcher() <nl> + { <nl> + @Override <nl> + public void process(WatchedEvent event) <nl> + { <nl> + if ( event . getState() == Event . KeeperState . Expired ) <nl> + { <nl> + sessionHasFailed . set(true) ; <nl> + failedSessionThreads . add(ourThread) ; <nl> + } <nl> + } <nl> + } ; <nl> - Preconditions . checkState(previousParentWatcher . get() == null, start() has already been called) ; <nl> - Watcher         watcher = new Watcher() <nl> - { <nl> - @Override <nl> - public void process(WatchedEvent event) <nl> - { <nl> - if ( event . getState() == Event . KeeperState . Expired ) <nl> - { <nl> - sessionHasFailed . set(true) ; <nl> - failedSessionThreads . add(ourThread) ; <nl> - } <nl> - Watcher localPreviousParentWatcher = previousParentWatcher . get() ; <nl> - if ( localPreviousParentWatcher != null ) <nl> - { <nl> - localPreviousParentWatcher . process(event) ; <nl> - } <nl> - } <nl> - } ; <nl> - previousParentWatcher . set(client . substituteParentWatcher(watcher)) ; <nl> + client . addParentWatcher(watcher) ; <nl> - Watcher previous = previousParentWatcher . getAndSet(null) ; <nl> - if ( previous != null ) <nl> - { <nl> - client . substituteParentWatcher(previous) ; <nl> - } <nl> + client . removeParentWatcher(watcher) ; <nl>",
        "commit_message": "use new list of parent watcher functionality to avoid edge case .",
        "what": "use new list of parent watcher functionality",
        "why": "to avoid edge case",
        "check": "1"
    },
    {
        "commit_time": "2015-12-29 10:41:40+05:00",
        "diff": "mmm DropwizardSSLConnectionSocketFactoryTest . java <nl> ppp DropwizardSSLConnectionSocketFactoryTest . java <nl> - final Response response = client . target(String . format(https://localhost:%d, TLS_APP_RULE . getLocalPort())) . request() . get() ; <nl> + client . target(String . format(https://localhost:%d, TLS_APP_RULE . getLocalPort())) . request() . get() ; <nl> - final ClientResponse response = client . target(String . format(https://localhost:%d, TLS_APP_RULE . getPort(1))) . request() . get(ClientResponse . class) ; <nl> + client . target(String . format(https://localhost:%d, TLS_APP_RULE . getPort(1))) . request() . get(ClientResponse . class) ; <nl> - final Response response = client . target(String . format(https://localhost:%d, TLS_APP_RULE . getPort(2))) . request() . get() ; <nl> + client . target(String . format(https://localhost:%d, TLS_APP_RULE . getPort(2))) . request() . get() ; <nl> - final Response response = client . target(String . format(https://localhost:%d, TLS_APP_RULE . getPort(3))) . request() . get() ; <nl> + client . target(String . format(https://localhost:%d, TLS_APP_RULE . getPort(3))) . request() . get() ; <nl> - final Response response = client . target(String . format(https://localhost:%d, TLS_APP_RULE . getPort(4))) . request() . get() ; <nl> + client . target(String . format(https://localhost:%d, TLS_APP_RULE . getPort(4))) . request() . get() ; <nl> mmm JsonProcessingExceptionMapperTest . java <nl> ppp JsonProcessingExceptionMapperTest . java <nl> - final Validator validator = Validators . newValidator() ; <nl>",
        "commit_message": "fix squid : s1481 - unused local variable should be remove",
        "what": "fix squid : s1481 - unused local variable should be removed",
        "why": "address coding standards and improve code quality by eliminating unused variables",
        "check": "1"
    },
    {
        "commit_time": "2018-07-24 08:31:09+02:00",
        "diff": "mmm ArbitraryDataProvider . java <nl> ppp ArbitraryDataProvider . java <nl> + cursor . close() ; <nl>",
        "commit_message": "added cursor.close() to ArbitraryDataProvider.java to ensure proper resource management and avoid potential memory leaks",
        "what": "added cursor.close() to ArbitraryDataProvider.java",
        "why": "ensure proper resource management and avoid potential memory leaks",
        "check": "1"
    },
    {
        "commit_time": "2012-09-29 15:00:59+00:00",
        "diff": "mmm MavenRepositorySystemSession . java <nl> ppp MavenRepositorySystemSession . java <nl>  <nl> mmm MavenServiceLocator . java <nl> ppp MavenServiceLocator . java <nl>  <nl>",
        "commit_message": "fix wrong explanation : repository system be a plexus component to use instead of mavenservicelocator , repository system session can be inject a plugin parameter",
        "what": "fix wrong explanation",
        "why": "repository system be a plexus component to use instead of mavenservicelocator, repository system session can be inject a plugin parameter",
        "check": "1"
    },
    {
        "commit_time": "2015-04-16 17:31:32+02:00",
        "diff": "mmm CodeGenerator . java <nl> ppp CodeGenerator . java <nl> + private int getScopeCallSiteFlags(final Symbol symbol) { <nl> + assert symbol . isScope() ; <nl> + final int flags = getCallSiteFlags() | CALLSITE_SCOPE ; <nl> + if (isEvalCode() && symbol . isGlobal()) { <nl> + return flags ; // Don't set fast-scope flag on non-declared globals in eval code - see JDK-8077955 .  <nl> + } <nl> + return isFastScope(symbol) ? flags | CALLSITE_FAST_SCOPE : flags ; <nl> + } <nl> - final int flags = CALLSITE_SCOPE | getCallSiteFlags() ; <nl> + final int flags = getScopeCallSiteFlags(symbol) ; <nl> - return lc . getScopeGet(unit, symbol, valueType, flags | CALLSITE_FAST_SCOPE) . generateInvoke(method) ; <nl> + return lc . getScopeGet(unit, symbol, valueType, flags) . generateInvoke(method) ; <nl> - super(identNode, resultBounds, flags | CALLSITE_FAST_SCOPE) ; <nl> + super(identNode, resultBounds, flags) ; <nl> - method . dynamicSet(symbol . getName(), flags | CALLSITE_FAST_SCOPE, false) ; <nl> + method . dynamicSet(symbol . getName(), flags, false) ; <nl> - final int scopeCallFlags = flags | (isFastScope ? CALLSITE_FAST_SCOPE : 0) ; <nl> - identNode . getType(), resultBounds . widest, paramTypes, scopeCallFlags) ; <nl> + identNode . getType(), resultBounds . widest, paramTypes, flags) ; <nl> - final int flags = getCallSiteFlags() | CALLSITE_SCOPE ; <nl> + final int flags = getScopeCallSiteFlags(symbol) ; <nl> - final int flags = CALLSITE_SCOPE | getCallSiteFlags() | (varNode . isBlockScoped() ? CALLSITE_DECLARE : 0) ; <nl> + final int flags = getScopeCallSiteFlags(identSymbol) | (varNode . isBlockScoped() ? CALLSITE_DECLARE : 0) ; <nl> - final int flags = CALLSITE_SCOPE | getCallSiteFlags() | (varNode . isBlockScoped() ? CALLSITE_DECLARE : 0) ; <nl> + final int flags = getScopeCallSiteFlags(identSymbol) | (varNode . isBlockScoped() ? CALLSITE_DECLARE : 0) ; <nl> - final int flags = CALLSITE_SCOPE | getCallSiteFlags() ; <nl> + final int flags = getScopeCallSiteFlags(symbol) ; <nl>",
        "commit_message": "added a method getScopeCallSiteFlags and updated flag handling throughout the CodeGenerator class to ensure correct flag settings for scope calls, particularly when dealing with global symbols in eval code",
        "what": "added a method getScopeCallSiteFlags and updated flag handling throughout the CodeGenerator class",
        "why": "ensure correct flag settings for scope calls, particularly when dealing with global symbols in eval code",
        "check": "1"
    },
    {
        "commit_time": "2013-10-08 19:57:11+02:00",
        "diff": "mmm ZipkinSpanCollector . java <nl> ppp ZipkinSpanCollector . java <nl> - private final SpanProcessingThread spanProcessingThread ; <nl> + private final List<SpanProcessingThread> spanProcessingThreads = new ArrayList<SpanProcessingThread>() ; <nl> - spanProcessingThread = new SpanProcessingThread(spanQueue, clientProvider, params . getBatchSize()) ; <nl> + final SpanProcessingThread spanProcessingThread = <nl> + new SpanProcessingThread(spanQueue, clientProvider, params . getBatchSize()) ; <nl> + spanProcessingThreads . add(spanProcessingThread) ; <nl> - spanProcessingThread . stop() ; <nl> + for (final SpanProcessingThread thread : spanProcessingThreads) { <nl> + thread . stop() ; <nl> + } <nl>",
        "commit_message": "replace a single SpanProcessingThread with a list of SpanProcessingThreads to enhance scalability by allowing multiple threads for processing spans",
        "what": "replace a single SpanProcessingThread with a list of SpanProcessingThreads",
        "why": "enhance scalability by allowing multiple threads for processing spans",
        "check": "1"
    },
    {
        "commit_time": "2022-12-02 11:57:28+03:00",
        "diff": "mmm SqlAvroTest . java <nl> ppp SqlAvroTest . java <nl> - properties . put(kafkastore . bootstrap . servers, kafkaTestSupport . getBrokerConnectionString()) ; <nl> + properties . put(SchemaRegistryConfig . KAFKASTORE_BOOTSTRAP_SERVERS_CONFIG, kafkaTestSupport . getBrokerConnectionString()) ; <nl> + properties . put(SchemaRegistryConfig . KAFKASTORE_TIMEOUT_CONFIG, 5000) ; <nl>",
        "commit_message": "fix timeout failure in sqlavrotest.test_toplevelfieldextraction [ hz-1841 ] ( # 23037 )",
        "what": "fix timeout failure in sqlavrotest.test_toplevelfieldextraction",
        "why": "addresses issue [ hz-1841 ] ( # 23037 )",
        "check": "1"
    },
    {
        "commit_time": "2018-03-27 13:51:02-07:00",
        "diff": "mmm DruidStorageHandlerUtils . java <nl> ppp DruidStorageHandlerUtils . java <nl> -  . readValue(fs . open(fileStatus . getPath()), DataSegment . class) ; <nl> +  . readValue((InputStream) fs . open(fileStatus . getPath()), DataSegment . class) ; <nl> mmm TestHiveDruidQueryBasedInputFormat . java <nl> ppp TestHiveDruidQueryBasedInputFormat . java <nl> - + \\granularity\\:\\DAY\\, <nl> + \\granularity\\:{\\type\\:\\period\\,\\period\\:\\P1D\\,\\timeZone\\: <nl> + \\America/Los_Angeles\\,\\origin\\:null}, <nl> - + \\granularity\\:\\DAY\\, <nl> + \\granularity\\:{\\type\\:\\period\\,\\period\\:\\P1D\\,\\timeZone\\: <nl> + \\America/Los_Angeles\\,\\origin\\:null}, <nl> mmm PTestClient . java <nl> ppp PTestClient . java <nl> - import org . codehaus . jackson . map . ObjectMapper ; <nl> + import com . fasterxml . jackson . databind . ObjectMapper ; <nl> mmm JIRAService . java <nl> ppp JIRAService . java <nl> - import org . codehaus . jackson . map . ObjectMapper ; <nl> - import org . codehaus . jackson . JsonFactory ; <nl> - import org . codehaus . jackson . JsonParser ; <nl> - import org . codehaus . jackson . JsonToken ; <nl> + import com . fasterxml . jackson . core . JsonFactory ; <nl> + import com . fasterxml . jackson . core . JsonParser ; <nl> + import com . fasterxml . jackson . core . JsonToken ; <nl> + import com . fasterxml . jackson . databind . ObjectMapper ; <nl>",
        "commit_message": "updated input stream handling and improved granularity specification in multiple files to enhance compatibility with the latest Jackson library and ensure correct granularity formatting for queries",
        "what": "updated input stream handling and improved granularity specification in multiple files",
        "why": "enhance compatibility with the latest Jackson library and ensure correct granularity formatting for queries",
        "check": "1"
    },
    {
        "commit_time": "2014-10-27 13:41:25-07:00",
        "diff": "mmm BucketPath . java <nl> ppp BucketPath . java <nl> + import java . util . concurrent . ConcurrentHashMap ; <nl> + protected static final ThreadLocal<HashMap<String, SimpleDateFormat>> simpleDateFormatCache = new ThreadLocal<HashMap<String, SimpleDateFormat>>() { <nl> + @Override <nl> + protected HashMap<String, SimpleDateFormat> initialValue() { <nl> + return new HashMap<String, SimpleDateFormat>() ; <nl> + } <nl> + } ; <nl> + protected static SimpleDateFormat getSimpleDateFormat(String string) { <nl> + HashMap<String, SimpleDateFormat> localCache = simpleDateFormatCache . get() ; <nl> + SimpleDateFormat simpleDateFormat = localCache . get(string) ; <nl> + if (simpleDateFormat == null) { <nl> + simpleDateFormat = new SimpleDateFormat(string) ; <nl> + localCache . put(string, simpleDateFormat) ; <nl> + simpleDateFormatCache . set(localCache) ; <nl> + } <nl> + return simpleDateFormat ; <nl> + } <nl> - SimpleDateFormat format = new SimpleDateFormat(formatString) ; <nl> + SimpleDateFormat format = getSimpleDateFormat(formatString) ; <nl>",
        "commit_message": "flume-2517 . cache simpledataformat object in bucketwriter for good performance .",
        "what": "cache simpledataformat object in bucketwriter",
        "why": "for good performance",
        "check": "1"
    },
    {
        "commit_time": "2022-11-08 14:14:20+01:00",
        "diff": "mmm CheckpointConfig . java <nl> ppp CheckpointConfig . java <nl> - @Deprecated private boolean failOnCheckpointingErrors = true ; <nl> - return failOnCheckpointingErrors ; <nl> + return getTolerableCheckpointFailureNumber() == 0 ; <nl> - this . failOnCheckpointingErrors = failOnCheckpointingErrors ; <nl>",
        "commit_message": "[ flink-29379 ] [ stream ] drop checkpointconfig # failoncheckpointingerrors and use gettolerablecheckpointfailurenumber ( ) instead",
        "what": "drop checkpointconfig # failoncheckpointingerrors and use gettolerablecheckpointfailurenumber ( ) instead",
        "why": "improve checkpoint handling in Flink by adjusting error tolerance behavior",
        "check": "1"
    },
    {
        "commit_time": "2012-12-20 12:45:13+00:00",
        "diff": "mmm AMQ4222Test . java <nl> ppp AMQ4222Test . java <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + private static final Logger LOG = LoggerFactory . getLogger(AMQ4222Test . class) ; <nl> - System . out . println(You got a message:  + ((TextMessage) message) . getText()) ; <nl> + LOG . info(You got a message:  ((TextMessage) message) . getText()) ; <nl> - System . out . println(error sending a response on the temp queue) ; <nl> + LOG . error(error sending a response on the temp queue) ; <nl>",
        "commit_message": "http : //issues.apache.org/jira/browse/amq-4222 - remove system.out.println from the test",
        "what": "remove system.out.println from the test",
        "why": "improve test output clarity",
        "check": "1"
    },
    {
        "commit_time": "2018-06-16 20:30:28-07:00",
        "diff": "mmm AstBuilder . java <nl> ppp AstBuilder . java <nl> + check(!filter . isPresent(), FILTER not valid for 'if' function, context) ; <nl> + check(!filter . isPresent(), FILTER not valid for 'nullif' function, context) ; <nl> + check(!filter . isPresent(), FILTER not valid for 'coalesce' function, context) ; <nl> + check(!filter . isPresent(), FILTER not valid for 'try' function, context) ; <nl> + check(!filter . isPresent(), FILTER not valid for '$internal$bind' function, context) ; <nl> mmm TestSqlParser . java <nl> ppp TestSqlParser . java <nl> + import com . facebook . presto . sql . tree . IfExpression ; <nl> + import com . facebook . presto . sql . tree . NullIfExpression ; <nl> + assertInvalidExpression(coalesce(1, 2) filter (where true), FILTER not valid for 'coalesce' function) ; <nl> + assertInvalidExpression(coalesce(1, 2) OVER (), OVER clause not valid for 'coalesce' function) ; <nl> + @Test <nl> + public void testIf() <nl> + { <nl> + assertExpression(if(true, 1, 0), new IfExpression(new BooleanLiteral(true), new LongLiteral(1), new LongLiteral(0))) ; <nl> + assertExpression(if(true, 3, null), new IfExpression(new BooleanLiteral(true), new LongLiteral(3), new NullLiteral())) ; <nl> + assertExpression(if(false, null, 4), new IfExpression(new BooleanLiteral(false), new NullLiteral(), new LongLiteral(4))) ; <nl> + assertExpression(if(false, null, null), new IfExpression(new BooleanLiteral(false), new NullLiteral(), new NullLiteral())) ; <nl> + assertExpression(if(true, 3), new IfExpression(new BooleanLiteral(true), new LongLiteral(3), null)) ; <nl> + assertInvalidExpression(IF(true), Invalid number of arguments for 'if' function) ; <nl> + assertInvalidExpression(IF(true, 1, 0) FILTER (WHERE true), FILTER not valid for 'if' function) ; <nl> + assertInvalidExpression(IF(true, 1, 0) OVER(), OVER clause not valid for 'if' function) ; <nl> + } <nl> + @Test <nl> + public void testNullIf() <nl> + { <nl> + assertExpression(nullif(42, 87), new NullIfExpression(new LongLiteral(42), new LongLiteral(87))) ; <nl> + assertExpression(nullif(42, null), new NullIfExpression(new LongLiteral(42), new NullLiteral())) ; <nl> + assertExpression(nullif(null, null), new NullIfExpression(new NullLiteral(), new NullLiteral())) ; <nl> + assertInvalidExpression(nullif(1), Invalid number of arguments for 'nullif' function) ; <nl> + assertInvalidExpression(nullif(1, 2, 3), Invalid number of arguments for 'nullif' function) ; <nl> + assertInvalidExpression(nullif(42, 87) filter (where true), FILTER not valid for 'nullif' function) ; <nl> + assertInvalidExpression(nullif(42, 87) OVER (), OVER clause not valid for 'nullif' function) ; <nl> + } <nl>",
        "commit_message": "fix incorrectly allow filter clause in conditional expression",
        "what": "fix incorrectly allow filter clause in conditional expression",
        "why": "[Reason not provided in the commit message]",
        "check": "0"
    },
    {
        "commit_time": "2013-05-14 11:13:12+08:00",
        "diff": "mmm AbstractNumberFormat . java <nl> ppp AbstractNumberFormat . java <nl> - private int multiplier ; <nl> + private double multiplier ; <nl> - this . multiplier = (int)Math . pow(10D, precision) ; <nl> + this . multiplier = Math . pow(10D, precision) ; <nl> - protected int getMultiplier() { <nl> + protected double getMultiplier() { <nl> mmm BigDecimalFormat . java <nl> ppp BigDecimalFormat . java <nl> + import java . math . RoundingMode ; <nl> - result = result . divide(new BigDecimal(super . getMultiplier())) ; <nl> + result = result . divide(new BigDecimal(super . getMultiplier()), super . getPrecision(), RoundingMode . HALF_EVEN) ; <nl> + } else { <nl> + if (super . getPrecision() != -1) { <nl> + result = result . setScale(super . getPrecision()) ; <nl> + } <nl> - if (super . getPrecision() != -1) { <nl> - result = result . setScale(super . getPrecision()) ; <nl> - } <nl>",
        "commit_message": "camel-6358 fixed the issue of implieddecimalseparator do n't work with big precision",
        "what": "fixed the issue of implieddecimalseparator don't work with big precision",
        "why": "camel-6358",
        "check": "0"
    },
    {
        "commit_time": "2015-04-22 13:38:32+02:00",
        "diff": "mmm DataSet . java <nl> ppp DataSet . java <nl> + public DataSink<T> print(String sinkIdentifier) { <nl> + return output(new PrintingOutputFormat<T>(sinkIdentifier, false)) ; <nl> + } <nl> + public DataSink<T> printToErr(String sinkIdentifier) { <nl> + return output(new PrintingOutputFormat<T>(sinkIdentifier, true)) ; <nl> + } <nl> mmm PrintingOutputFormat . java <nl> ppp PrintingOutputFormat . java <nl> - private boolean target ;  <nl> + private String sinkIdentifier ; <nl> + private boolean target ; <nl> + public PrintingOutputFormat(String sinkIdentifier, boolean stdErr) { <nl> + this(stdErr) ; <nl> + this . sinkIdentifier = sinkIdentifier ; <nl> + } <nl> - }\t <nl> + } <nl> - this . prefix = (numTasks > 1) ? ((taskNumber+1) + > ) : null ; <nl> + if (this . sinkIdentifier != null) { <nl> + this . prefix = this . sinkIdentifier ; <nl> + if (numTasks > 1) { <nl> + this . prefix += : (taskNumber 1) ; <nl> + } <nl> + this . prefix += >  ; <nl> + } else if (numTasks > 1) { <nl> + this . prefix = (taskNumber 1) >  ; <nl> + } else { <nl> + this . prefix =  ; <nl> + } <nl> - if (this . prefix != null) { <nl> - this . stream . println(this . prefix + record . toString()) ; <nl> - } <nl> - else { <nl> - this . stream . println(record . toString()) ; <nl> - } <nl> + this . stream . println(this . prefix record . toString()) ; <nl> + this . sinkIdentifier = null ; <nl>",
        "commit_message": "[ flink-1486 ] add additional print method for prefix a user-defined string",
        "what": "add additional print method for prefix a user-defined string",
        "why": "enhance functionality for better output customization",
        "check": "1"
    },
    {
        "commit_time": "2007-10-05 19:19:05+00:00",
        "diff": "mmm SpringIntegrationTest . java <nl> ppp SpringIntegrationTest . java <nl> + import static org . junit . Assert . fail ;\r <nl> + import java . io . File ;\r <nl> + import org . junit . Assert ;\r <nl> + import schemacrawler . tools . ExecutionContext ;\r <nl> + import schemacrawler . tools . ToolsExecutor ;\r <nl> - SchemaCrawlerOptions schemaCrawlerOptions = (SchemaCrawlerOptions) appContext\r <nl> + final SchemaCrawlerOptions schemaCrawlerOptions = (SchemaCrawlerOptions) appContext\r <nl> - DataSource dataSource = (DataSource) appContext . getBean(dataSource) ;\r <nl> + final DataSource dataSource = (DataSource) appContext . getBean(dataSource) ;\r <nl> + @Test\r <nl> + public void testToolsExecutorSchemaText()\r <nl> + throws Exception\r <nl> + {\r <nl> + final String outputFilename = File . createTempFile(schemacrawler, test)\r <nl> +  . getAbsolutePath() ;\r <nl> + final ExecutionContext executionContext = (ExecutionContext) appContext\r <nl> +  . getBean(executionContextForSchema) ;\r <nl> + final DataSource dataSource = (DataSource) appContext . getBean(dataSource) ;\r <nl> + executionContext . getToolOptions() . getOutputOptions()\r <nl> +  . setOutputFileName(outputFilename) ;\r <nl> + new ToolsExecutor() . execute(executionContext, dataSource) ;\r <nl> + final File outputFile = new File(outputFilename) ;\r <nl> + Assert . assertTrue(outputFile . exists()) ;\r <nl> + Assert . assertTrue(outputFile . length() > 0) ;\r <nl> + if (!outputFile . delete())\r <nl> + {\r <nl> + fail(Cannot delete output file) ;\r <nl> + }\r <nl> + } <nl>",
        "commit_message": "added a test method for ToolsExecutor and changed variable declarations to final in SpringIntegrationTest.java to improve code clarity and enforce immutability for better maintainability",
        "what": "added a test method for ToolsExecutor and changed variable declarations to final in SpringIntegrationTest.java",
        "why": "improve code clarity and enforce immutability for better maintainability",
        "check": "1"
    },
    {
        "commit_time": "2023-04-28 20:46:30+02:00",
        "diff": "mmm JvmstatModelProvider . java <nl> ppp JvmstatModelProvider . java <nl> + import sun . jvmstat . monitor . Monitor ; <nl> - if (vm . findByName(java . property . java . vm . version) != null) {   // NOI18N <nl> - JvmstatModelImpl jvmstat = new JvmstatModelImpl(app,vm) ; <nl> - app . notifyWhenRemoved(jvmstat) ; <nl> - return jvmstat ; <nl> - } else { <nl> - LOGGER . log(Level . INFO, java . property . java . vm . version is null) ; // NOI18N <nl> - } <nl> + Monitor vmEndTimeMon ; <nl> + long vmEndTime = 0 ; <nl> + long oldVmEndTime = 0 ; <nl> + do { <nl> + if (vm . findByName(java . property . java . vm . version) != null) {   // NOI18N <nl> + JvmstatModelImpl jvmstat = new JvmstatModelImpl(app,vm) ; <nl> + app . notifyWhenRemoved(jvmstat) ; <nl> + return jvmstat ; <nl> + } else { <nl> + LOGGER . log(Level . INFO, app . getId()+ java . property . java . vm . version is null) ; // NOI18N <nl> + vmEndTimeMon = vm . findByName(sun . rt . createVmEndTime) ;     // NOI18N <nl> + if (vmEndTimeMon != null) { <nl> + LOGGER . log(Level . INFO, app . getId()+ +vmEndTimeMon . getName()+ = +vmEndTimeMon . getValue()) ;   // NOI18N <nl> + oldVmEndTime = vmEndTime ; <nl> + vmEndTime = ((Long)vmEndTimeMon . getValue()) . longValue() ; <nl> + } <nl> + try { <nl> + Thread . sleep(100) ; <nl> + } catch (InterruptedException ex) { <nl> + } <nl> + } <nl> + } while (vmEndTimeMon != null && oldVmEndTime == 0) ; <nl> + LOGGER . log(Level . INFO, sun . rt . createVmEndTime is null +oldVmEndTime+ +vmEndTime) ; // NOI18N <nl>",
        "commit_message": "gh-493 'java.property.java.vm.version ' can be null if it be access too early after process be start and vm be not fully initialize - wait till vm be fully start",
        "what": "'java.property.java.vm.version' can be null if accessed too early after the process starts",
        "why": "wait till the VM is fully started",
        "check": "1"
    },
    {
        "commit_time": "2019-03-15 19:54:51-07:00",
        "diff": "mmm Background . java <nl> ppp Background . java <nl> - mLauncher . getSystemUiObject(recent_apps) . click() ; <nl> + mLauncher . waitForSystemUiObject(recent_apps) . click() ; <nl> - return mLauncher . getSystemUiObject(home) . getVisibleBounds() . centerY() ; <nl> + return mLauncher . waitForSystemUiObject(home) . getVisibleBounds() . centerY() ; <nl> mmm LauncherInstrumentation . java <nl> ppp LauncherInstrumentation . java <nl> - getSystemUiObject(home) . click() ; <nl> + waitForSystemUiObject(home) . click() ; <nl> - getSystemUiObject(home) . click() ; <nl> + waitForSystemUiObject(home) . click() ; <nl> - UiObject2 getSystemUiObject(String resId) { <nl> - final UiObject2 object = mDevice . findObject(By . res(SYSTEMUI_PACKAGE, resId)) ; <nl> + UiObject2 waitForSystemUiObject(String resId) { <nl> + final UiObject2 object = mDevice . wait( <nl> + Until . findObject(By . res(SYSTEMUI_PACKAGE, resId)), WAIT_TIME_MS) ; <nl> mmm Overview . java <nl> ppp Overview . java <nl> - final UiObject2 navBar = mLauncher . getSystemUiObject(navigation_bar_frame) ; <nl> + final UiObject2 navBar = mLauncher . waitForSystemUiObject(navigation_bar_frame) ; <nl>",
        "commit_message": "replaced direct calls to getSystemUiObject with waitForSystemUiObject in multiple files to ensure the UI elements are fully loaded before interaction to improve stability",
        "what": "replaced direct calls to getSystemUiObject with waitForSystemUiObject in multiple files",
        "why": "ensure the UI elements are fully loaded before interaction to improve stability",
        "check": "1"
    },
    {
        "commit_time": "2023-12-15 21:43:51-08:00",
        "diff": "mmm HollowConsumer . java <nl> ppp HollowConsumer . java <nl> - refreshExecutor = newSingleThreadExecutor(r -> daemonThread(r, getClass(), refresh)) ; <nl> + final Class<?> clazz = getClass() ; // to avoid capturing 'this' in lambda <nl> + refreshExecutor = newSingleThreadExecutor(r -> daemonThread(r, clazz, refresh)) ; <nl>",
        "commit_message": "fix : remove memory leak ( ref 'this ' ) from hollowconsumerbuilder ( # 653 )",
        "what": "remove memory leak (ref 'this') from hollowconsumerbuilder",
        "why": "fix an issue related to memory consumption (referenced by #653)",
        "check": "1"
    },
    {
        "commit_time": "2022-07-19 08:53:16-07:00",
        "diff": "mmm DeleteStatement . java <nl> ppp DeleteStatement . java <nl> - import org . openrewrite . java . tree . J ; <nl> - import org . openrewrite . java . tree . JavaType ; <nl> - import org . openrewrite . java . tree . Space ; <nl> - import org . openrewrite . java . tree . Statement ; <nl> + import org . openrewrite . java . tree . * ; <nl> + import static org . openrewrite . java . tree . Space . EMPTY ; <nl> - null, <nl> + JRightPadded . build(false), <nl> mmm NoDoubleBraceInitialization . java <nl> ppp NoDoubleBraceInitialization . java <nl> - JRightPadded<Boolean> padding ; <nl> + JRightPadded<Boolean> isStatic ; <nl> - padding = JRightPadded . build(true) . withAfter(Space . format( )) ; <nl> + isStatic = JRightPadded . build(true) . withAfter(Space . format( )) ; <nl> - padding = JRightPadded . build(false) ; <nl> + isStatic = JRightPadded . build(false) ; <nl> - padding, <nl> + isStatic, <nl>",
        "commit_message": "fix potential npe when use deletestatement visitor fix # 2061",
        "what": "fix potential npe when using deletestatement visitor",
        "why": "fix # 2061",
        "check": "1"
    },
    {
        "commit_time": "2019-10-04 19:04:33+03:30",
        "diff": "mmm DefaultSingleSignOnParticipationStrategy . java <nl> ppp DefaultSingleSignOnParticipationStrategy . java <nl> + import org . apereo . cas . authentication . AuthenticationServiceSelectionPlan ; <nl> + import org . apereo . cas . services . RegisteredService ; <nl> + @Getter <nl> + @Setter <nl> - @Getter <nl> - @Getter <nl> - @Setter <nl> - @Getter <nl> + private final AuthenticationServiceSelectionPlan serviceSelectionStrategy ; <nl> - var registeredService = WebUtils . getRegisteredService(requestContext) ; <nl> - if (registeredService == null) { <nl> - val service = WebUtils . getService(requestContext) ; <nl> - if (service != null) { <nl> - registeredService = this . servicesManager . findServiceBy(service) ; <nl> - } <nl> - } <nl> + val registeredService = determineRegisteredService(requestContext) ; <nl> + private RegisteredService determineRegisteredService(final RequestContext requestContext) { <nl> + val registeredService = WebUtils . getRegisteredService(requestContext) ; <nl> + if (registeredService != null) { <nl> + return registeredService ; <nl> + } <nl> + val service = WebUtils . getService(requestContext) ; <nl> + val serviceToUse = serviceSelectionStrategy . resolveService(service) ; <nl> + if (serviceToUse != null) { <nl> + return this . servicesManager . findServiceBy(serviceToUse) ; <nl> + } <nl> + return null ; <nl> + } <nl> mmm CasCoreWebflowConfiguration . java <nl> ppp CasCoreWebflowConfiguration . java <nl> - ticketRegistrySupport . getObject()) ; <nl> + ticketRegistrySupport . getObject(), <nl> + authenticationServiceSelectionPlan . getObject()) ; <nl> mmm DefaultSingleSignOnParticipationStrategyTests . java <nl> ppp DefaultSingleSignOnParticipationStrategyTests . java <nl> + import org . apereo . cas . authentication . AuthenticationServiceSelectionPlan ; <nl> + import org . apereo . cas . authentication . DefaultAuthenticationServiceSelectionPlan ; <nl> + import org . apereo . cas . authentication . DefaultAuthenticationServiceSelectionStrategy ; <nl> - val strategy = new DefaultSingleSignOnParticipationStrategy(mgr, true, true, mock(TicketRegistrySupport . class)) ; <nl> + val strategy = new DefaultSingleSignOnParticipationStrategy(mgr, true, true, <nl> + mock(TicketRegistrySupport . class), mock(AuthenticationServiceSelectionPlan . class)) ; <nl> - val strategy = new DefaultSingleSignOnParticipationStrategy(mgr, false, true, mock(TicketRegistrySupport . class)) ; <nl> + val strategy = new DefaultSingleSignOnParticipationStrategy(mgr, false, true, <nl> + mock(TicketRegistrySupport . class), mock(AuthenticationServiceSelectionPlan . class)) ; <nl> - val strategy = new DefaultSingleSignOnParticipationStrategy(mgr, false, true, mock(TicketRegistrySupport . class)) ; <nl> - context . setExternalContext(new ServletExternalContext(new MockServletContext(), request, response)) ; <nl> + val plan = new DefaultAuthenticationServiceSelectionPlan(new DefaultAuthenticationServiceSelectionStrategy()) ; <nl> + val strategy = new DefaultSingleSignOnParticipationStrategy(mgr, false, true, <nl> + mock(TicketRegistrySupport . class), plan) ; <nl> + context . setExternalContext(new ServletExternalContext(new MockServletContext(), request, response)) ; <nl> - public void verifyDoesNotParticipateSAMLCallback() { <nl> + public void verifyRegisteredServiceFromContextEvaluatedBeforeService() { <nl> - val strategy = new DefaultSingleSignOnParticipationStrategy(mgr, false, true, mock(TicketRegistrySupport . class)) ; <nl> + val strategy = new DefaultSingleSignOnParticipationStrategy(mgr, false, true, <nl> + mock(TicketRegistrySupport . class), mock(AuthenticationServiceSelectionPlan . class)) ; <nl> mmm InitialFlowSetupActionCookieTests . java <nl> ppp InitialFlowSetupActionCookieTests . java <nl> - true, mock(TicketRegistrySupport . class)), <nl> + true, mock(TicketRegistrySupport . class), mock(AuthenticationServiceSelectionPlan . class)), <nl>",
        "commit_message": "added authentication service selection plan to the DefaultSingleSignOnParticipationStrategy and related tests to enhance the authentication mechanism by introducing service selection flexibility",
        "what": "added authentication service selection plan to the DefaultSingleSignOnParticipationStrategy and related tests",
        "why": "enhance the authentication mechanism by introducing service selection flexibility",
        "check": "1"
    },
    {
        "commit_time": "2014-08-22 16:25:20+10:00",
        "diff": "mmm HttpScheme . java <nl> ppp HttpScheme . java <nl> - return _string . equalsIgnoreCase(s) ; <nl> + return s!=null && _string . equalsIgnoreCase(s) ; <nl> mmm HttpURI . java <nl> ppp HttpURI . java <nl> + public static HttpURI createHttpURI(String scheme, String host, int port, String path, String param, String query, String fragment) <nl> + { <nl> + if (port==80 && HttpScheme . HTTP . is(scheme)) <nl> + port=0 ; <nl> + if (port==443 && HttpScheme . HTTPS . is(scheme)) <nl> + port=0 ; <nl> + return new HttpURI(scheme,host,port,path,param,query,fragment) ; <nl> + } <nl> mmm Dispatcher . java <nl> ppp Dispatcher . java <nl> - int port=request . getServerPort() ; <nl> - if (port==80 && HttpScheme . HTTP . is(request . getScheme())) <nl> - port=0 ; <nl> - if (port==443 && HttpScheme . HTTPS . is(request . getScheme())) <nl> - port=0 ; <nl> - HttpURI uri = new HttpURI(request . getScheme(),request . getServerName(),request . getServerPort(),_uri . getPath(),baseRequest . getHttpURI() . getParam(),query,null) ; <nl> + HttpURI uri = HttpURI . createHttpURI(request . getScheme(),request . getServerName(),request . getServerPort(),_uri . getPath(),baseRequest . getHttpURI() . getParam(),query,null) ; <nl>",
        "commit_message": "updated HttpSchemes equalsIgnoreCase method to handle null inputs and added createHttpURI method to HttpURI class to enhance null safety and streamline URI creation logic",
        "what": "updated HttpSchemes equalsIgnoreCase method to handle null inputs and added createHttpURI method to HttpURI class",
        "why": "enhance null safety and streamline URI creation logic",
        "check": "1"
    },
    {
        "commit_time": "2008-07-26 01:39:14+00:00",
        "diff": "mmm ExecutionContext . java <nl> ppp ExecutionContext . java <nl> - import java . util . Properties ; <nl> - public Properties getProperties() { <nl> - Properties props = new Properties() ; <nl> - for (Entry<String, Object> entry : map . entrySet()) { <nl> - props . setProperty(entry . getKey(), entry . getValue() . toString()) ; <nl> - } <nl> - return props ; <nl> - } <nl>",
        "commit_message": "added a method to retrieve Properties from the ExecutionContext to enable better access to configurations stored in the context map",
        "what": "added a method to retrieve Properties from the ExecutionContext",
        "why": "enable better access to configurations stored in the context map",
        "check": "1"
    },
    {
        "commit_time": "2018-03-30 23:49:06-05:00",
        "diff": "mmm StringClientParam . java <nl> ppp StringClientParam . java <nl> + public IStringMatch contains() { <nl> + return new StringContains() ; <nl> + } <nl> + private class StringContains implements IStringMatch { <nl> + @Override <nl> + public ICriterion<StringClientParam> value(String theValue) { <nl> + return new StringCriterion<StringClientParam>(getParamName() Constants . PARAMQUALIFIER_STRING_CONTAINS, theValue) ; <nl> + } <nl> + @Override <nl> + public ICriterion<StringClientParam> value(StringDt theValue) { <nl> + return new StringCriterion<StringClientParam>(getParamName() Constants . PARAMQUALIFIER_STRING_CONTAINS, theValue . getValue()) ; <nl> + } <nl> + @Override <nl> + public ICriterion<StringClientParam> values(List<String> theValue) { <nl> + return new StringCriterion<StringClientParam>(getParamName() Constants . PARAMQUALIFIER_STRING_CONTAINS, theValue) ; <nl> + } <nl> + @Override <nl> + public ICriterion<?> values(String .  .  .  theValues) { <nl> + return new StringCriterion<StringClientParam>(getParamName() Constants . PARAMQUALIFIER_STRING_CONTAINS, Arrays . asList(theValues)) ; <nl> + } <nl> + } <nl> mmm SearchParameter . java <nl> ppp SearchParameter . java <nl> - ourParamQualifiers . put(RestSearchParameterTypeEnum . STRING, CollectionUtil . newSet(Constants . PARAMQUALIFIER_STRING_EXACT, Constants . PARAMQUALIFIER_MISSING, EMPTY_STRING)) ; <nl> + ourParamQualifiers . put(RestSearchParameterTypeEnum . STRING, CollectionUtil . newSet(Constants . PARAMQUALIFIER_STRING_EXACT, Constants . PARAMQUALIFIER_STRING_CONTAINS, Constants . PARAMQUALIFIER_MISSING, EMPTY_STRING)) ; <nl> mmm SearchParameter . java <nl> ppp SearchParameter . java <nl> - ourParamQualifiers . put(RestSearchParameterTypeEnum . STRING, CollectionUtil . newSet(Constants . PARAMQUALIFIER_STRING_EXACT, Constants . PARAMQUALIFIER_MISSING, EMPTY_STRING)) ; <nl> + ourParamQualifiers . put(RestSearchParameterTypeEnum . STRING, CollectionUtil . newSet(Constants . PARAMQUALIFIER_STRING_EXACT, Constants . PARAMQUALIFIER_STRING_CONTAINS, Constants . PARAMQUALIFIER_MISSING, EMPTY_STRING)) ; <nl>",
        "commit_message": "fix # 911 - add support for : contains modifier",
        "what": "add support for : contains modifier",
        "why": "fix # 911",
        "check": "1"
    },
    {
        "commit_time": "2019-02-05 17:20:23-08:00",
        "diff": "mmm BcfgFile . java <nl> ppp BcfgFile . java <nl>  <nl> mmm BcfgFileType . java <nl> ppp BcfgFileType . java <nl>  <nl> mmm BcfgFileTypeFactory . java <nl> ppp BcfgFileTypeFactory . java <nl>  <nl> mmm BcfgLanguage . java <nl> ppp BcfgLanguage . java <nl>  <nl> mmm BuckFile . java <nl> ppp BuckFile . java <nl>  <nl> mmm BuckFileType . java <nl> ppp BuckFileType . java <nl>  <nl> mmm BuckFileTypeFactory . java <nl> ppp BuckFileTypeFactory . java <nl>  <nl> mmm BuckLanguage . java <nl> ppp BuckLanguage . java <nl>  <nl> mmm BcfgElementType . java <nl> ppp BcfgElementType . java <nl>  <nl> mmm BcfgTokenType . java <nl> ppp BcfgTokenType . java <nl>  <nl> mmm BuckElementType . java <nl> ppp BuckElementType . java <nl>  <nl> mmm BuckTokenType . java <nl> ppp BuckTokenType . java <nl>  <nl>",
        "commit_message": "rename various classes related to Bcfg and Buck to improve consistency to enhance code clarity and maintainability by aligning naming conventions",
        "what": "rename various classes related to Bcfg and Buck to improve consistency",
        "why": "enhance code clarity and maintainability by aligning naming conventions",
        "check": "1"
    },
    {
        "commit_time": "2020-11-12 00:14:27+08:00",
        "diff": "mmm ReceiptCapsule . java <nl> ppp ReceiptCapsule . java <nl> - receipt . getEnergyUsageTotal(), energyProcessor, now) ; <nl> + receipt . getEnergyUsageTotal(), receipt . getResult(), energyProcessor, now) ; <nl> - receipt . getEnergyUsageTotal(), energyProcessor, now) ; <nl> + receipt . getEnergyUsageTotal(), receipt . getResult(), energyProcessor, now) ; <nl> - caller, callerUsage, energyProcessor, now) ; <nl> + caller, callerUsage, receipt . getResult(), energyProcessor, now) ; <nl> + contractResult contractResult, <nl> - if (dynamicPropertiesStore . supportTransactionFeePool()) { <nl> + if (dynamicPropertiesStore . supportTransactionFeePool() && <nl> + !contractResult . equals(contractResult . OUT_OF_TIME)) { <nl>",
        "commit_message": "update method calls to include receipt results and add a condition in the transaction fee check to ensure accurate energy usage reporting and prevent processing in out-of-time scenarios",
        "what": "update method calls to include receipt results and add a condition in the transaction fee check",
        "why": "ensure accurate energy usage reporting and prevent processing in out-of-time scenarios",
        "check": "1"
    },
    {
        "commit_time": "2017-12-13 11:34:44-08:00",
        "diff": "mmm KotlinLibraryDescription . java <nl> ppp KotlinLibraryDescription . java <nl> + import com . facebook . buck . jvm . java . toolchain . JavacOptionsProvider ; <nl> + import com . facebook . buck . toolchain . ToolchainProvider ; <nl> + private final ToolchainProvider toolchainProvider ; <nl> - private final JavacOptions defaultOptions ; <nl> + ToolchainProvider toolchainProvider, <nl> - JavaBuckConfig javaBuckConfig, <nl> - JavacOptions defaultOptions) { <nl> + JavaBuckConfig javaBuckConfig) { <nl> + this . toolchainProvider = toolchainProvider ; <nl> - this . defaultOptions = defaultOptions ; <nl> - JavacOptionsFactory . create(defaultOptions, buildTarget, projectFilesystem, resolver, args) ; <nl> + JavacOptionsFactory . create( <nl> + toolchainProvider <nl> +  . getByName(JavacOptionsProvider . DEFAULT_NAME, JavacOptionsProvider . class) <nl> +  . getJavacOptions(), <nl> + buildTarget, <nl> + projectFilesystem, <nl> + resolver, <nl> + args) ; <nl> mmm AbstractKnownBuildRuleTypes . java <nl> ppp AbstractKnownBuildRuleTypes . java <nl> - new KotlinLibraryDescription(kotlinBuckConfig, javaConfig, defaultJavacOptions)) ; <nl> + new KotlinLibraryDescription(toolchainProvider, kotlinBuckConfig, javaConfig)) ; <nl> mmm FauxKotlinLibraryBuilder . java <nl> ppp FauxKotlinLibraryBuilder . java <nl> + import static com . facebook . buck . jvm . java . JavaCompilationConstants . DEFAULT_JAVAC_OPTIONS ; <nl> + import com . facebook . buck . jvm . java . toolchain . JavacOptionsProvider ; <nl> + import com . facebook . buck . toolchain . impl . ToolchainProviderBuilder ; <nl> - super(new KotlinLibraryDescription(null, null, null), target, projectFilesystem, hashCode) ; <nl> + super( <nl> + new KotlinLibraryDescription( <nl> + new ToolchainProviderBuilder() <nl> +  . withToolchain( <nl> + JavacOptionsProvider . DEFAULT_NAME, <nl> + JavacOptionsProvider . of(DEFAULT_JAVAC_OPTIONS)) <nl> +  . build(), <nl> + null, <nl> + null), <nl> + target, <nl> + projectFilesystem, <nl> + hashCode) ; <nl>",
        "commit_message": "replaced default JavacOptions with ToolchainProvider in KotlinLibraryDescription and related classes to enhance flexibility in managing Java compilation options",
        "what": "replaced default JavacOptions with ToolchainProvider in KotlinLibraryDescription and related classes",
        "why": "enhance flexibility in managing Java compilation options",
        "check": "1"
    },
    {
        "commit_time": "2023-11-21 14:49:23+01:00",
        "diff": "mmm DeclarativeRecipe . java <nl> ppp DeclarativeRecipe . java <nl> - preconditions . add(recipe) ; <nl> + uninitializedPreconditions . add(recipe) ; <nl> - private Validated<Object> validation = Validated . test(initialization, <nl> - initialize( .  . ) must be called on DeclarativeRecipe prior to use . , <nl> - this, r -> uninitializedRecipes . isEmpty()) ; <nl> + private Validated<Object> validation = Validated . none() ; <nl> + @JsonIgnore <nl> + private Validated<Object> initValidation = null ; <nl> + initValidation = Validated . none() ; <nl> + initialized . clear() ; <nl> - validation = validation . and( <nl> + initValidation = initValidation . and( <nl> - uninitialized . clear() ; <nl> - return validation ; <nl> + return Validated . <Object>test(initialization, <nl> + initialize( .  . ) must be called on DeclarativeRecipe prior to use . , <nl> + this, r -> initValidation != null) <nl> +  . and(validation) <nl> +  . and(initValidation) ; <nl>",
        "commit_message": "replace preconditions with uninitializedPreconditions and modify validation handling in DeclarativeRecipe.java to improve initialization validation logic and ensure proper recipe setup before use",
        "what": "replace preconditions with uninitializedPreconditions and modify validation handling in DeclarativeRecipe.java",
        "why": "improve initialization validation logic and ensure proper recipe setup before use",
        "check": "1"
    },
    {
        "commit_time": "2021-05-10 14:42:07+01:00",
        "diff": "mmm PGConnectionContext . java <nl> ppp PGConnectionContext . java <nl> - doSendWithRetries(n, size n) ; <nl> + doSendWithRetries(offset n, size - n) ; <nl>",
        "commit_message": "fix ( pgwire ) : incorrect buffer be send to client when single buffer it interrupt more than once ( # 998 )",
        "what": "fix incorrect buffer be send to client when single buffer it interrupt more than once",
        "why": "address issue #998",
        "check": "1"
    },
    {
        "commit_time": "2021-08-11 20:54:47+02:00",
        "diff": "mmm SavepointEnvironment . java <nl> ppp SavepointEnvironment . java <nl> - public ThroughputCalculator getThroughputMeter() { <nl> + public ThroughputCalculator getThroughputCalculator() { <nl> mmm Environment . java <nl> ppp Environment . java <nl> - ThroughputCalculator getThroughputMeter() ; <nl> + ThroughputCalculator getThroughputCalculator() ; <nl> mmm RuntimeEnvironment . java <nl> ppp RuntimeEnvironment . java <nl> - public ThroughputCalculator getThroughputMeter() { <nl> + public ThroughputCalculator getThroughputCalculator() { <nl> mmm DummyEnvironment . java <nl> ppp DummyEnvironment . java <nl> - public ThroughputCalculator getThroughputMeter() { <nl> + public ThroughputCalculator getThroughputCalculator() { <nl> mmm MockEnvironment . java <nl> ppp MockEnvironment . java <nl> - public ThroughputCalculator getThroughputMeter() { <nl> + public ThroughputCalculator getThroughputCalculator() { <nl> mmm MockEnvironmentBuilder . java <nl> ppp MockEnvironmentBuilder . java <nl> - public MockEnvironmentBuilder setThroughputMeter(ThroughputCalculator throughputCalculator) { <nl> + public MockEnvironmentBuilder setThroughputCalculator( <nl> + ThroughputCalculator throughputCalculator) { <nl> mmm StreamTask . java <nl> ppp StreamTask . java <nl> - this . throughputCalculator = environment . getThroughputMeter() ; <nl> + this . throughputCalculator = environment . getThroughputCalculator() ; <nl> mmm StreamMockEnvironment . java <nl> ppp StreamMockEnvironment . java <nl> - public ThroughputCalculator getThroughputMeter() { <nl> + public ThroughputCalculator getThroughputCalculator() { <nl> mmm StreamTaskMailboxTestHarnessBuilder . java <nl> ppp StreamTaskMailboxTestHarnessBuilder . java <nl> - public <T> StreamTaskMailboxTestHarnessBuilder<OUT> setThroughputMeter( <nl> + public <T> StreamTaskMailboxTestHarnessBuilder<OUT> setThroughputCalculator( <nl> mmm StreamTaskTest . java <nl> ppp StreamTaskTest . java <nl> - ThroughputCalculator throughputCalculator = environment . getThroughputMeter() ; <nl> + ThroughputCalculator throughputCalculator = environment . getThroughputCalculator() ; <nl> -  . setThroughputMeter( <nl> +  . setThroughputCalculator( <nl> -  . setThroughputMeter( <nl> +  . setThroughputCalculator( <nl>",
        "commit_message": "[ hotfix ] [ runtime ] setthroughputmeter rename to setthroughputcalculator accord to name of the set object .",
        "what": "setthroughputmeter rename to setthroughputcalculator",
        "why": "accord to name of the set object",
        "check": "1"
    },
    {
        "commit_time": "2017-02-20 12:33:24-08:00",
        "diff": "mmm CalcitePlanner . java <nl> ppp CalcitePlanner . java <nl> + processPositionAlias(ast) ; <nl> mmm SemanticAnalyzer . java <nl> ppp SemanticAnalyzer . java <nl> - processPositionAlias(ast) ; <nl> + processPositionAlias(ast) ; <nl> + processPositionAlias(tree) ; <nl> - private void processPositionAlias(ASTNode ast) throws SemanticException { <nl> + public void processPositionAlias(ASTNode ast) throws SemanticException { <nl>",
        "commit_message": "updated the method visibility of processPositionAlias from private to public and added an additional parameter in SemanticAnalyzer to allow access to processPositionAlias from other classes and handle multiple AST nodes",
        "what": "updated the method visibility of processPositionAlias from private to public and added an additional parameter in SemanticAnalyzer",
        "why": "allow access to processPositionAlias from other classes and handle multiple AST nodes",
        "check": "1"
    },
    {
        "commit_time": "2014-11-06 22:45:04-03:00",
        "diff": "mmm Connection . java <nl> ppp Connection . java <nl> - outputStream . close() ; <nl> + outputStream . close() ; <nl>",
        "commit_message": "fix disconnect socket closing to make it work with java 8",
        "what": "fix disconnect socket closing",
        "why": "to make it work with java 8",
        "check": "1"
    },
    {
        "commit_time": "2018-02-17 12:12:53+01:00",
        "diff": "mmm RtMethod . java <nl> ppp RtMethod . java <nl> - public static <T> RtMethod[] sameMethodsWithDifferentTypeOf(Class<T> superClass, List<RtMethod> comparedMethods) { <nl> + public static <T> RtMethod[] sameMethodsWithDifferentTypeOf(Class<T> klass, List<RtMethod> comparedMethods) { <nl> - for (Method method : superClass . getDeclaredMethods()) { <nl> + for (Method method : klass . getDeclaredMethods()) { <nl>",
        "commit_message": "doc : add doc for public method in rtmethod ( # 1858 )",
        "what": "add doc for public method in rtmethod",
        "why": "improve documentation (issue #1858)",
        "check": "1"
    },
    {
        "commit_time": "2021-02-22 23:11:03+00:00",
        "diff": "mmm StatsLogCompatManager . java <nl> ppp StatsLogCompatManager . java <nl> + case SEARCH_ACTION_ITEM: <nl> + return info . getSearchActionItem() . getPackageName() ; <nl> + case SEARCH_ACTION_ITEM: <nl> + return info . getSearchActionItem() . getTitle() ; <nl> mmm SearchActionItemInfo . java <nl> ppp SearchActionItemInfo . java <nl> + import com . android . launcher3 . logger . LauncherAtom . ItemInfo ; <nl> + import com . android . launcher3 . logger . LauncherAtom . SearchActionItem ; <nl> + @Override <nl> + public ItemInfo buildProto(FolderInfo fInfo) { <nl> + return getDefaultItemInfoBuilder() <nl> +  . setSearchActionItem( <nl> + SearchActionItem . newBuilder() <nl> +  . setTitle(title . toString()) <nl> +  . setPackageName(mFallbackPackageName)) <nl> +  . setContainerInfo(getContainerInfo()) <nl> +  . build() ; <nl> + } <nl> mmm ItemClickHandler . java <nl> ppp ItemClickHandler . java <nl> + import static com . android . launcher3 . logging . StatsLogManager . LauncherEvent . LAUNCHER_APP_LAUNCH_TAP ; <nl> + launcher . getStatsLogManager() . logger() . withItemInfo(itemInfo) . log(LAUNCHER_APP_LAUNCH_TAP) ; <nl>",
        "commit_message": "added functionality to retrieve search action items and their package names in StatsLogCompatManager to enhance logging capabilities for better tracking of search actions",
        "what": "added functionality to retrieve search action items and their package names in StatsLogCompatManager",
        "why": "enhance logging capabilities for better tracking of search actions",
        "check": "1"
    },
    {
        "commit_time": "2015-12-07 21:18:33-05:00",
        "diff": "mmm DistributeLoad . java <nl> ppp DistributeLoad . java <nl> + session . rollback() ; <nl> + context . yield() ; <nl>",
        "commit_message": "nifi-1269 : ensure that we roll back session if not transfer flowfile",
        "what": "ensure that we roll back session if not transfer flowfile",
        "why": "relates to issue nifi-1269",
        "check": "1"
    },
    {
        "commit_time": "2021-10-08 12:33:57+02:00",
        "diff": "mmm JavaScriptRoutesBuilderLoader . java <nl> ppp JavaScriptRoutesBuilderLoader . java <nl> + import org . graalvm . polyglot . HostAccess ; <nl> + import org . graalvm . polyglot . PolyglotAccess ; <nl> - final Context context = Context . newBuilder(LANGUAGE_ID) . allowAllAccess(true) . build() ; <nl> + final Context . Builder contextBuilder = Context . newBuilder(LANGUAGE_ID) <nl> +  . allowHostAccess(HostAccess . ALL) <nl> +  . allowExperimentalOptions(true) <nl> +  . allowHostClassLookup(s -> true) <nl> +  . allowPolyglotAccess(PolyglotAccess . NONE) <nl> +  . option(engine . WarnInterpreterOnly, false) ; <nl> + final Context context = contextBuilder . build() ; <nl>",
        "commit_message": "dsl : configure host access policy and disable warning for interpreted mode only",
        "what": "configure host access policy and disable warning for interpreted mode only",
        "why": "improve security and user experience by managing host access and reducing unnecessary warnings",
        "check": "1"
    },
    {
        "commit_time": "2018-03-05 15:59:13+08:00",
        "diff": "mmm WitnessCapsule . java <nl> ppp WitnessCapsule . java <nl> + public Long getVoteCount() { <nl> + return witness . getVoteCount() ; <nl> + } <nl> mmm Manager . java <nl> ppp Manager . java <nl> + import com . google . common . collect . Lists ; <nl> - import org . tron . protos . Protocal . Account ; <nl> + import org . tron . protos . Protocal . Account ; <nl> + private static final int MAX_ACTIVE_WITNESS_NUM = 21 ; <nl> + List<WitnessCapsule> witnessCapsuleList = Lists . newArrayList() ; <nl> + witnessCapsuleList . add(new WitnessCapsule(witnessTarget)) ; <nl> + witnessCapsuleList . sort((a, b) -> { <nl> + return (int) (a . getVoteCount() - b . getVoteCount()) ; <nl> + }) ; <nl> + wits = witnessCapsuleList . subList(0, MAX_ACTIVE_WITNESS_NUM) ; <nl>",
        "commit_message": "added a method to get the vote count in the WitnessCapsule class and modified the Manager class to manage a sorted list of active witnesses to enhance the functionality of vote tracking and enforce a limit on the number of active witnesses",
        "what": "added a method to get the vote count in the WitnessCapsule class and modified the Manager class to manage a sorted list of active witnesses",
        "why": "enhance the functionality of vote tracking and enforce a limit on the number of active witnesses",
        "check": "1"
    },
    {
        "commit_time": "2014-02-07 09:38:41+01:00",
        "diff": "mmm BTCChinaAccountDemo . java <nl> ppp BTCChinaAccountDemo . java <nl> + import java . math . BigDecimal ;\r <nl> + String withdrawResult = accountService . withdrawFunds(new BigDecimal(1) . movePointLeft(5), 1CoPAWJtran45gNM21te1xgZqbDd5UqYWB) ;\r <nl> + System . out . println(withdrawResult =  withdrawResult) ; <nl>",
        "commit_message": "added currency withdrawal functionality with proper amount handling and output logging to enable users to withdraw funds in a specified amount and receive feedback on the transaction",
        "what": "added currency withdrawal functionality with proper amount handling and output logging",
        "why": "enable users to withdraw funds in a specified amount and receive feedback on the transaction",
        "check": "1"
    },
    {
        "commit_time": "2017-05-26 17:06:03-04:00",
        "diff": "mmm WelcomeActivity . java <nl> ppp WelcomeActivity . java <nl> + private WelcomePagerAdapter adapter = new WelcomePagerAdapter() ; <nl> - setUpAdapter() ; <nl> + pager . setAdapter(adapter) ; <nl> + indicator . setViewPager(pager) ; <nl> + adapter . setCallback(new WelcomePagerAdapter . Callback() { <nl> + @Override <nl> + public void onYesClicked() { <nl> + finish() ; <nl> + } <nl> + }) ; <nl> - private void setUpAdapter() { <nl> - pager . setAdapter(new WelcomePagerAdapter()) ; <nl> - indicator . setViewPager(pager) ; <nl> + @Override <nl> + public void onDestroy() { <nl> + adapter . setCallback(null) ; <nl> + super . onDestroy() ; <nl> mmm WelcomePagerAdapter . java <nl> ppp WelcomePagerAdapter . java <nl> - import android . app . Activity ; <nl> + import android . support . annotation . Nullable ; <nl> + private Callback callback ; <nl> + public interface Callback { <nl> + void onYesClicked() ; <nl> + } <nl> + public void setCallback(@Nullable Callback callback) { <nl> + this . callback = callback ; <nl> + } <nl> - public static class ViewHolder { <nl> - public ViewHolder(View view) { <nl> + class ViewHolder { <nl> + ViewHolder(View view) { <nl> - void onClicked(View view) { <nl> - ((Activity) view . getContext()) . finish() ; <nl> + void onClicked() { <nl> + if (callback != null) { <nl> + callback . onYesClicked() ; <nl> + } <nl>",
        "commit_message": "refactor WelcomeActivity to use a WelcomePagerAdapter with a callback for handling user confirmation to improve code modularity and enable better management of user interactions",
        "what": "refactor WelcomeActivity to use a WelcomePagerAdapter with a callback for handling user confirmation",
        "why": "improve code modularity and enable better management of user interactions",
        "check": "1"
    },
    {
        "commit_time": "2018-08-15 18:39:07-07:00",
        "diff": "mmm MovementFall . java <nl> ppp MovementFall . java <nl> + import net . minecraft . block . Block ; <nl> - targetRotation = LookBehaviorUtils . reachable(dest . down()) ; <nl> + targetRotation = LookBehaviorUtils . reachable((BlockStateInterface . get(dest) . getCollisionBoundingBox(mc . world, dest) == Block . NULL_AABB) ? dest : dest . down()) ; <nl>",
        "commit_message": "address raytrace bush failure when fall ( # 15 )",
        "what": "address raytrace bush failure when fall",
        "why": "relates to issue #15",
        "check": "1"
    },
    {
        "commit_time": "2018-08-06 15:10:30+02:00",
        "diff": "mmm OCFile . java <nl> ppp OCFile . java <nl> - int result = (int) (mId ^ (mId >>> 32)) ; <nl> - result = 31 * result + (int) (mParentId ^ (mParentId >>> 32)) ; <nl> - return result ; <nl> + return 31 * (int) (mId ^ (mId >>> 32)) (int) (mParentId ^ (mParentId >>> 32)) ; <nl> - asString = String . format(asString, mId, getFileName(), mMimeType, isDown(), <nl> + return String . format(asString, mId, getFileName(), mMimeType, isDown(), <nl> - return asString ; <nl>",
        "commit_message": "findbugs : do n't locally store return result before immediately return it",
        "what": "do not locally store return result before immediately returning it",
        "why": "related to findbugs analysis",
        "check": "1"
    },
    {
        "commit_time": "2008-07-07 01:54:41+00:00",
        "diff": "mmm IntegrationSecurityNamespaceHandler . java <nl> ppp IntegrationSecurityNamespaceHandler . java <nl> - import org . springframework . integration . security . channel . config . SecuredChannelsParser ; <nl> - import org . springframework . integration . security . channel . config . SecurityPropagatingChannelsParser ; <nl> - import org . springframework . integration . security . endpoint . config . SecurityEndpointInterceptorParser ; <nl> mmm SecuredChannelsParser . java <nl> ppp SecuredChannelsParser . java <nl> - package org . springframework . integration . security . channel . config ; <nl> + package org . springframework . integration . security . config ; <nl> mmm SecurityEndpointInterceptorParser . java <nl> ppp SecurityEndpointInterceptorParser . java <nl> - package org . springframework . integration . security . endpoint . config ; <nl> + package org . springframework . integration . security . config ; <nl> mmm SecurityPropagatingBeanPostProcessor . java <nl> ppp SecurityPropagatingBeanPostProcessor . java <nl> - package org . springframework . integration . security . channel . config ; <nl> + package org . springframework . integration . security . config ; <nl> - import org . springframework . integration . security . config . OrderedIncludeExcludeList ; <nl> mmm SecurityPropagatingChannelsParser . java <nl> ppp SecurityPropagatingChannelsParser . java <nl> - package org . springframework . integration . security . channel . config ; <nl> + package org . springframework . integration . security . config ; <nl> - import org . springframework . integration . security . config . IncludeExcludePatternParser ; <nl> - import org . springframework . integration . security . config . OrderedIncludeExcludeList ; <nl> mmm SecuredChannelsParserTests . java <nl> ppp SecuredChannelsParserTests . java <nl> - package org . springframework . integration . security . channel . config ; <nl> + package org . springframework . integration . security . config ; <nl> mmm SecurityPropagatingChannelsParserTests . java <nl> ppp SecurityPropagatingChannelsParserTests . java <nl> - package org . springframework . integration . security . channel . config ; <nl> + package org . springframework . integration . security . config ; <nl>",
        "commit_message": "consolidated security parser into the main 'config ' package ( avoids a tangle ) .",
        "what": "consolidated security parser into the main 'config' package",
        "why": "avoids a tangle",
        "check": "1"
    },
    {
        "commit_time": "2016-12-19 16:52:13+01:00",
        "diff": "mmm TraceContinuingCallable . java <nl> ppp TraceContinuingCallable . java <nl> - getTracer() . detach(span) ; <nl> + if (getTracer() . isTracing()) { <nl> + getTracer() . detach(span) ; <nl> + } <nl> mmm SleuthHystrixConcurrencyStrategy . java <nl> ppp SleuthHystrixConcurrencyStrategy . java <nl> + import org . apache . commons . logging . Log ; <nl> + import org . apache . commons . logging . LogFactory ; <nl> + import org . springframework . cloud . sleuth . Span ; <nl> + import org . springframework . cloud . sleuth . TraceKeys ; <nl> + import org . springframework . cloud . sleuth . Tracer ; <nl> - import org . apache . commons . logging . Log ; <nl> - import org . apache . commons . logging . LogFactory ; <nl> - import org . springframework . cloud . sleuth . Span ; <nl> - import org . springframework . cloud . sleuth . TraceKeys ; <nl> - import org . springframework . cloud . sleuth . Tracer ; <nl> - else { <nl> + else if(this . tracer . isTracing()) { <nl> mmm SleuthRxJavaSchedulersHook . java <nl> ppp SleuthRxJavaSchedulersHook . java <nl> - } else { <nl> + } else if (this . tracer . isTracing()) { <nl>",
        "commit_message": "added a check for tracer status before detaching span in TraceContinuingCallable and modified imports in SleuthHystrixConcurrencyStrategy to ensure span is only detached when tracing is active to improve tracing accuracy",
        "what": "added a check for tracer status before detaching span in TraceContinuingCallable and modified imports in SleuthHystrixConcurrencyStrategy",
        "why": "ensure span is only detached when tracing is active to improve tracing accuracy",
        "check": "1"
    },
    {
        "commit_time": "2022-09-20 16:53:41+00:00",
        "diff": "mmm BaseActivity . java <nl> ppp BaseActivity . java <nl> + import android . os . Bundle ; <nl> + import android . window . OnBackInvokedDispatcher ; <nl> + import com . android . launcher3 . testing . TestLogging ; <nl> + import com . android . launcher3 . testing . shared . TestProtocol ; <nl> + @Override <nl> + protected void onCreate(Bundle savedInstanceState) { <nl> + super . onCreate(savedInstanceState) ; <nl> + if (Utilities . ATLEAST_T) { <nl> + getOnBackInvokedDispatcher() . registerOnBackInvokedCallback( <nl> + OnBackInvokedDispatcher . PRIORITY_DEFAULT, <nl> + () -> { <nl> + onBackPressed() ; <nl> + TestLogging . recordEvent(TestProtocol . SEQUENCE_MAIN, onBackInvoked) ; <nl> + }) ; <nl> + } <nl> + } <nl> mmm Launcher . java <nl> ppp Launcher . java <nl> - import android . window . OnBackInvokedDispatcher ; <nl> - registerOnBackInvokedCallback() ; <nl> - private void registerOnBackInvokedCallback() { <nl> - if (Utilities . ATLEAST_T) { <nl> - getOnBackInvokedDispatcher() . registerOnBackInvokedCallback( <nl> - OnBackInvokedDispatcher . PRIORITY_DEFAULT, <nl> - () -> { <nl> - onBackPressed() ; <nl> - TestLogging . recordEvent(TestProtocol . SEQUENCE_MAIN, onBackInvoked) ; <nl> - }) ; <nl> - } <nl> - } <nl>",
        "commit_message": "added onBackInvokedDispatcher registration to BaseActivity and removed it from Launcher to streamline back navigation handling and consolidate event logging",
        "what": "added onBackInvokedDispatcher registration to BaseActivity and removed it from Launcher",
        "why": "streamline back navigation handling and consolidate event logging",
        "check": "1"
    },
    {
        "commit_time": "2020-05-01 19:27:31+01:00",
        "diff": "mmm ClusterTest . java <nl> ppp ClusterTest . java <nl> - import java . util . concurrent . CountDownLatch ; <nl> - @Timeout(70) <nl> + @Timeout(30) <nl> - final CountDownLatch latch = new CountDownLatch(1) ; <nl> - final Thread messageThread = startMessageThread(cluster, MICROSECONDS . toNanos(500), latch) ; <nl> + final Thread messageThread = startMessageThread(cluster, MICROSECONDS . toNanos(500)) ; <nl> - latch . await() ; // wait for at thread to start .  <nl> + Tests . sleep(3000) ; // keep ingress going so started node has to catchup .  <nl> + while (leader . commitPosition() > followerB . commitPosition()) <nl> + { <nl> + Tests . sleep(10) ; <nl> + } <nl> mmm ClusterTests . java <nl> ppp ClusterTests . java <nl> - import java . util . concurrent . CountDownLatch ; <nl> - public static Thread startMessageThread( <nl> - final TestCluster cluster, final long backoffIntervalNs, final CountDownLatch latch) <nl> + public static Thread startMessageThread(final TestCluster cluster, final long backoffIntervalNs) <nl> - latch . countDown() ; <nl>",
        "commit_message": "[ java ] run at rate for a bit so follower have to catch up during recovery .",
        "what": "run at rate for a bit so follower have to catch up during recovery",
        "why": "(implicit, inferred purpose of allowing follower to catch up)",
        "check": "0"
    },
    {
        "commit_time": "2014-04-22 16:11:40-07:00",
        "diff": "mmm LauncherProvider . java <nl> ppp LauncherProvider . java <nl> - private static final int DATABASE_VERSION = 18 ; <nl> + private static final int DATABASE_VERSION = 19 ; <nl> - db . execSQL(DELETE FROM  + TABLE_FAVORITES +  WHERE  + <nl> + String removeOrphanedDesktopItems = DELETE FROM  TABLE_FAVORITES + <nl> +  WHERE  + <nl> - LauncherSettings . WorkspaceScreens . _ID +  FROM  + TABLE_WORKSPACE_SCREENS + <nl> - )) ; <nl> + LauncherSettings . WorkspaceScreens . _ID  FROM  TABLE_WORKSPACE_SCREENS ) + <nl> +  AND  + <nl> + LauncherSettings . Favorites . CONTAINER  =  + <nl> + LauncherSettings . Favorites . CONTAINER_DESKTOP ; <nl> + db . execSQL(removeOrphanedDesktopItems) ; <nl> + String removeOrphanedFolderItems = DELETE FROM  TABLE_FAVORITES + <nl> +  WHERE  + <nl> + LauncherSettings . Favorites . CONTAINER  <>  + <nl> + LauncherSettings . Favorites . CONTAINER_DESKTOP + <nl> +  AND  <nl> + LauncherSettings . Favorites . CONTAINER  <>  + <nl> + LauncherSettings . Favorites . CONTAINER_HOTSEAT + <nl> +  AND  <nl> + LauncherSettings . Favorites . CONTAINER  NOT IN (SELECT  + <nl> + LauncherSettings . Favorites . _ID  FROM  TABLE_FAVORITES + <nl> +  WHERE  LauncherSettings . Favorites . ITEM_TYPE  =  + <nl> + LauncherSettings . Favorites . ITEM_TYPE_FOLDER ) ; <nl> + db . execSQL(removeOrphanedFolderItems) ; <nl> + version = 18 ; <nl> + } <nl> + if (version < 19) { <nl> - version = 18 ; <nl> + removeOrphanedItems(db) ; <nl> + version = 19 ; <nl>",
        "commit_message": "updated the database version from 18 to 19 and refined SQL deletion queries for orphaned items to ensure data integrity and remove obsolete entries from the favorites table",
        "what": "updated the database version from 18 to 19 and refined SQL deletion queries for orphaned items",
        "why": "ensure data integrity and remove obsolete entries from the favorites table",
        "check": "1"
    },
    {
        "commit_time": "2020-12-30 13:16:41-06:00",
        "diff": "mmm MD5Digest . java <nl> ppp MD5Digest . java <nl> + private static final byte[] HEX_BYTES = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'} ; <nl> - MessageDigest md ; <nl> - byte[] tempDigest ; <nl> - byte[] passDigest ; <nl> - byte[] hexDigest = new byte[35] ; <nl> - md = MessageDigest . getInstance(MD5) ; <nl> + final MessageDigest md = MessageDigest . getInstance(MD5) ; <nl> - tempDigest = md . digest() ; <nl> + byte[] digest = md . digest() ; <nl> + final byte[] hexDigest = new byte[35] ; <nl> - bytesToHex(tempDigest, hexDigest, 0) ; <nl> + bytesToHex(digest, hexDigest, 0) ; <nl> - passDigest = md . digest() ; <nl> + digest = md . digest() ; <nl> - bytesToHex(passDigest, hexDigest, 3) ; <nl> + bytesToHex(digest, hexDigest, 3) ; <nl> + return hexDigest ; <nl> - return hexDigest ; <nl> - final char[] lookup = <nl> - {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'} ; <nl> - int i ; <nl> - int c ; <nl> - int j ; <nl> - for (i = 0 ; i < 16 ; i++) { <nl> - c = bytes[i] & 0xFF ; <nl> - j = c >> 4 ; <nl> - hex[pos++] = (byte) lookup[j] ; <nl> - j = (c & 0xF) ; <nl> - hex[pos++] = (byte) lookup[j] ; <nl> + for (int i = 0 ; i < 16 ; i++) { <nl> + final int c = bytes[i] & 0xFF ; <nl> + hex[pos++] = HEX_BYTES[c >> 4] ; <nl> + hex[pos++] = HEX_BYTES[c & 0xF] ; <nl>",
        "commit_message": "refactor MD5Digest to use a static final byte array for hex values and make the MessageDigest variable final to improve code clarity and efficiency by reducing variable scope and enhancing readability",
        "what": "refactor MD5Digest to use a static final byte array for hex values and make the MessageDigest variable final",
        "why": "improve code clarity and efficiency by reducing variable scope and enhancing readability",
        "check": "1"
    },
    {
        "commit_time": "2015-08-28 01:22:45-07:00",
        "diff": "mmm DynamicPartitionPruningOptimization . java <nl> ppp DynamicPartitionPruningOptimization . java <nl> + if (ts == null) { <nl> + LOG . warn(Could not find the table scan for  filter) ;  <nl> + return null ; <nl> + } else { <nl> + Table table = ts . getConf() . getTableMetadata() ; <nl> + if (table != null && !table . isPartitioned()) { <nl> + return null ; <nl> + } <nl> + } <nl>",
        "commit_message": "added null check for table scan in DynamicPartitionPruningOptimization.java to avoid potential null pointer exceptions when table scan is not found",
        "what": "added null check for table scan in DynamicPartitionPruningOptimization.java",
        "why": "avoid potential null pointer exceptions when table scan is not found",
        "check": "1"
    },
    {
        "commit_time": "2018-01-26 11:22:32+01:00",
        "diff": "mmm OpenBSDBCryptTest . java <nl> ppp OpenBSDBCryptTest . java <nl> - $2a$10$ . TtQJ4Jr6isd4Hp . mVfZeuh6Gws4rOQ/vdBczhDx . 19NFK0Y84Dle,  <nl> + $2a$10$ . TtQJ4Jr6isd4Hp . mVfZeuh6Gws4rOQ/vdBczhDx . 19NFK0Y84Dle, \\u03c0\\u03c0\\u03c0\\u03c0\\u03c0\\u03c0\\u03c0\\u03c0 <nl>",
        "commit_message": "encode  a \\u03c0 prevent problem on other locale",
        "what": "encode  a \\u03c0",
        "why": "prevent problem on other locale",
        "check": "1"
    },
    {
        "commit_time": "2020-09-25 18:15:32-07:00",
        "diff": "mmm NinePatch . java <nl> ppp NinePatch . java <nl> + -\t\t\tbottomCenter = add(patches[BOTTOM_CENTER], true, false) ;\r <nl> + bottomCenter = add(patches[BOTTOM_CENTER], patches[BOTTOM_LEFT] != null || patches[BOTTOM_RIGHT] != null, false) ;\r <nl> - middleLeft = add(patches[MIDDLE_LEFT], false, true) ;\r <nl> + middleLeft = add(patches[MIDDLE_LEFT], false, patches[TOP_LEFT] != null || patches[BOTTOM_LEFT] != null) ;\r <nl> - middleCenter = add(patches[MIDDLE_CENTER], true, true) ;\r <nl> + middleCenter = add(patches[MIDDLE_CENTER], patches[MIDDLE_LEFT] != null || patches[MIDDLE_RIGHT] != null,\r <nl> + patches[TOP_CENTER] != null || patches[BOTTOM_CENTER] != null) ;\r <nl> - middleRight = add(patches[MIDDLE_RIGHT], false, true) ;\r <nl> + middleRight = add(patches[MIDDLE_RIGHT], false, patches[TOP_RIGHT] != null || patches[BOTTOM_RIGHT] != null) ;\r <nl> - topCenter = add(patches[TOP_CENTER], true, false) ;\r <nl> + topCenter = add(patches[TOP_CENTER], patches[TOP_LEFT] != null || patches[TOP_RIGHT] != null, false) ; <nl>",
        "commit_message": "ninepatch , fix blurry render when use a single center region .",
        "what": "fix blurry render when use a single center region",
        "why": "improve visual quality when displaying ninepatch images",
        "check": "1"
    },
    {
        "commit_time": "2009-02-26 17:32:37+00:00",
        "diff": "new file <nl> ppp KahaDBQueueTest . java <nl> + package org . apache . activemq . perf ; <nl> + import java . io . File ; <nl> + import org . apache . activemq . broker . BrokerService ; <nl> + import org . apache . activemq . store . kahadb . KahaDBStore ; <nl> + public class KahaDBQueueTest extends SimpleQueueTest { <nl> + protected void configureBroker(BrokerService answer,String uri) throws Exception { <nl> + File dataFileDir = new File(target/test-amq-data/perfTest/kahadb) ; <nl> + KahaDBStore kaha = new KahaDBStore() ; <nl> + kaha . setDirectory(dataFileDir) ; <nl> + kaha . setEnableJournalDiskSyncs(false) ; <nl> + kaha . setJournalMaxFileLength(1024*100) ; <nl> + kaha . setIndexWriteBatchSize(100) ; <nl> + kaha . setEnableIndexWriteAsync(true) ; <nl> + answer . setPersistenceAdapter(kaha) ; <nl> + answer . addConnector(uri) ; <nl> + answer . setDeleteAllMessagesOnStartup(true) ; <nl> + } <nl> + } <nl> mmm DataFileAppender . java <nl> ppp DataFileAppender . java <nl> + if (!sync) { <nl> + inflightWrites . put(new WriteKey(location), write) ; <nl> + } <nl> - } else { <nl> - inflightWrites . put(new WriteKey(location), write) ; <nl>",
        "commit_message": "resolve mem leak in kahadb - amq-2143",
        "what": "resolve mem leak in kahadb",
        "why": "amq-2143",
        "check": "0"
    },
    {
        "commit_time": "2011-02-13 11:23:51+00:00",
        "diff": "mmm Sprite . java <nl> ppp Sprite . java <nl> + public void draw(SpriteBatch spriteBatch, float alphaModulation) {\r <nl> + Color color = getColor() ;\r <nl> + float oldAlpha = color . a ;\r <nl> + color . a *= alphaModulation ;\r <nl> + setColor(color) ;\r <nl> + draw(spriteBatch) ;\r <nl> + color . a = oldAlpha ;\r <nl> + setColor(color) ;\r <nl> + } <nl>",
        "commit_message": "[ add ] sprite.draw ( spritebatch batch , float alphamodulation ) . useful in actor to apply the parent 's alpha .",
        "what": "add sprite.draw (spritebatch batch, float alphamodulation)",
        "why": "useful in actor to apply the parent's alpha",
        "check": "1"
    },
    {
        "commit_time": "2018-11-05 11:23:00-05:00",
        "diff": "mmm ModularityHelper . java <nl> ppp ModularityHelper . java <nl> - public static void iterateModules(PrintStream out, ModuleIteratorFilter filter, ModuleOutput outputter, String filterArg) throws CorruptDataException { <nl> + public static int iterateModules(PrintStream out, ModuleIteratorFilter filter, ModuleOutput outputter, String filterArg) throws CorruptDataException { <nl> + int count = 0 ; <nl> + count++ ; <nl> + return count ; <nl> - public static void iteratePackages(PrintStream out, PackageIteratorFilter filter, PackageOutput outputter, String filterArg) throws CorruptDataException { <nl> + public static int iteratePackages(PrintStream out, PackageIteratorFilter filter, PackageOutput outputter, String filterArg) throws CorruptDataException { <nl> + int count = 0 ; <nl> + count++ ; <nl> + return count ; <nl> mmm FindModulesCommand . java <nl> ppp FindModulesCommand . java <nl> + int result ; <nl> - ModularityHelper . iterateModules(out, moduleFilter, moduleOutput, filterArg) ; <nl> + result = ModularityHelper . iterateModules(out, moduleFilter, moduleOutput, filterArg) ; <nl> + out . printf(Found %d module%s\\n, result, (1 == result ? : s)) ; <nl> - ModularityHelper . PackageOutput packageOutput = ModularityHelper::printPackageJ9Module ;  <nl> - ModularityHelper . iteratePackages(out, packageFilter, packageOutput, filterArg) ; <nl> + ModularityHelper . PackageOutput packageOutput = ModularityHelper::printPackageJ9Module ; <nl> + result = ModularityHelper . iteratePackages(out, packageFilter, packageOutput, filterArg) ; <nl> + out . printf(Found %d module%s\\n, result, (1 == result ? : s)) ; <nl>",
        "commit_message": "modified iterateModules and iteratePackages methods to return the count of iterations instead of void to provide feedback on the number of modules and packages processed",
        "what": "modified iterateModules and iteratePackages methods to return the count of iterations instead of void",
        "why": "provide feedback on the number of modules and packages processed",
        "check": "1"
    },
    {
        "commit_time": "2014-08-06 12:26:59+02:00",
        "diff": "mmm ItBitTradeServiceRaw . java <nl> ppp ItBitTradeServiceRaw . java <nl> + public ItBitOrder[] getItBitOrders(String status) throws IOException { <nl> + ItBitOrder[] orders = itBit . getOrders(signatureCreator, new Date() . getTime(), valueFactory, XBTUSD, 1, 1000, status, walletId) ; <nl> + return orders ; <nl> + } <nl>",
        "commit_message": "added a method getItBitOrders to retrieve orders based on their status to enhance functionality by allowing users to filter orders according to specified statuses",
        "what": "added a method getItBitOrders to retrieve orders based on their status",
        "why": "enhance functionality by allowing users to filter orders according to specified statuses",
        "check": "1"
    },
    {
        "commit_time": "2015-11-01 10:38:08-08:00",
        "diff": "mmm TarGzCompressionUtils . java <nl> ppp TarGzCompressionUtils . java <nl> + import java . io . BufferedInputStream ; <nl> - is = new GzipCompressorInputStream(new FileInputStream(inputFile)) ; <nl> + is = new GzipCompressorInputStream(new BufferedInputStream(new FileInputStream(inputFile))) ; <nl>",
        "commit_message": "updated GzipCompressorInputStream initialization to use BufferedInputStream to improve performance by reducing the number of I/O operations",
        "what": "updated GzipCompressorInputStream initialization to use BufferedInputStream",
        "why": "improve performance by reducing the number of I/O operations",
        "check": "1"
    },
    {
        "commit_time": "2023-05-19 01:35:46+00:00",
        "diff": "mmm TaskbarDragLayerController . java <nl> ppp TaskbarDragLayerController . java <nl> - mTaskbarDragLayer . getHeight() mActivity . getDeviceProfile() . taskbarHeight) ; <nl> + mTaskbarDragLayer . getHeight() - mActivity . getDeviceProfile() . taskbarHeight <nl> + - mActivity . getDeviceProfile() . taskbarBottomMargin) ; <nl> mmm TaplTestsQuickstep . java <nl> ppp TaplTestsQuickstep . java <nl> + import static com . android . quickstep . TaskbarModeSwitchRule . Mode . PERSISTENT ; <nl> + import com . android . quickstep . TaskbarModeSwitchRule . TaskbarModeSwitch ; <nl> - @Ignore <nl> + @TaskbarModeSwitch(mode = PERSISTENT) <nl>",
        "commit_message": "modified height calculation and taskbar mode switch annotations in TaskbarDragLayerController and TaplTestsQuickstep classes to correct the height adjustment logic and enable persistent taskbar mode handling",
        "what": "modified height calculation and taskbar mode switch annotations in TaskbarDragLayerController and TaplTestsQuickstep classes",
        "why": "correct the height adjustment logic and enable persistent taskbar mode handling",
        "check": "1"
    },
    {
        "commit_time": "2020-01-14 11:00:16-05:00",
        "diff": "mmm NettyMutableHttpResponse . java <nl> ppp NettyMutableHttpResponse . java <nl> - if (cookies . size() > 1) { <nl> - Set<String> values = new HashSet<>(cookies . size()) ; <nl> - for (Cookie cookie: cookies) { <nl> - if (cookie instanceof NettyCookie) { <nl> - NettyCookie nettyCookie = (NettyCookie) cookie ; <nl> - String value = ClientCookieEncoder . LAX . encode(nettyCookie . getNettyCookie()) ; <nl> - values . add(value) ; <nl> - } else { <nl> - throw new IllegalArgumentException(Argument is not a Netty compatible Cookie) ; <nl> - } <nl> - } <nl> - headers . add(HttpHeaderNames . COOKIE, String . join( ;, values)) ; <nl> - } else if (!cookies . isEmpty()) { <nl> - cookie(cookies . iterator() . next()) ; <nl> + if (cookies == null || cookies . isEmpty()) { <nl> + return this ; <nl> + } <nl> + for (Cookie cookie: cookies) { <nl> + cookie(cookie) ; <nl>",
        "commit_message": "change cooky to set multiple cookie header . fix # 2636",
        "what": "change cooky to set multiple cookie header",
        "why": "fix # 2636",
        "check": "1"
    },
    {
        "commit_time": "2006-04-20 03:42:56+00:00",
        "diff": "mmm GroupElement . java <nl> ppp GroupElement . java <nl> - if ( child instanceof GroupElement && ( child instanceof And || child instanceof Or ) ) {\r <nl> - GroupElement group = ( GroupElement )  child ;\r <nl> - if (  group . getChildren() . size() == 1 ) {\r <nl> - child = group . getChildren() . get( 0 ) ;\r <nl> - }            \r <nl> - }\r <nl> - if ( child instanceof GroupElement && ( child instanceof And || child instanceof Or ) ) {\r <nl> - GroupElement group = ( GroupElement )  child ;\r <nl> - if ( group . getClass() == this . getClass() ) {\r <nl> - GroupElement newGroup = null ;\r <nl> - if ( group instanceof And) {\r <nl> - newGroup = new And() ;\r <nl> - } else {\r <nl> - newGroup =  new Or() ;\r <nl> - }\r <nl> - for ( Iterator it = group . getChildren() . iterator() ; it . hasNext() ; ) {\r <nl> - this . children . add( it . next() ) ;\r <nl> - }\r <nl> - } else {\r <nl> - this . children . add( child ) ;\r <nl> - }\r <nl> - }   else {        \r <nl> - this . children . add( child ) ;\r <nl> - }\r <nl> + this . children . add( child ) ; <nl>",
        "commit_message": "-comment out some transformation code , make it work in 3.1",
        "what": "comment out some transformation code",
        "why": "make it work in 3.1",
        "check": "1"
    },
    {
        "commit_time": "2011-10-17 18:31:36-07:00",
        "diff": "mmm Robolectric . java <nl> ppp Robolectric . java <nl> + ShadowHandlerThread . class, <nl> + public static ShadowHandlerThread shadowOf(HandlerThread instance) { <nl> + return (ShadowHandlerThread) shadowOf_(instance) ; <nl> + } <nl> new file <nl> ppp ShadowHandlerThread . java <nl> + package com . xtremelabs . robolectric . shadows ; <nl> + import android . os . HandlerThread ; <nl> + import android . os . Looper ; <nl> + import com . xtremelabs . robolectric . internal . Implementation ; <nl> + import com . xtremelabs . robolectric . internal . Implements ; <nl> + @Implements(HandlerThread . class) <nl> + public class ShadowHandlerThread { <nl> + private String name ; <nl> + private Looper looper ; <nl> + public void __constructor__(String name) { <nl> + __constructor__(name, -1) ; <nl> + } <nl> + public void __constructor__(String name, int priority) { <nl> + this . name = name ; <nl> + looper = Looper . getMainLooper() ; <nl> + } <nl> + @Implementation <nl> + public void run() { <nl> + Looper . prepare() ; <nl> + synchronized (this) { <nl> + looper = Looper . myLooper() ; <nl> + notifyAll() ; <nl> + } <nl> + Looper . loop() ; <nl> + } <nl> + @Implementation <nl> + public Looper getLooper() { <nl> + synchronized (this) { <nl> + while (looper == null) { <nl> + try { <nl> + wait() ; <nl> + } catch (InterruptedException e) { <nl> + } <nl> + } <nl> + } <nl> + return looper ; <nl> + } <nl> + } <nl> new file <nl> ppp ShadowHandlerThreadTest . java <nl> + package com . xtremelabs . robolectric . shadows ; <nl> + import android . os . HandlerThread ; <nl> + import com . xtremelabs . robolectric . WithTestDefaultsRunner ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + import static org . hamcrest . CoreMatchers . notNullValue ; <nl> + import static org . junit . Assert . assertThat ; <nl> + @RunWith(WithTestDefaultsRunner . class) <nl> + public class ShadowHandlerThreadTest { <nl> + @Test <nl> + public void getLooper_returnsLooper() { <nl> + HandlerThread handlerThread = new HandlerThread(test) ; <nl> + handlerThread . start() ; <nl> + assertThat(handlerThread . getLooper(), notNullValue()) ; <nl> + } <nl> + } <nl>",
        "commit_message": "added ShadowHandlerThread class with methods to manage a HandlerThread's looper to enable testing and simulation of HandlerThread behavior in Robolectric",
        "what": "added ShadowHandlerThread class with methods to manage a HandlerThread's looper",
        "why": "enable testing and simulation of HandlerThread behavior in Robolectric",
        "check": "1"
    },
    {
        "commit_time": "2017-11-20 10:55:35-08:00",
        "diff": "mmm AnomaliesResource . java <nl> ppp AnomaliesResource . java <nl> + import com . fasterxml . jackson . core . type . TypeReference ; <nl> + import com . linkedin . thirdeye . constant . AnomalyResultSource ; <nl> + import com . linkedin . thirdeye . datalayer . dto . RawAnomalyResultDTO ; <nl> + @POST <nl> + @Path(value = /reportAnomaly/{anomalyFunctionId}) <nl> + public void createUserAnomaly(@PathParam(anomalyFunctionId) long anomalyFunctionId, <nl> + @QueryParam(startTime) Long startTime, <nl> + @QueryParam(endTime) Long endTime, <nl> + @QueryParam(feedbackType) AnomalyFeedbackType feedbackType, <nl> + @QueryParam(comment) String comment, <nl> + @QueryParam(dimensionsJson) String dimensionsJson) { <nl> + AnomalyFunctionDTO anomalyFunction = anomalyFunctionDAO . findById(anomalyFunctionId) ; <nl> + if (anomalyFunction == null) { <nl> + throw new IllegalArgumentException(String . format(Could not resolve anomaly function id %d, anomalyFunctionId)) ; <nl> + } <nl> + if (startTime == null) { <nl> + throw new IllegalArgumentException(Must provide startTime) ; <nl> + } <nl> + if (endTime == null) { <nl> + throw new IllegalArgumentException(Must provide endTime) ; <nl> + } <nl> + if (feedbackType == null) { <nl> + throw new IllegalArgumentException(Must provide feedbackType) ; <nl> + } <nl> + MergedAnomalyResultDTO anomaly = new MergedAnomalyResultDTO() ; <nl> + anomaly . setFunction(anomalyFunction) ; <nl> + anomaly . setStartTime(startTime) ; <nl> + anomaly . setEndTime(endTime) ; <nl> + anomaly . setDimensions(new DimensionMap(dimensionsJson != null ? dimensionsJson : {})) ; <nl> + anomaly . setAnomalyResultSource(AnomalyResultSource . USER_LABELED_ANOMALY) ; <nl> + anomaly . setMetric(anomalyFunction . getTopicMetric()) ; <nl> + anomaly . setCollection(anomalyFunction . getCollection()) ; <nl> + anomaly . setProperties(Collections . <String, String>emptyMap()) ; <nl> + anomaly . setAnomalyResults(Collections . <RawAnomalyResultDTO>emptyList()) ; <nl> + if (mergedAnomalyResultDAO . save(anomaly) == null) { <nl> + throw new IllegalArgumentException(String . format(Could not store user reported anomaly: '%s', anomaly)) ; <nl> + } <nl> + AnomalyFeedbackDTO feedback = new AnomalyFeedbackDTO() ; <nl> + feedback . setFeedbackType(feedbackType) ; <nl> + feedback . setComment(comment) ; <nl> + anomaly . setFeedback(feedback) ; <nl> + mergedAnomalyResultDAO . updateAnomalyFeedback(anomaly) ; <nl> + } <nl>",
        "commit_message": "added a new endpoint to report user anomalies in AnomaliesResource.java to enable users to submit feedback on anomalies for better tracking and analysis",
        "what": "added a new endpoint to report user anomalies in AnomaliesResource.java",
        "why": "enable users to submit feedback on anomalies for better tracking and analysis",
        "check": "1"
    },
    {
        "commit_time": "2021-10-13 15:15:24+08:00",
        "diff": "mmm LogFilterWrapper . java <nl> ppp LogFilterWrapper . java <nl> - Block block = wallet . getBlockById(ByteString . copyFrom(ByteArray . fromHexString(blockHash))) ; <nl> + Block block = null ; <nl> + if (wallet != null) { <nl> + block = wallet . getBlockById(ByteString . copyFrom(ByteArray . fromHexString(blockHash))) ; <nl> + } <nl> + if (toBlock == -1) { <nl> + toBlock = Long . MAX_VALUE ; <nl> + } <nl>",
        "commit_message": "changed block initialization logic to handle null wallet and set toBlock to MAX_VALUE when it is -1 to improve robustness by preventing potential null pointer exceptions and ensuring toBlock has a valid default value",
        "what": "changed block initialization logic to handle null wallet and set toBlock to MAX_VALUE when it is -1",
        "why": "improve robustness by preventing potential null pointer exceptions and ensuring toBlock has a valid default value",
        "check": "1"
    },
    {
        "commit_time": "2014-09-17 15:02:42+05:30",
        "diff": "mmm NashornBeansLinker . java <nl> ppp NashornBeansLinker . java <nl> + if (sourceType == ConsString . class) { <nl> + if (String . class == targetType1 || CharSequence . class == targetType1) { <nl> + return Comparison . TYPE_1_BETTER ; <nl> + } <nl> + if (String . class == targetType2 || CharSequence . class == targetType2) { <nl> + return Comparison . TYPE_2_BETTER ; <nl> + } <nl> + } <nl>",
        "commit_message": "added checks for sourceType and targetType in NashornBeansLinker.java to improve comparison logic for handling ConsString types",
        "what": "added checks for sourceType and targetType in NashornBeansLinker.java",
        "why": "improve comparison logic for handling ConsString types",
        "check": "1"
    },
    {
        "commit_time": "2015-08-18 22:26:44+12:00",
        "diff": "deleted file <nl> mmm Oracle9Platform . java <nl> - package com . avaje . ebean . config . dbplatform ; <nl> - public class Oracle9Platform extends Oracle10Platform { <nl> - public Oracle9Platform() { <nl> - super() ; <nl> - } <nl> - } <nl> mmm Oracle10DbEncrypt . java <nl> ppp Oracle10DbEncrypt . java <nl> - public class Oracle10DbEncrypt extends AbstractDbEncrypt { <nl> + public class OracleDbEncrypt extends AbstractDbEncrypt { <nl> - public Oracle10DbEncrypt() { <nl> + public OracleDbEncrypt() { <nl> - public Oracle10DbEncrypt(String encryptFunction, String decryptFunction) { <nl> + public OracleDbEncrypt(String encryptFunction, String decryptFunction) { <nl> mmm Oracle10Platform . java <nl> ppp Oracle10Platform . java <nl> - public class Oracle10Platform extends DatabasePlatform { <nl> + public class OraclePlatform extends DatabasePlatform { <nl> - public Oracle10Platform() { <nl> + public OraclePlatform() { <nl> - this . dbEncrypt = new Oracle10DbEncrypt() ; <nl> + this . dbEncrypt = new OracleDbEncrypt() ; <nl> mmm DbMigration . java <nl> ppp DbMigration . java <nl> - import com . avaje . ebean . config . dbplatform . Oracle10Platform ; <nl> + import com . avaje . ebean . config . dbplatform . OraclePlatform ; <nl> - return new Oracle10Platform() ; <nl> + return new OraclePlatform() ; <nl> mmm DatabasePlatformFactory . java <nl> ppp DatabasePlatformFactory . java <nl> - if (dbName . equals(oracle9)) { <nl> - return new Oracle9Platform() ; <nl> - } <nl> - if (dbName . equals(oracle) || dbName . equals(oracle10)) { <nl> - return new Oracle10Platform() ; <nl> + if (dbName . equals(oracle) || dbName . equals(oracle10) || dbName . equals(oracle9)) { <nl> + return new OraclePlatform() ; <nl> - if (majorVersion > 9) { <nl> - return new Oracle10Platform() ; <nl> - } else { <nl> - return new Oracle9Platform() ; <nl> - } <nl> + return new OraclePlatform() ; <nl> mmm OraclePlatformTest . java <nl> ppp OraclePlatformTest . java <nl> - Oracle10Platform platform = new Oracle10Platform() ; <nl> + OraclePlatform platform = new OraclePlatform() ; <nl> mmm PlatformDdl_AlterColumnTest . java <nl> ppp PlatformDdl_AlterColumnTest . java <nl> - import com . avaje . ebean . config . dbplatform . Oracle10Platform ; <nl> + import com . avaje . ebean . config . dbplatform . OraclePlatform ; <nl> - PlatformDdl oraDdl = new Oracle10Platform() . getPlatformDdl() ; <nl> + PlatformDdl oraDdl = new OraclePlatform() . getPlatformDdl() ; <nl> mmm PlatformDdl_dropUniqueConstraintTest . java <nl> ppp PlatformDdl_dropUniqueConstraintTest . java <nl> - import com . avaje . ebean . config . dbplatform . Oracle10Platform ; <nl> + import com . avaje . ebean . config . dbplatform . OraclePlatform ; <nl> - PlatformDdl oraDdl = new Oracle10Platform() . getPlatformDdl() ; <nl> + PlatformDdl oraDdl = new OraclePlatform() . getPlatformDdl() ; <nl>",
        "commit_message": "# 383 - refactor - rename oracle10platform to oracleplatform , remove oracle9platform ( a not different )",
        "what": "rename oracle10platform to oracleplatform, remove oracle9platform",
        "why": "refactor the code for better clarity and maintainability",
        "check": "1"
    },
    {
        "commit_time": "2013-04-10 16:06:08+00:00",
        "diff": "mmm NetworkUtils . java <nl> ppp NetworkUtils . java <nl> - = Integer . parseInt(array1[4]) Integer . parseInt(array2[4]) ; <nl> + = Integer . parseInt(array1[3]) - Integer . parseInt(array2[3]) ; <nl>",
        "commit_message": "fix naptr sort by preference ( report by juha heinanen on dev )",
        "what": "fix naptr sort by preference",
        "why": "report by juha heinanen on dev",
        "check": "1"
    },
    {
        "commit_time": "2020-03-04 12:52:02-08:00",
        "diff": "mmm BaseSwipeUpHandler . java <nl> ppp BaseSwipeUpHandler . java <nl> - RectFSpringAnim anim = new RectFSpringAnim(startRect, targetRect, mContext . getResources()) ; <nl> + RectFSpringAnim anim = new RectFSpringAnim(startRect, targetRect, mContext) ; <nl> mmm RectFSpringAnim . java <nl> ppp RectFSpringAnim . java <nl> - import android . content . res . Resources ; <nl> - public RectFSpringAnim(RectF startRect, RectF targetRect, Resources resources) { <nl> + public RectFSpringAnim(RectF startRect, RectF targetRect, Context context) { <nl> - mMinVisChange = resources . getDimensionPixelSize(R . dimen . swipe_up_fling_min_visible_change) ; <nl> - mYOvershoot = resources . getDimensionPixelSize(R . dimen . swipe_up_y_overshoot) ; <nl> + ResourceProvider rp = DynamicResource . provider(context) ; <nl> + mMinVisChange = rp . getDimension(R . dimen . swipe_up_fling_min_visible_change) ; <nl> + mYOvershoot = rp . getDimension(R . dimen . swipe_up_y_overshoot) ; <nl> - mRectXAnim = new FlingSpringAnim(this, RECT_CENTER_X, startX, endX, <nl> + mRectXAnim = new FlingSpringAnim(this, context, RECT_CENTER_X, startX, endX, <nl> - mRectYAnim = new FlingSpringAnim(this, RECT_Y, startY, endY, startVelocityY, <nl> + mRectYAnim = new FlingSpringAnim(this, context, RECT_Y, startY, endY, startVelocityY, <nl> - float damping = rp . getFloat(R . dimen . swipe_up_rect_damping_ratio) ; <nl> - float stiffness = rp . getFloat(R . dimen . swipe_up_rect_stiffness) ; <nl> + float damping = rp . getFloat(R . dimen . swipe_up_rect_scale_damping_ratio) ; <nl> + float stiffness = rp . getFloat(R . dimen . swipe_up_rect_scale_stiffness) ; <nl> mmm FlingSpringAnim . java <nl> ppp FlingSpringAnim . java <nl> + import android . content . Context ; <nl> + import com . android . launcher3 . R ; <nl> + import com . android . launcher3 . util . DynamicResource ; <nl> + import com . android . systemui . plugins . ResourceProvider ; <nl> - private static final float FLING_FRICTION = 1 . 5f ; <nl> - private static final float SPRING_STIFFNESS = 200 ; <nl> - private static final float SPRING_DAMPING = 0 . 8f ; <nl> - public <K> FlingSpringAnim(K object, FloatPropertyCompat<K> property, float startPosition, <nl> - float targetPosition, float startVelocity, float minVisChange, float minValue, <nl> - float maxValue, float springVelocityFactor, OnAnimationEndListener onEndListener) { <nl> + public <K> FlingSpringAnim(K object, Context context, FloatPropertyCompat<K> property, <nl> + float startPosition, float targetPosition, float startVelocity, float minVisChange, <nl> + float minValue, float maxValue, float springVelocityFactor, <nl> + OnAnimationEndListener onEndListener) { <nl> + ResourceProvider rp = DynamicResource . provider(context) ; <nl> + float damping = rp . getFloat(R . dimen . swipe_up_rect_xy_damping_ratio) ; <nl> + float stiffness = rp . getFloat(R . dimen . swipe_up_rect_xy_stiffness) ; <nl> + float friction = rp . getFloat(R . dimen . swipe_up_rect_xy_fling_friction) ; <nl> -  . setFriction(FLING_FRICTION) <nl> +  . setFriction(friction) <nl> -  . setStiffness(SPRING_STIFFNESS) <nl> -  . setDampingRatio(SPRING_DAMPING)) ; <nl> +  . setStiffness(stiffness) <nl> +  . setDampingRatio(damping)) ; <nl>",
        "commit_message": "modified RectFSpringAnim and FlingSpringAnim constructors to accept Context instead of Resources to enhance resource management by utilizing DynamicResource for better flexibility",
        "what": "modified RectFSpringAnim and FlingSpringAnim constructors to accept Context instead of Resources",
        "why": "enhance resource management by utilizing DynamicResource for better flexibility",
        "check": "1"
    },
    {
        "commit_time": "2016-03-24 23:44:44+01:00",
        "diff": "mmm TestUtils . java <nl> ppp TestUtils . java <nl> + import javax . net . ServerSocketFactory ; <nl> - try (ServerSocket socket = new ServerSocket(0)) { <nl> + try (ServerSocket socket = ServerSocketFactory . getDefault() . createServerSocket(0)) { <nl>",
        "commit_message": "try to improve findfreeport because intellij steal some port and break test",
        "what": "try to improve findfreeport",
        "why": "because intellij steal some port and break test",
        "check": "1"
    },
    {
        "commit_time": "2012-06-21 21:58:29+02:00",
        "diff": "mmm BlockChannelAccess . java <nl> ppp BlockChannelAccess . java <nl> + import java . nio . ByteBuffer ; <nl> - this . channel . fileChannel . read(this . segment . wrap(0, this . segment . size())) ; <nl> + try { <nl> + final ByteBuffer wrapper = this . segment . wrap(0, this . segment . size()) ; <nl> + this . channel . fileChannel . read(wrapper) ; <nl> + } catch (NullPointerException npex) { <nl> + } <nl> - this . channel . fileChannel . write(this . segment . wrap(0, this . segment . size())) ; <nl> + try { <nl> + this . channel . fileChannel . write(this . segment . wrap(0, this . segment . size())) ; <nl> + } catch (NullPointerException npex) { <nl> + } <nl>",
        "commit_message": "correct handling of nullpointerexception in i/o request when memory have be asynchronously release by cancel or fail the task .",
        "what": "correct handling of nullpointerexception in i/o request",
        "why": "when memory have be asynchronously released by cancel or fail the task",
        "check": "1"
    },
    {
        "commit_time": "2012-08-30 23:29:00+00:00",
        "diff": "mmm ValueSourceParser . java <nl> ppp ValueSourceParser . java <nl> + addParser(mod, new ValueSourceParser() { <nl> + @Override <nl> + public ValueSource parse(FunctionQParser fp) throws ParseException { <nl> + ValueSource a = fp . parseValueSource() ; <nl> + ValueSource b = fp . parseValueSource() ; <nl> + return new DualFloatFunction(a, b) { <nl> + @Override <nl> + protected String name() { <nl> + return mod ; <nl> + } <nl> + @Override <nl> + protected float func(int doc, FunctionValues aVals, FunctionValues bVals) { <nl> + return aVals . floatVal(doc) % bVals . floatVal(doc) ; <nl> + } <nl> + } ; <nl> + } <nl> + }) ; <nl> mmm QueryEqualityTest . java <nl> ppp QueryEqualityTest . java <nl> + public void testFuncMod() throws Exception { <nl> + assertFuncEquals(mod(5,4), mod(5, 4)) ; <nl> + assertFuncEquals(mod(foo_i,4), mod(foo_i, 4),  <nl> + mod(field('foo_i'), 4)) ; <nl> + assertFuncEquals(mod(foo_i,sub(4,field('bar_i'))),  <nl> + mod(field(foo_i), sub(4,bar_i))) ; <nl> + } <nl>",
        "commit_message": "added a new mod parser to the ValueSourceParser and corresponding unit tests for its functionality to support modulo operations in query parsing and ensure correctness through validation",
        "what": "added a new mod parser to the ValueSourceParser and corresponding unit tests for its functionality",
        "why": "support modulo operations in query parsing and ensure correctness through validation",
        "check": "1"
    },
    {
        "commit_time": "2015-07-16 12:45:50+02:00",
        "diff": "mmm Importer . java <nl> ppp Importer . java <nl> - if (!direct && targetStore instanceof CoverageStoreInfo <nl> - && catalog . getCoveragesByStore((CoverageStoreInfo) targetStore) . isEmpty()) { <nl> + if (!direct && targetStore instanceof CoverageStoreInfo) { <nl> + if (!catalog . getCoveragesByStore((CoverageStoreInfo) targetStore) . isEmpty()) { <nl> + t . setUpdateMode(UpdateMode . APPEND) ; <nl> + } <nl> - if (task . getLayer() . getId() == null) { <nl> - addToCatalog(task) ; <nl> + if (task . getUpdateMode() == UpdateMode . CREATE) { <nl> + if (task . getLayer() . getId() == null) { <nl> + addToCatalog(task) ; <nl> + } <nl> mmm ImporterMosaicTest . java <nl> ppp ImporterMosaicTest . java <nl> + import org . opengis . filter . Filter ; <nl> + int initialLayerCount = catalog . count(LayerInfo . class, Filter . INCLUDE) ; <nl> + int layerCount = catalog . count(LayerInfo . class, Filter . INCLUDE) ; <nl> + assertEquals(initialLayerCount, layerCount) ; <nl>",
        "commit_message": "[ geos-7109 ] imagemosaic update on importer create a new store and layer",
        "what": "imagemosaic update on importer create a new store and layer",
        "why": "[geos-7109]",
        "check": "0"
    },
    {
        "commit_time": "2022-08-22 09:49:43+02:00",
        "diff": "mmm BasePartDTO . java <nl> ppp BasePartDTO . java <nl> - if (!(ec instanceof FinSet || ec instanceof MassObject)) { <nl> + if (!(ec instanceof FinSet)) { <nl> - if (ec instanceof MassObject) { <nl> - setLen(((MassObject)ec) . getLengthNoAuto() * RocksimCommonConstants . ROCKSIM_TO_OPENROCKET_LENGTH) ; <nl> - } <nl>",
        "commit_message": "removed the check for MassObject and its associated length adjustment in BasePartDTO.java to simplify the condition handling for object types and eliminate redundant code",
        "what": "removed the check for MassObject and its associated length adjustment in BasePartDTO.java",
        "why": "simplify the condition handling for object types and eliminate redundant code",
        "check": "1"
    },
    {
        "commit_time": "2023-11-08 17:19:26-08:00",
        "diff": "mmm TaskGeneratorRegistry . java <nl> ppp TaskGeneratorRegistry . java <nl> - import com . clearspring . analytics . util . Preconditions ; <nl> + import com . google . common . base . Preconditions ; <nl> mmm WindowNode . java <nl> ppp WindowNode . java <nl> - import com . clearspring . analytics . util . Preconditions ; <nl> + import com . google . common . base . Preconditions ; <nl>",
        "commit_message": "fix the wrong import for precondition ( # 11979 )",
        "what": "fix the wrong import for precondition",
        "why": "(implicit) relates to issue #11979",
        "check": "1"
    },
    {
        "commit_time": "2004-06-04 17:07:17+00:00",
        "diff": "mmm Item . java <nl> ppp Item . java <nl> + public Bitstream createSingleBitstream(InputStream is) <nl> + throws AuthorizeException, IOException, SQLException <nl> + { <nl> + return createSingleBitstream(is, ORIGINAL) ; <nl> + } <nl> - throws SQLException, AuthorizeException, IOException <nl> + throws SQLException, AuthorizeException <nl>",
        "commit_message": "added createsinglebitstream ( ) method for backwards compatibility .",
        "what": "added createsinglebitstream( ) method",
        "why": "for backwards compatibility",
        "check": "1"
    },
    {
        "commit_time": "2007-09-08 15:29:52+00:00",
        "diff": "mmm GenericTestBeanCustomizer . java <nl> ppp GenericTestBeanCustomizer . java <nl> + void clearGuiFields() { <nl> + for (int i = 0 ; i < editors . length ; i++) { <nl> + PropertyEditor propertyEditor=editors[i] ; // might be null (e . g .  in testing) <nl> + if (propertyEditor != null) { <nl> + try { <nl> + if (propertyEditor instanceof WrapperEditor){ <nl> + WrapperEditor we = (WrapperEditor) propertyEditor ; <nl> + String tags[]=we . getTags() ; <nl> + if (tags != null) { <nl> + we . setAsText(tags[0]) ; <nl> + } else { <nl> + we . setValue() ; <nl> + } <nl> + } else if (propertyEditor instanceof ComboStringEditor) { <nl> + ComboStringEditor cse = (ComboStringEditor) propertyEditor ; <nl> + cse . setAsText(cse . getInitialEditValue()) ; <nl> + } else { <nl> + propertyEditor . setAsText() ; <nl> + } <nl> + } catch (IllegalArgumentException ex){ <nl> + log . error(Failed to set field +descriptors[i] . getName(),ex) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl>",
        "commit_message": "add clearguifields ( ) method - see bug 43332",
        "what": "add clearguifields ( ) method",
        "why": "see bug 43332",
        "check": "1"
    },
    {
        "commit_time": "2020-05-26 10:00:47+02:00",
        "diff": "mmm TokenEndpointDocs . java <nl> ppp TokenEndpointDocs . java <nl> + scopeParameter, <nl>",
        "commit_message": "added scopeParameter to the TokenEndpointDocs class to support enhanced OAuth 2.0 functionality",
        "what": "added scopeParameter to the TokenEndpointDocs class",
        "why": "support enhanced OAuth 2.0 functionality",
        "check": "1"
    },
    {
        "commit_time": "2021-11-17 13:25:24+01:00",
        "diff": "mmm ITestDbTxnManager . java <nl> ppp ITestDbTxnManager . java <nl>  <nl>",
        "commit_message": "hive-25701 : declare jdbc driver a runtime & optional dependency ( stamatis zampetakis , review by zoltan haindrich )",
        "what": "declare jdbc driver a runtime & optional dependency",
        "why": "ensure proper functionality and flexibility in the project's dependencies",
        "check": "1"
    },
    {
        "commit_time": "2015-04-22 17:44:19-07:00",
        "diff": "mmm GlowScheduler . java <nl> ppp GlowScheduler . java <nl> - import javax . annotation . Nullable ; <nl> - public boolean apply(@Nullable GlowTask glowTask) { <nl> + public boolean apply(GlowTask glowTask) { <nl>",
        "commit_message": "remove jsr305 javax.annotation dependency to fix spongeapi conflict",
        "what": "remove jsr305 javax.annotation dependency",
        "why": "to fix spongeapi conflict",
        "check": "1"
    },
    {
        "commit_time": "2014-09-11 13:44:05+01:00",
        "diff": "mmm AppWidgetManagerCompatVL . java <nl> ppp AppWidgetManagerCompatVL . java <nl> - } catch (Exception e) { <nl> + } catch (Throwable e) { <nl> mmm UserManagerCompatVL . java <nl> ppp UserManagerCompatVL . java <nl> - } catch (Exception e) { <nl> + } catch (Throwable e) { <nl> - return mPm . getUserBadgedLabel(label, user . getUser()) ; <nl> - } catch (Exception e) { <nl> + return mPm . getUserBadgedLabel(label, user . getUser()) ; <nl> + } catch (Throwable e) { <nl>",
        "commit_message": "changed catch block from catching Exception to catching Throwable in AppWidgetManagerCompatVL.java and UserManagerCompatVL.java to handle broader error types and improve error management",
        "what": "changed catch block from catching Exception to catching Throwable in AppWidgetManagerCompatVL.java and UserManagerCompatVL.java",
        "why": "handle broader error types and improve error management",
        "check": "1"
    },
    {
        "commit_time": "2002-05-11 00:46:14+00:00",
        "diff": "new file <nl> ppp SearchService . java <nl> + import org . apache . lucene . analysis . Analyzer ; <nl> + import org . apache . lucene . search . Filter ; <nl> + import org . apache . lucene . search . Query ; <nl> + import org . apache . lucene . document . Document ; <nl> + import org . apache . fulcrum . ServiceException ; <nl> + import org . apache . fulcrum . Service ; <nl> + import java . util . Map ; <nl> + public interface SearchService extends Service <nl> + { <nl> + public static final String SERVICE_NAME = SearchService ; <nl> + public static final String INDEX_LOCATION_KEY = index . location ; <nl> + public SearchResults search(Query query) throws ServiceException ; <nl> + public SearchResults search(Query query, Filter filter) throws ServiceException ; <nl> + public SearchResults search(Query query, Filter filter, <nl> + int from, int to) throws ServiceException ; <nl> + public void batchIndex() throws ServiceException ; <nl> + public boolean isIndexing() ; <nl> + public Analyzer getAnalyzer() ; <nl> + } <nl>",
        "commit_message": "created a new interface SearchService with search and indexing methods to define a standard service for searching and indexing functionality",
        "what": "created a new interface SearchService with search and indexing methods",
        "why": "define a standard service for searching and indexing functionality",
        "check": "1"
    },
    {
        "commit_time": "2015-11-12 11:01:40+01:00",
        "diff": "mmm BridgeMethodsHitAgainTest . java <nl> ppp BridgeMethodsHitAgainTest . java <nl> - import org . junit . Before ; <nl> + import org . junit . Ignore ; <nl> - import org . mockito . MockitoAnnotations ; <nl> + import java . io . Serializable ; <nl> + public interface Base<T extends Serializable> { <nl> + int test(T value) ; <nl> + } <nl> + public interface Extended extends Base<String> { <nl> + @Override <nl> + int test(String value) ; <nl> + } <nl> - } <nl> + @Test <nl> + @Ignore(Mockito does not resolve bridge methods as their actual method and can therefore not verify its invocation) <nl> + public void testBridgeInvocationIsRecordedForInterceptedMethod() { <nl> + Extended ext = mock(Extended . class) ; <nl> + ext . test(123) ; <nl> + verify(ext) . test(123) ; <nl> + ((Base<String>) ext) . test(456) ; <nl> + verify(ext) . test(456) ; <nl> + } <nl> + } <nl>",
        "commit_message": "replaced JUnit's Before import with Ignore and added new interfaces for testing bridge methods to address issues with Mockito not verifying bridge method invocations correctly",
        "what": "replaced JUnit's Before import with Ignore and added new interfaces for testing bridge methods",
        "why": "address issues with Mockito not verifying bridge method invocations correctly",
        "check": "1"
    },
    {
        "commit_time": "2020-05-04 20:39:15-04:00",
        "diff": "deleted file <nl> mmm H2GrantsTest . java <nl> - package schemacrawler . integration . test ; <nl> - import static org . hamcrest . MatcherAssert . assertThat ; <nl> - import static schemacrawler . test . utility . ExecutableTestUtility . executableExecution ; <nl> - import static schemacrawler . test . utility . FileHasContent . classpathResource ; <nl> - import static schemacrawler . test . utility . FileHasContent . hasSameContentAs ; <nl> - import static schemacrawler . test . utility . FileHasContent . outputOf ; <nl> - import org . junit . jupiter . api . BeforeEach ; <nl> - import org . junit . jupiter . api . Test ; <nl> - import org . junit . jupiter . api . extension . ExtendWith ; <nl> - import schemacrawler . schemacrawler . SchemaCrawlerOptions ; <nl> - import schemacrawler . schemacrawler . SchemaCrawlerOptionsBuilder ; <nl> - import schemacrawler . schemacrawler . SchemaInfoLevelBuilder ; <nl> - import schemacrawler . test . utility . BaseAdditionalDatabaseTest ; <nl> - import schemacrawler . test . utility . LightDatabaseBuildCondition ; <nl> - import schemacrawler . tools . executable . SchemaCrawlerExecutable ; <nl> - import schemacrawler . tools . text . schema . SchemaTextOptions ; <nl> - import schemacrawler . tools . text . schema . SchemaTextOptionsBuilder ; <nl> - @ExtendWith(LightDatabaseBuildCondition . class) <nl> - public class H2GrantsTest <nl> - extends BaseAdditionalDatabaseTest <nl> - { <nl> - @BeforeEach <nl> - public void createDatabase() <nl> - throws Exception <nl> - { <nl> - createDataSource(jdbc:h2:mem:customersdb, null, null) ; <nl> - runScript(/h2Grants . sql) ; <nl> - } <nl> - @Test <nl> - public void testH2Grants() <nl> - throws Exception <nl> - { <nl> - final SchemaCrawlerOptionsBuilder schemaCrawlerOptionsBuilder = <nl> - SchemaCrawlerOptionsBuilder <nl> -  . builder() <nl> -  . withSchemaInfoLevel(SchemaInfoLevelBuilder . maximum()) ; <nl> - final SchemaCrawlerOptions schemaCrawlerOptions = <nl> - schemaCrawlerOptionsBuilder . toOptions() ; <nl> - final SchemaTextOptionsBuilder textOptionsBuilder = <nl> - SchemaTextOptionsBuilder . builder() ; <nl> - final SchemaTextOptions textOptions = textOptionsBuilder . toOptions() ; <nl> - final SchemaCrawlerExecutable executable = <nl> - new SchemaCrawlerExecutable(details) ; <nl> - executable . setSchemaCrawlerOptions(schemaCrawlerOptions) ; <nl> - executable . setAdditionalConfiguration(SchemaTextOptionsBuilder <nl> -  . builder(textOptions) <nl> -  . toConfig()) ; <nl> - final String expectedResource = testH2Grants . txt ; <nl> - assertThat(outputOf(executableExecution(getConnection(), executable)), <nl> - hasSameContentAs(classpathResource(expectedResource))) ; <nl> - } <nl> - } <nl>",
        "commit_message": "deleted the H2GrantsTest.java file containing database grant tests to remove obsolete test cases that are no longer needed",
        "what": "deleted the H2GrantsTest.java file containing database grant tests",
        "why": "remove obsolete test cases that are no longer needed",
        "check": "1"
    },
    {
        "commit_time": "2018-05-09 09:10:23+08:00",
        "diff": "mmm ClassLoaderResourceAccessor . java <nl> ppp ClassLoaderResourceAccessor . java <nl> + if (path . contains(!/)) { <nl> + String[] components = path . split(!/) ; <nl> + if (components . length > 1) { <nl> + path = components[components . length - 1] ; <nl> + } <nl> + } <nl>",
        "commit_message": "add test case for core-3139 , and fix it again",
        "what": "add test case for core-3139 and fix it",
        "why": "improve coverage and address the issue related to core-3139",
        "check": "1"
    },
    {
        "commit_time": "2019-06-25 15:02:46-07:00",
        "diff": "mmm HiveConf . java <nl> ppp HiveConf . java <nl> - HIVE_ZOOKEEPER_SESSION_TIMEOUT(hive . zookeeper . session . timeout, 1200000ms, <nl> + HIVE_ZOOKEEPER_SESSION_TIMEOUT(hive . zookeeper . session . timeout, 120000ms, <nl>",
        "commit_message": "hive-20854 sensible default : hive 's zookeeper heartbeat interval be 20 minute , change to 2 ( gopal v via alan gate )",
        "what": "change hive's zookeeper heartbeat interval from 20 minutes to 2 minutes",
        "why": "set a sensible default",
        "check": "0"
    },
    {
        "commit_time": "2019-08-22 10:06:35-07:00",
        "diff": "mmm VersionBuckConfig . java <nl> ppp VersionBuckConfig . java <nl> - import java . util . Map ; <nl> - public Map<VersionTargetGraphMode, Double> getVersionTargetGraphModeGroups() { <nl> - return delegate . getExperimentGroups( <nl> - build, version_tg_mode_probabilities, VersionTargetGraphMode . class) ; <nl> - } <nl> mmm VersionedTargetGraphCache . java <nl> ppp VersionedTargetGraphCache . java <nl> - Map<VersionTargetGraphMode, Double> versionTargetGraphModeProbabilities, <nl> - if (versionTargetGraphModeProbabilities . isEmpty()) { <nl> - resolvedMode = <nl> - RandomizedTrial . getGroup( <nl> - async_version_tg_builder, <nl> - eventBus . getBuildId() . toString(), <nl> - VersionTargetGraphMode . class) ; <nl> - } else { <nl> - resolvedMode = <nl> - RandomizedTrial . getGroup( <nl> - async_version_tg_builder, <nl> - eventBus . getBuildId() . toString(), <nl> - versionTargetGraphModeProbabilities) ; <nl> - } <nl> + resolvedMode = <nl> + RandomizedTrial . getGroup( <nl> + async_version_tg_builder, <nl> + eventBus . getBuildId() . toString(), <nl> + VersionTargetGraphMode . class) ; <nl> - Map<VersionTargetGraphMode, Double> versionTargetGraphModeProbabilities, <nl> - versionTargetGraphModeProbabilities, <nl> - versionBuckConfig . getVersionTargetGraphModeGroups(), <nl> - ImmutableMap . of(), <nl>",
        "commit_message": "updated the method for resolving version target graph modes to improve clarity and remove unnecessary conditions to streamline logic for mode resolution and enhance code maintainability",
        "what": "updated the method for resolving version target graph modes to improve clarity and remove unnecessary conditions",
        "why": "streamline logic for mode resolution and enhance code maintainability",
        "check": "1"
    },
    {
        "commit_time": "2016-06-25 18:49:19-07:00",
        "diff": "mmm FFmpeg . java <nl> ppp FFmpeg . java <nl> - IOUtils . copy(r, new NullOutputStream()) ; // Throw away rest of the output <nl> + IOUtils . copy(r, new NullOutputStream(), Charsets . UTF_8) ; // Throw away rest of the output <nl> - IOUtils . copy(wrapInReader(p), System . out) ; // TODO Should I be outputting to stdout? <nl> + IOUtils . copy(wrapInReader(p), System . out, Charsets . UTF_8) ; // TODO Should I be outputting to <nl>",
        "commit_message": "ensure we use charsets.utf_8 while handle ffmpeg output .",
        "what": "ensure we use charsets.utf_8 while handling ffmpeg output",
        "why": "provides proper encoding for ffmpeg output",
        "check": "1"
    },
    {
        "commit_time": "2008-11-04 22:46:21+00:00",
        "diff": "new file <nl> ppp PermissionEvaluator . java <nl> + package org . springframework . security . expression ; <nl> + import org . springframework . security . Authentication ; <nl> + public interface PermissionEvaluator { <nl> + boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) ; <nl> + } <nl>",
        "commit_message": "add a new interface for evaluating permissions in the security framework to provide a standardized way to check user permissions on domain objects",
        "what": "add a new interface for evaluating permissions in the security framework",
        "why": "provide a standardized way to check user permissions on domain objects",
        "check": "1"
    },
    {
        "commit_time": "2014-11-21 20:02:48+00:00",
        "diff": "mmm PDPage . java <nl> ppp PDPage . java <nl> + import org . apache . commons . logging . Log ; <nl> + import org . apache . commons . logging . LogFactory ; <nl> + private static final Log LOG = LogFactory . getLog(PDPage . class) ; <nl> + if (mediaBox == null) <nl> + { <nl> + LOG . debug(Can't find MediaBox, will use U . S .  Letter) ; <nl> + mediaBox = PDRectangle . LETTER ; <nl> + } <nl>",
        "commit_message": "pdfbox-2423 : use letter a default pagesize if no mediabox be define ( see also pdfbox 1515 / rev 1465217 )",
        "what": "use letter a default pagesize if no mediabox be define",
        "why": "related to pdfbox-2423, see also pdfbox 1515 / rev 1465217",
        "check": "1"
    },
    {
        "commit_time": "2017-06-30 17:12:22+00:00",
        "diff": "mmm DrawGrid . java <nl> ppp DrawGrid . java <nl> - private int getNumberOfSubgrids() {\r <nl> + private int getNumberOfSubgrids(int axis) {\r <nl> - if (view . axesNumberingDistances[0] > 1) {\r <nl> - temp = String . valueOf((int) view . axesNumberingDistances[0]) ;\r <nl> + if (view . axesNumberingDistances[axis] > 1) {\r <nl> + temp = String . valueOf((int) view . axesNumberingDistances[axis]) ;\r <nl> - temp = String . valueOf(view . axesNumberingDistances[0]) ;\r <nl> + temp = String . valueOf(view . axesNumberingDistances[axis]) ;\r <nl> - n = getNumberOfSubgrids() ;\r <nl> + n = getNumberOfSubgrids(1) ; <nl>",
        "commit_message": "ggb-1881 subgrids number fix for different xaxis : yaxis ratio .",
        "what": "ggb-1881 subgrids number fix for different xaxis : yaxis ratio",
        "why": "address issue related to xaxis and yaxis ratio",
        "check": "1"
    },
    {
        "commit_time": "2016-12-14 07:43:26-08:00",
        "diff": "mmm AbstractPrebuiltCxxLibraryGroupDescription . java <nl> ppp AbstractPrebuiltCxxLibraryGroupDescription . java <nl> + import com . facebook . buck . versions . VersionPropagator ; <nl> - Description<AbstractPrebuiltCxxLibraryGroupDescription . Args> { <nl> + Description<AbstractPrebuiltCxxLibraryGroupDescription . Args>, <nl> + VersionPropagator<AbstractPrebuiltCxxLibraryGroupDescription . Args> { <nl>",
        "commit_message": "cxx : make  prebuilt_cxx_library_group ( )  support versioning",
        "what": "make prebuilt_cxx_library_group() support versioning",
        "why": "to improve versioning capabilities",
        "check": "1"
    },
    {
        "commit_time": "2014-04-23 16:22:17+02:00",
        "diff": "mmm AddLocationNode . java <nl> ppp AddLocationNode . java <nl> - @Input private ValueNode x ; <nl> - @Input private ValueNode y ; <nl> + @Input(InputType . Association) private ValueNode x ; <nl> + @Input(InputType . Association) private ValueNode y ; <nl>",
        "commit_message": "use association type for addlocationnode input while wait for a good solution .",
        "what": "use association type for addlocationnode input",
        "why": "wait for a good solution",
        "check": "0"
    },
    {
        "commit_time": "2010-04-19 22:55:12-04:00",
        "diff": "mmm Relative302Test . java <nl> ppp Relative302Test . java <nl>  <nl>",
        "commit_message": "fix proper comment . the test behave differently if inside firewall/proxy",
        "what": "fix proper comment",
        "why": "the test behaves differently if inside firewall/proxy",
        "check": "1"
    },
    {
        "commit_time": "2009-08-10 15:35:51+00:00",
        "diff": "mmm HiveCallableStatement . java <nl> ppp HiveCallableStatement . java <nl>  <nl> mmm HiveConnection . java <nl> ppp HiveConnection . java <nl>  <nl> mmm HiveDataSource . java <nl> ppp HiveDataSource . java <nl>  <nl> mmm HiveDatabaseMetaData . java <nl> ppp HiveDatabaseMetaData . java <nl>  <nl> mmm HiveDriver . java <nl> ppp HiveDriver . java <nl>  <nl> mmm HivePreparedStatement . java <nl> ppp HivePreparedStatement . java <nl>  <nl> mmm HiveResultSet . java <nl> ppp HiveResultSet . java <nl>  <nl> mmm HiveResultSetMetaData . java <nl> ppp HiveResultSetMetaData . java <nl>  <nl> mmm HiveStatement . java <nl> ppp HiveStatement . java <nl>  <nl> mmm TestJdbcDriver . java <nl> ppp TestJdbcDriver . java <nl>  <nl>",
        "commit_message": "refactor multiple Hive classes for improved code organization to enhance maintainability and readability of the Hive JDBC implementation",
        "what": "refactor multiple Hive classes for improved code organization",
        "why": "enhance maintainability and readability of the Hive JDBC implementation",
        "check": "1"
    },
    {
        "commit_time": "2018-05-31 16:53:07+08:00",
        "diff": "mmm GrpcClient . java <nl> ppp GrpcClient . java <nl> - public Optional<TransactionList> getTransactionsByTimestamp(long start, long end, int offset , int limit) { <nl> mmm WalletClient . java <nl> ppp WalletClient . java <nl> - public static Optional<TransactionList> getTransactionsByTimestamp(long start, long end, int offset, int limit) { <nl> mmm WalletTestTransfer004 . java <nl> ppp WalletTestTransfer004 . java <nl> - @Test(enabled = true) <nl>",
        "commit_message": "modified the method signatures for getTransactionsByTimestamp in GrpcClient and WalletClient to ensure consistency across classes for better maintainability",
        "what": "modified the method signatures for getTransactionsByTimestamp in GrpcClient and WalletClient",
        "why": "ensure consistency across classes for better maintainability",
        "check": "1"
    },
    {
        "commit_time": "2007-12-04 07:40:13+00:00",
        "diff": "mmm BatchCommandLineLauncher . java <nl> ppp BatchCommandLineLauncher . java <nl> + public static final String DEFAULT_BEAN_REF_CONTEXT_PATH = beanRefContext . xml ;\r <nl> + private static final String BEAN_REF_CONTEXT_KEY = bean . ref . context ;\r <nl> - public BatchCommandLineLauncher() {\r <nl> - beanFactoryLocator = ContextSingletonBeanFactoryLocator . getInstance() ;\r <nl> + public BatchCommandLineLauncher(String beanRefContextPath) {\r <nl> + beanFactoryLocator = ContextSingletonBeanFactoryLocator\r <nl> +  . getInstance(beanRefContextPath) ;\r <nl> + String beanRefContextPath = System . getProperty(BEAN_REF_CONTEXT_KEY,\r <nl> + DEFAULT_BEAN_REF_CONTEXT_PATH) ;\r <nl> - BatchCommandLineLauncher command = new BatchCommandLineLauncher() ;\r <nl> + BatchCommandLineLauncher command = new BatchCommandLineLauncher(\r <nl> + beanRefContextPath) ; <nl>",
        "commit_message": "resolved - issue batch-245 : make beanrefcontext.xml location configurable",
        "what": "make beanrefcontext.xml location configurable",
        "why": "resolved - issue batch-245",
        "check": "1"
    },
    {
        "commit_time": "2014-03-14 17:45:16+00:00",
        "diff": "mmm WallpaperCropActivity . java <nl> ppp WallpaperCropActivity . java <nl> + cropRect . left = Math . max(0, cropRect . left) ; <nl> + cropRect . right = Math . min(mCropView . getWidth(), cropRect . right) ; <nl> + cropRect . top = Math . max(0, cropRect . top) ; <nl> + cropRect . bottom = Math . min(mCropView . getHeight(), cropRect . bottom) ; <nl>",
        "commit_message": "be e04e8b2a : fix a crash when an image with an odd width/height be select",
        "what": "fix a crash when an image with an odd width/height be select",
        "why": "to prevent application crashes during image selection",
        "check": "1"
    },
    {
        "commit_time": "2013-05-12 18:55:56+02:00",
        "diff": "mmm ICalDataFormatTest . java <nl> ppp ICalDataFormatTest . java <nl> + import org . junit . After ; <nl> + import org . junit . Before ; <nl> + private java . util . TimeZone defaultTimeZone ; <nl> + @Override <nl> + @Before <nl> + public void setUp() throws Exception { <nl> + defaultTimeZone = java . util . TimeZone . getDefault() ; <nl> + java . util . TimeZone . setDefault(java . util . TimeZone . getTimeZone(America/New_York)) ; <nl> + super . setUp() ; <nl> + } <nl> + @Override <nl> + @After <nl> + public void tearDown() throws Exception { <nl> + java . util . TimeZone . setDefault(defaultTimeZone) ; <nl> + super . tearDown() ; <nl> + } <nl>",
        "commit_message": "fix the unit test which fail in environment where new york be n't the default time zone",
        "what": "fix the unit test which fail in environment where new york be n't the default time zone",
        "why": "ensure tests pass in non-default time zones",
        "check": "1"
    },
    {
        "commit_time": "2012-01-06 03:51:43+01:00",
        "diff": "mmm MMapController . java <nl> ppp MMapController . java <nl> + if (existingNode == null)\r <nl> + return newModel() ; <nl>",
        "commit_message": "backward compatibility : make newmapmodel ( null ) work",
        "what": "make newmapmodel ( null ) work",
        "why": "backward compatibility",
        "check": "1"
    },
    {
        "commit_time": "2014-11-12 22:29:19+02:00",
        "diff": "mmm Configuration . java <nl> ppp Configuration . java <nl> + public static final String EXTERNAL_SCRIPT_TIMEOUT_KEY = server . script . timeout ; <nl> + public static final String EXTERNAL_SCRIPT_TIMEOUT_DEFAULT = 5000 ; <nl> + configsMap . put(EXTERNAL_SCRIPT_TIMEOUT_KEY, properties . getProperty( <nl> + EXTERNAL_SCRIPT_TIMEOUT_KEY, EXTERNAL_SCRIPT_TIMEOUT_DEFAULT)) ; <nl> + public Integer getExternalScriptTimeout() { <nl> + return Integer . parseInt(properties . getProperty(EXTERNAL_SCRIPT_TIMEOUT_KEY, EXTERNAL_SCRIPT_TIMEOUT_DEFAULT)) ; <nl> + } <nl> mmm ClientConfigResourceProvider . java <nl> ppp ClientConfigResourceProvider . java <nl> - executeCommand(cmd, SCRIPT_TIMEOUT) ; <nl> + executeCommand(cmd, configs . getExternalScriptTimeout()) ; <nl> mmm ClientConfigResourceProviderTest . java <nl> ppp ClientConfigResourceProviderTest . java <nl> + expect(configuration . getExternalScriptTimeout()) . andReturn(Integer . parseInt(Configuration . EXTERNAL_SCRIPT_TIMEOUT_DEFAULT)) ; <nl>",
        "commit_message": "added external script timeout configuration and retrieval methods to allow dynamic configuration of script execution timeout",
        "what": "added external script timeout configuration and retrieval methods",
        "why": "allow dynamic configuration of script execution timeout",
        "check": "1"
    },
    {
        "commit_time": "2013-08-31 23:00:49-07:00",
        "diff": "mmm DinnerPermsResolver . java <nl> ppp DinnerPermsResolver . java <nl> - private static final String GROUP_PREFIX = group .  ; <nl> - private final Server server ; <nl> + public static final String GROUP_PREFIX = group .  ; <nl> + protected final Server server ; <nl> mmm PermissionsExResolver . java <nl> ppp PermissionsExResolver . java <nl> + import org . bukkit . permissions . Permissible ; <nl> - public class PermissionsExResolver implements PermissionsResolver { <nl> + public class PermissionsExResolver extends DinnerPermsResolver { <nl> - private final Server server ; <nl> - this . server = server ; <nl> + super(server) ; <nl> - public void load() { <nl> - } <nl> - public boolean hasPermission(String name, String permission) { <nl> - Player player = server . getPlayerExact(name) ; <nl> - return manager . has(name, permission, player == null ? null : player . getWorld() . getName()) ; <nl> - } <nl> - public boolean inGroup(String player, String group) { <nl> - PermissionUser user = manager . getUser(player) ; <nl> - if (user == null) { <nl> - return false ; <nl> - } <nl> - return user . inGroup(group) ; <nl> - } <nl> - public String[] getGroups(String player) { <nl> - PermissionUser user = manager . getUser(player) ; <nl> - if (user == null) { <nl> - return new String[0] ; <nl> - } <nl> - return user . getGroupsNames() ; <nl> - } <nl> - Player onlinePlayer = player . getPlayer() ; <nl> - return manager . has(player . getName(), permission, onlinePlayer == null ? null : onlinePlayer . getWorld() . getName()) ; <nl> + Permissible permissible = getPermissible(player) ; <nl> + if (permissible == null) { <nl> + return manager . has(player . getName(), permission, null) ; <nl> + } else { <nl> + return permissible . hasPermission(permission) ; <nl> + } <nl> - return inGroup(player . getName(), group) ; <nl> + if (getPermissible(player) == null) { <nl> + return manager . getUser(player . getName()) . inGroup(group) ; <nl> + } else { <nl> + return hasPermission(player, GROUP_PREFIX group) ; <nl> + } <nl> - return getGroups(player . getName()) ; <nl> + if (getPermissible(player) == null) { <nl> + PermissionUser user = manager . getUser(player . getName()) ; <nl> + if (user == null) { <nl> + return new String[0] ; <nl> + } <nl> + return user . getGroupsNames() ; <nl> + } else { <nl> + return super . getGroups(player) ; <nl> + } <nl>",
        "commit_message": "update pex wepif resolver to use superperms where possible",
        "what": "update pex wepif resolver to use superperms",
        "why": "where possible",
        "check": "0"
    },
    {
        "commit_time": "2017-06-20 04:35:14-07:00",
        "diff": "mmm JdtUtils . java <nl> ppp JdtUtils . java <nl> - return createTypeDescriptor(javaLangInteger . getSuperclass()) ; <nl> + TypeDescriptor numberDescriptor = createTypeDescriptor(javaLangInteger . getSuperclass()) ; <nl> + Preconditions . checkState(java . lang . Number . equals(numberDescriptor . getSourceName())) ; <nl> + return numberDescriptor ; <nl> - return createTypeDescriptor(interfaces[0] . getErasure()) ; <nl> + TypeDescriptor comparableDescriptor = createTypeDescriptor(interfaces[0] . getErasure()) ; <nl> + Preconditions . checkState(java . lang . Comparable . equals(comparableDescriptor . getSourceName())) ; <nl> + return comparableDescriptor ; <nl> - return createTypeDescriptor(i) ; <nl> + TypeDescriptor charSequenceDescriptor = createTypeDescriptor(i) ; <nl> + Preconditions . checkState( <nl> + java . lang . CharSequence . equals(charSequenceDescriptor . getSourceName())) ; <nl> + return charSequenceDescriptor ; <nl>",
        "commit_message": "add a precondition check to ensure that descriptor for type not well know to eclipse jdt be be set correctly .",
        "what": "add a precondition check to ensure that descriptor for type not well known to eclipse jdt be set correctly",
        "why": "ensure that the descriptor is set correctly",
        "check": "1"
    },
    {
        "commit_time": "2015-12-22 02:04:09-08:00",
        "diff": "mmm ScheduledChore . java <nl> ppp ScheduledChore . java <nl> - private synchronized double getMaximumAllowedTimeBetweenRuns() { <nl> + private double getMaximumAllowedTimeBetweenRuns() { <nl> - public synchronized String getName() { <nl> + public String getName() { <nl> - public synchronized Stoppable getStopper() { <nl> + public Stoppable getStopper() { <nl> - public synchronized int getPeriod() { <nl> + public int getPeriod() { <nl> - public synchronized long getInitialDelay() { <nl> + public long getInitialDelay() { <nl> - public final synchronized TimeUnit getTimeUnit() { <nl> + public TimeUnit getTimeUnit() { <nl>",
        "commit_message": "hbase-14977 choreservice.shutdown may result in concurrentmodificationexception - addendum to fix extra concurrency issue",
        "what": "hbase-14977 choreservice.shutdown may result in concurrentmodificationexception - addendum to fix extra concurrency issue",
        "why": "fix extra concurrency issue",
        "check": "1"
    },
    {
        "commit_time": "2018-11-20 19:06:35+01:00",
        "diff": "mmm ContainerResource . java <nl> ppp ContainerResource . java <nl> - BytesLimitTerminateTimeTailPrettyLoggable<S, W> { <nl> + TimestampBytesLimitTerminateTimeTailPrettyLoggable<S, W> { <nl> new file <nl> ppp TimestampBytesLimitTerminateTimeTailPrettyLoggable . java <nl> + package io . fabric8 . kubernetes . client . dsl ; <nl> + public interface TimestampBytesLimitTerminateTimeTailPrettyLoggable<T, W> extends Timestampable<BytesLimitTerminateTimeTailPrettyLoggable<T, W>>, BytesLimitTerminateTimeTailPrettyLoggable<T, W> { <nl> + } <nl> mmm PodOperationsImpl . java <nl> ppp PodOperationsImpl . java <nl> + if (withTimestamps) { <nl> + sb . append(&timestamps=true) ; <nl> + } <nl> + @Override <nl> + public BytesLimitTerminateTimeTailPrettyLoggable<String, LogWatch> usingTimestamps() { <nl> + return new PodOperationsImpl(client, getConfig(), apiVersion, namespace, name, isCascading(), getItem(), getResourceVersion(), isReloadingFromServer(), getGracePeriodSeconds(), getLabels(), getLabelsNot(), getLabelsIn(), getLabelsNotIn(), getFields(), containerId, in, inPipe, out, outPipe, err, errPipe, errChannel, errChannelPipe, withTTY, withTerminatedStatus, true, sinceTimestamp, sinceSeconds, withTailingLines, withPrettyOutput, execListener, limitBytes) ; <nl> + } <nl> mmm PodTest . java <nl> ppp PodTest . java <nl> + server . expect() . withPath(/api/v1/namespaces/test5/pods/pod1/log?pretty=false&tailLines=1&timestamps=true) . andReturn(200, pod1Log) . once() ; <nl> + log = client . pods() . inNamespace(test5) . withName(pod1) . usingTimestamps() . tailingLines(1) . getLog() ; <nl> + assertEquals(pod1Log, log) ; <nl> mmm BuildResource . java <nl> ppp BuildResource . java <nl> - import io . fabric8 . kubernetes . client . dsl . BytesLimitTerminateTimeTailPrettyLoggable ; <nl> + import io . fabric8 . kubernetes . client . dsl . TimestampBytesLimitTerminateTimeTailPrettyLoggable ; <nl> - BytesLimitTerminateTimeTailPrettyLoggable<S, W> { <nl> + TimestampBytesLimitTerminateTimeTailPrettyLoggable<S, W> { <nl> mmm BuildOperationsImpl . java <nl> ppp BuildOperationsImpl . java <nl> + if (withTimestamps) { <nl> + sb . append(&timestamps=true) ; <nl> + } <nl> + @Override <nl> + public BytesLimitTerminateTimeTailPrettyLoggable<String, LogWatch> usingTimestamps() { <nl> + return new BuildOperationsImpl(client, getConfig(), apiVersion, namespace, name, isCascading(), getItem(), getResourceVersion(), isReloadingFromServer(), getGracePeriodSeconds(), getLabels(), getLabelsNot(), getLabelsIn(), getLabelsNotIn(), getFields(), in,out,err,inPipe, outPipe, errPipe, withTTY, withTerminatedStatus, true, sinceTimestamp, sinceSeconds, withTailingLines, withPrettyOutput, version, limitBytes) ; <nl> + } <nl>",
        "commit_message": "fix # 579 - add timestampable interface to podoperationsimpl/buildoperationsimpl and set timestamps parameter",
        "what": "add timestampable interface to podoperationsimpl/buildoperationsimpl and set timestamps parameter",
        "why": "fix #579",
        "check": "1"
    },
    {
        "commit_time": "2011-02-02 15:55:04-08:00",
        "diff": "mmm VirtualMachineProfile . java <nl> ppp VirtualMachineProfile . java <nl> - enum Param { <nl> - VmPassword,   <nl> - ControlNic, <nl> - RestartNetwork, <nl> - } <nl> + public static class Param { <nl> + public static final Param VmPassword = new Param(VmPassword) ; <nl> + public static final Param ControlNic = new Param(ControlNic) ; <nl> + public static final Param RestartNetwork = new Param(RestartNetwork) ; <nl> + private String name ; <nl> + public Param(String name) { <nl> + synchronized(Param . class) { <nl> + this . name = name ; <nl> + } <nl> + } <nl> + public String getName() { <nl> + return name ; <nl> + } <nl> + } <nl> mmm SecondaryStorageManagerImpl . java <nl> ppp SecondaryStorageManagerImpl . java <nl>  <nl>",
        "commit_message": "use static inner class instead of enum for param parameter ( use in virtualmachineprofile )",
        "what": "use static inner class instead of enum for param parameter",
        "why": "use in virtualmachineprofile",
        "check": "1"
    },
    {
        "commit_time": "2014-02-16 14:39:54+01:00",
        "diff": "new file <nl> ppp AssertDelegateTarget . java <nl> + package org . assertj . core . api ; <nl> + public interface AssertDelegateTarget { <nl> + } <nl> mmm Assertions . java <nl> ppp Assertions . java <nl> + public static <T extends AssertDelegateTarget> T assertThat(T assertion) { <nl> + return assertion ; <nl> + } <nl> new file <nl> ppp Assertions_assertThat_with_AssertDelegateTarget_Test . java <nl> + package org . assertj . core . api ; <nl> + import static org . assertj . core . api . Assertions . assertThat ; <nl> + import org . junit . Test ; <nl> + public class Assertions_assertThat_with_AssertDelegateTarget_Test { <nl> + @Test <nl> + public void should_allow_wrapping_assertion_method_within_assertThat() { <nl> + MyAssertDelegateTarget assertion = new MyAssertDelegateTarget(true) ; <nl> + assertThat(assertion) . isCompletelyTrue() ; <nl> + Object result = assertThat(assertion) ; <nl> + assertThat(result) . isSameAs(assertion) ; <nl> + } <nl> + private static class MyAssertDelegateTarget implements AssertDelegateTarget { <nl> + private boolean value ; <nl> + public MyAssertDelegateTarget(boolean v) { <nl> + value = v ; <nl> + } <nl> + void isCompletelyTrue() { <nl> + assertThat(value) . isTrue() ; <nl> + } <nl> + } <nl> + } <nl>",
        "commit_message": "added AssertDelegateTarget interface and updated Assertions to support it to enable wrapping assertion methods for better usability in assertion chains",
        "what": "added AssertDelegateTarget interface and updated Assertions to support it",
        "why": "enable wrapping assertion methods for better usability in assertion chains",
        "check": "1"
    },
    {
        "commit_time": "2015-09-18 17:05:39+00:00",
        "diff": "mmm LauncherModel . java <nl> ppp LauncherModel . java <nl> + public static List<ResolveInfo> sBgShortcutProviders ; <nl> - Intent shortcutsIntent = new Intent(Intent . ACTION_CREATE_SHORTCUT) ; <nl> - widgetsAndShortcuts . addAll(packageManager . queryIntentActivities(shortcutsIntent, 0)) ; <nl> + synchronized (sBgLock) { <nl> + try { <nl> + Intent shortcutsIntent = new Intent(Intent . ACTION_CREATE_SHORTCUT) ; <nl> + List<ResolveInfo> providers = packageManager . queryIntentActivities(shortcutsIntent, 0) ; <nl> + sBgShortcutProviders = providers ; <nl> + } catch (RuntimeException e) { <nl> + if (!LauncherAppState . isDogfoodBuild() && <nl> + (e . getCause() instanceof TransactionTooLargeException || <nl> + e . getCause() instanceof DeadObjectException)) { <nl> + } else { <nl> + throw e ; <nl> + } <nl> + } <nl> + if (sBgShortcutProviders != null) { <nl> + widgetsAndShortcuts . addAll(sBgShortcutProviders) ; <nl> + } <nl> + } <nl>",
        "commit_message": "added synchronization for querying shortcut providers and updated handling of exceptions to improve stability and thread safety when retrieving shortcut data",
        "what": "added synchronization for querying shortcut providers and updated handling of exceptions",
        "why": "improve stability and thread safety when retrieving shortcut data",
        "check": "1"
    },
    {
        "commit_time": "2019-12-06 09:09:33-08:00",
        "diff": "mmm MainModuleOnly . java <nl> ppp MainModuleOnly . java <nl> + import jtreg . SkippedException ; <nl> + import sun . hotspot . code . Compiler ; <nl> - run2(null, topArchiveName, <nl> - -Xlog:cds+dynamic=debug,cds=debug,class+load=trace, <nl> - -cp, destJar . toString(), <nl> - --limit-modules, java . base, + TEST_MODULE1, <nl> - --module-path, moduleDir . toString(), <nl> - -m, TEST_MODULE1) <nl> -  . assertSilentlyDisabledCDS(out -> { <nl> - out . shouldHaveExitValue(0) <nl> -  . shouldMatch(CDS is disabled when the . *option is specified) <nl> -  . shouldMatch( . class . load .  com . simple . Main source: . *com . simple . jar) ; <nl> + boolean skippedTest = false ; <nl> + if (!Compiler . isGraalEnabled()) { <nl> + run2(null, topArchiveName, <nl> + -Xlog:cds+dynamic=debug,cds=debug,class+load=trace, <nl> + -cp, destJar . toString(), <nl> + --limit-modules, java . base, TEST_MODULE1, <nl> + --module-path, moduleDir . toString(), <nl> + -m, TEST_MODULE1) <nl> +  . assertSilentlyDisabledCDS(out -> { <nl> + out . shouldHaveExitValue(0) <nl> +  . shouldMatch(CDS is disabled when the . *option is specified) <nl> +  . shouldMatch( . class . load .  com . simple . Main source: . *com . simple . jar) ; <nl> + } else { <nl> + skippedTest = true ; <nl> + } <nl> + if (skippedTest) { <nl> + throw new SkippedException(Skipped --limit-modules test ; it can't be run with Graal enabled) ; <nl> + } <nl> mmm MainModuleOnly . java <nl> ppp MainModuleOnly . java <nl> + import jtreg . SkippedException ; <nl> + import sun . hotspot . code . Compiler ; <nl> - TestCommon . run(-Xlog:class+load=trace, <nl> - -cp, destJar . toString(), <nl> - --limit-modules, java . base, + TEST_MODULE1, <nl> - --module-path, moduleDir . toString(), <nl> - -m, TEST_MODULE1) <nl> -  . assertSilentlyDisabledCDS(out -> { <nl> - out . shouldHaveExitValue(0) <nl> -  . shouldMatch(CDS is disabled when the . *option is specified) <nl> -  . shouldMatch( . class . load .  com . simple . Main source: . *com . simple . jar) ; <nl> + boolean skippedTest = false ; <nl> + if (!Compiler . isGraalEnabled()) { <nl> + TestCommon . run(-Xlog:class+load=trace, <nl> + -cp, destJar . toString(), <nl> + --limit-modules, java . base, TEST_MODULE1, <nl> + --module-path, moduleDir . toString(), <nl> + -m, TEST_MODULE1) <nl> +  . assertSilentlyDisabledCDS(out -> { <nl> + out . shouldHaveExitValue(0) <nl> +  . shouldMatch(CDS is disabled when the . *option is specified) <nl> +  . shouldMatch( . class . load .  com . simple . Main source: . *com . simple . jar) ; <nl> + } else { <nl> + skippedTest = true ; <nl> + } <nl> + if (skippedTest) { <nl> + throw new SkippedException(Skipped --limit-modules test ; it can't be run with Graal enabled) ; <nl> + } <nl> mmm ModulePathAndCP_JFR . java <nl> ppp ModulePathAndCP_JFR . java <nl>  <nl>",
        "commit_message": "8225219 : [ testbug ] appcds test time out with -xcomp and -- limit-modules option wo n't work with graal",
        "what": "appcds test time out with -xcomp and --limit-modules option",
        "why": "won't work with graal",
        "check": "1"
    },
    {
        "commit_time": "2014-12-17 12:54:26-05:00",
        "diff": "new file <nl> ppp PropertyService . java <nl> + package org . apache . ambari . view . property ; <nl> + import org . apache . ambari . view . ViewContext ; <nl> + import javax . inject . Inject ; <nl> + import javax . ws . rs . GET ; <nl> + import javax . ws . rs . POST ; <nl> + import javax . ws . rs . Path ; <nl> + import javax . ws . rs . PathParam ; <nl> + import javax . ws . rs . Produces ; <nl> + import javax . ws . rs . Consumes ; <nl> + import javax . ws . rs . core . Context ; <nl> + import javax . ws . rs . core . HttpHeaders ; <nl> + import javax . ws . rs . core . Response ; <nl> + import javax . ws . rs . core . UriInfo ; <nl> + import java . io . IOException ; <nl> + import java . util . Map ; <nl> + import java . util . Iterator ; <nl> + public class PropertyService { <nl> + @Inject <nl> + ViewContext context ; <nl> + @GET <nl> + @Path(/) <nl> + @Produces({text/plain, application/json}) <nl> + public Response getValue(@Context HttpHeaders headers, @Context UriInfo ui) { <nl> + Map props = context . getProperties() ; ; <nl> + Iterator it = props . entrySet() . iterator() ; <nl> + StringBuffer buf = new StringBuffer() ; <nl> + boolean first = true ; <nl> + buf . append([) ; <nl> + while(it . hasNext()) { <nl> + Map . Entry pairs = (Map . Entry)it . next() ; <nl> + if (first == false) <nl> + buf . append(,\\n) ; <nl> + buf . append({\\) ; <nl> + buf . append(pairs . getKey()) ; <nl> + buf . append(\\ : \\) ; <nl> + buf . append(pairs . getValue()) ; <nl> + buf . append(\\}) ; <nl> + first = false ; <nl> + } <nl> + buf . append(]) ; <nl> + return Response . ok(buf . toString()) . build() ; <nl> + } <nl> + } // end PropertyService <nl>",
        "commit_message": "added a new file for PropertyService to handle property retrieval to provide a RESTful service fetching properties in JSON format",
        "what": "added a new file for PropertyService to handle property retrieval",
        "why": "provide a RESTful service fetching properties in JSON format",
        "check": "1"
    },
    {
        "commit_time": "2017-11-08 16:33:58+01:00",
        "diff": "mmm AuthenticatorUrlUtils . java <nl> ppp AuthenticatorUrlUtils . java <nl> - if (url . endsWith(/)) { <nl> - url = url . substring(0, url . length() 1) ; <nl> + String normalizedUrl = url ; <nl> + if (normalizedUrl . endsWith(/)) { <nl> + normalizedUrl = normalizedUrl . substring(0, normalizedUrl . length() - 1) ; <nl> - return trimUrlWebdav(url) ; <nl> + return trimUrlWebdav(normalizedUrl) ; <nl> mmm MediaService . java <nl> ppp MediaService . java <nl> - boolean mIsStreaming = false ; <nl>",
        "commit_message": "normalize URL handling in AuthenticatorUrlUtils by using a separate variable for standardization to improve code clarity and ensure consistent URL processing",
        "what": "normalize URL handling in AuthenticatorUrlUtils by using a separate variable for standardization",
        "why": "improve code clarity and ensure consistent URL processing",
        "check": "1"
    },
    {
        "commit_time": "2017-01-14 19:42:54+02:00",
        "diff": "mmm Int2IntCounterMap . java <nl> ppp Int2IntCounterMap . java <nl> - final int[] entries = this . entries ; <nl> - @DoNotSub final int length = entries . length ; <nl> - for (@DoNotSub int i = 1 ; i < length ; i += 2) <nl> + if (value != initialValue) <nl> - if (value == entries[i]) <nl> + final int[] entries = this . entries ; <nl> + @DoNotSub final int length = entries . length ; <nl> + for (@DoNotSub int i = 1 ; i < length ; i += 2) <nl> - found = true ; <nl> - break ; <nl> + if (value == entries[i]) <nl> + { <nl> + found = true ; <nl> + break ; <nl> + } <nl> mmm Int2IntHashMap . java <nl> ppp Int2IntHashMap . java <nl> - final int[] entries = this . entries ; <nl> - @DoNotSub final int length = entries . length ; <nl> - for (@DoNotSub int valueIndex = 1 ; valueIndex < length ; valueIndex += 2) <nl> + if (value != missingValue) <nl> - if (value == entries[valueIndex]) <nl> + final int[] entries = this . entries ; <nl> + @DoNotSub final int length = entries . length ; <nl> + for (@DoNotSub int valueIndex = 1 ; valueIndex < length ; valueIndex += 2) <nl> - found = true ; <nl> - break ; <nl> + if (value == entries[valueIndex]) <nl> + { <nl> + found = true ; <nl> + break ; <nl> + } <nl> mmm Int2IntCounterMapTest . java <nl> ppp Int2IntCounterMapTest . java <nl> - public void shouldNotAllowMissingValueAsValue() <nl> + public void shouldNotAllowInitialValueAsValue() <nl> - public void shouldAllowMissingValueAsKey() <nl> + public void shouldAllowInitialValueAsKey() <nl> + @Test <nl> + public void shouldNotContainInitialValue() <nl> + { <nl> + assertFalse(map . containsValue(INITIAL_VALUE)) ; <nl> + map . put(INITIAL_VALUE, 1) ; <nl> + assertFalse(map . containsValue(INITIAL_VALUE)) ; <nl> + } <nl> mmm Int2IntHashMapTest . java <nl> ppp Int2IntHashMapTest . java <nl> + @Test <nl> + public void shouldNotContainMissingValue() <nl> + { <nl> + assertFalse(map . containsValue(MISSING_VALUE)) ; <nl> + map . put(MISSING_VALUE, 1) ; <nl> + assertFalse(map . containsValue(MISSING_VALUE)) ; <nl> + } <nl>",
        "commit_message": "[ java ] fix containsvalue in primitive map to correctly handle missingvalue",
        "what": "fix containsvalue in primitive map to correctly handle missingvalue",
        "why": "to correctly handle missing value",
        "check": "1"
    },
    {
        "commit_time": "2012-07-27 21:41:26-04:00",
        "diff": "mmm FileUtils . java <nl> ppp FileUtils . java <nl> - return StringUtils . getRelativePath(exactBase . getPath(), exactPath . getPath()) ;\r <nl> + if (exactPath . getPath() . startsWith(exactBase . getPath())) {\r <nl> + return StringUtils . getRelativePath(exactBase . getPath(), exactPath . getPath()) ;\r <nl> + } else if (exactPath . getPath() . startsWith(basePath . getAbsolutePath())) {\r <nl> + return StringUtils . getRelativePath(basePath . getAbsolutePath(), exactPath . getPath()) ;\r <nl> + } else if (path . getAbsolutePath() . startsWith(exactBase . getPath())) {\r <nl> + return StringUtils . getRelativePath(exactBase . getPath(), path . getAbsolutePath()) ;\r <nl> + } else if (path . getAbsolutePath() . startsWith(basePath . getAbsolutePath())) {\r <nl> + return StringUtils . getRelativePath(basePath . getAbsolutePath(), path . getAbsolutePath()) ;\r <nl> + }\r <nl> + return null ; <nl>",
        "commit_message": "fix to relative path determination for symlinks ( issue 116 )",
        "what": "fix to relative path determination for symlinks",
        "why": "addresses issue 116",
        "check": "1"
    },
    {
        "commit_time": "2014-09-24 12:22:06+02:00",
        "diff": "mmm MoveActivity . java <nl> ppp MoveActivity . java <nl> - import android . support . v4 . widget . SwipeRefreshLayout ; <nl> - OnClickListener, SwipeRefreshLayout . OnRefreshListener { <nl> + OnClickListener, OnEnforceableRefreshListener { <nl> + refreshList(true) ; <nl> + } <nl> + @Override <nl> + public void onRefresh(boolean enforced) { <nl> + refreshList(enforced) ; <nl> + } <nl> + private void refreshList(boolean ignoreETag) { <nl> - startSyncFolderOperation(folder, true) ; <nl> + startSyncFolderOperation(folder, ignoreETag) ; <nl>",
        "commit_message": "refactor MoveActivity to use OnEnforceableRefreshListener instead of SwipeRefreshLayout.OnRefreshListener to enhance the refresh functionality by allowing enforced refresh operations",
        "what": "refactor MoveActivity to use OnEnforceableRefreshListener instead of SwipeRefreshLayout.OnRefreshListener",
        "why": "enhance the refresh functionality by allowing enforced refresh operations",
        "check": "1"
    },
    {
        "commit_time": "2014-12-12 20:01:04+00:00",
        "diff": "mmm CloudComputeService . java <nl> ppp CloudComputeService . java <nl> + import java . util . Map ; <nl> + private final Map<String, String> mUserMetadata ; <nl> - String imageId, String keyPair, String securityGroup, Float maxBid) { <nl> + String imageId, String keyPair, String securityGroup, Float maxBid, Map<String,String> userMetadata) { <nl> + mUserMetadata = userMetadata ; <nl> -  . spotPrice(mMaxBid) . tags(Collections . singletonList(mGroupTag)) ; <nl> +  . spotPrice(mMaxBid) . tags(Collections . singletonList(mGroupTag)) <nl> +  . userMetadata(mUserMetadata) ; <nl> mmm CloudExecutionContextProvider . java <nl> ppp CloudExecutionContextProvider . java <nl> + public static final String USER_METADATA = userMetadata ; <nl> - instanceType, groupName, imageId, keyPair, securityGroup, maxBid) ; <nl> + instanceType, groupName, imageId, keyPair, securityGroup, maxBid, context . getSubProperties(USER_METADATA  . )) ; <nl>",
        "commit_message": "added user metadata handling to CloudComputeService and CloudExecutionContextProvider to enhance cloud compute functionality by allowing user-specific metadata to be passed and utilized",
        "what": "added user metadata handling to CloudComputeService and CloudExecutionContextProvider",
        "why": "enhance cloud compute functionality by allowing user-specific metadata to be passed and utilized",
        "check": "1"
    },
    {
        "commit_time": "2015-08-13 15:04:54-07:00",
        "diff": "mmm ConsoleActivity . java <nl> ppp ConsoleActivity . java <nl> - Log . d(TAG, Someone sending HANDLE_DISCONNECT to parentHandler) ; <nl> + synchronized (pager) { <nl> + Log . d(TAG, Someone sending HANDLE_DISCONNECT to parentHandler) ; <nl> - TerminalBridge bridge = (TerminalBridge) msg . obj ; <nl> + TerminalBridge bridge = (TerminalBridge) msg . obj ; <nl> - adapter . notifyDataSetChanged() ; <nl> - if (bridge . isAwaitingClose()) { <nl> - closeBridge(bridge) ; <nl> + adapter . notifyDataSetChanged() ; <nl> + if (bridge . isAwaitingClose()) { <nl> + closeBridge(bridge) ; <nl> + } <nl> - synchronized (pager) { <nl> - updateEmptyVisible() ; <nl> - updatePromptVisible() ; <nl> + updateEmptyVisible() ; <nl> + updatePromptVisible() ; <nl> - if (pager . getChildCount() == 0) { <nl> - finish() ; <nl> - } <nl> + if (pager . getChildCount() == 0) { <nl> + finish() ; <nl>",
        "commit_message": "added synchronization around the log message and reorganized the code for handling bridge closure to ensure thread safety during bridge operations and improve code readability",
        "what": "added synchronization around the log message and reorganized the code for handling bridge closure",
        "why": "ensure thread safety during bridge operations and improve code readability",
        "check": "1"
    },
    {
        "commit_time": "2022-07-19 14:10:56+10:00",
        "diff": "mmm BufferedBlockCipher . java <nl> ppp BufferedBlockCipher . java <nl> + if (pgpCFB && forEncryption) <nl> + { <nl> + return length bufOff (cipher . getBlockSize() 2) ; <nl> + } <nl>",
        "commit_message": "tweaked update size for pgpcfb ( java 15+ issue )",
        "what": "tweaked update size for pgpcfb",
        "why": "java 15+ issue",
        "check": "1"
    },
    {
        "commit_time": "2020-05-04 17:26:00+02:00",
        "diff": "mmm SplitAggregateStackOverflowIssueTest . java <nl> ppp SplitAggregateStackOverflowIssueTest . java <nl> - assertTrue(Stackframe must not be too high, was  + count . get(), count . get() < 100) ; <nl> + assertTrue(Stackframe must not be too high, was  count . get(), count . get() < 70) ; <nl>",
        "commit_message": "camel-14996 : splitter/multicast eip can cause a thread to starve from endless stackframes when split a it do not collapse it stackframes but keep schedule for next split/task .",
        "what": "splitter/multicast eip can cause a thread to starve from endless stackframes when split",
        "why": "do not collapse it stackframes but keep schedule for next split/task",
        "check": "1"
    },
    {
        "commit_time": "2015-01-06 15:57:50+00:00",
        "diff": "mmm ElectingLevelDBStoreTest . java <nl> ppp ElectingLevelDBStoreTest . java <nl> - assertEquals(expected_list, getMessages(ms)) ; <nl> + ArrayList<String> messagesInStore = getMessages(ms) ; <nl> + int index=0 ; <nl> + for (String id: expected_list) { <nl> + if (!id . equals(messagesInStore . get(index))) { <nl> + LOG . info(Mismatch for expected: id , got: messagesInStore . get(index)) ; <nl> + break ; <nl> + } <nl> + index++ ; <nl> + } <nl> + assertEquals(expected_list, messagesInStore) ; <nl>",
        "commit_message": "track first miss message - to see if there be some consistency to the ubuntu ci failure",
        "what": "track first miss message",
        "why": "to see if there be some consistency to the ubuntu ci failure",
        "check": "1"
    },
    {
        "commit_time": "2022-12-29 19:10:43+01:00",
        "diff": "mmm ConsoleProvider . java <nl> ppp ConsoleProvider . java <nl> + import javax . swing . JScrollPane ; <nl> - AbstractOutputTab outputTab = (AbstractOutputTab) getSelected() ; <nl> - AbstractOutputPane outputPane = outputTab . getOutputPane() ; <nl> - return outputPane . getTextView() ; <nl> + JComponent outputTab = getSelected() ; <nl> + JScrollPane outputPane = (JScrollPane) outputTab . getComponent(0) ; <nl> + return (JTextComponent) outputPane . getViewport() . getComponent(0) ; <nl>",
        "commit_message": "refactor output tab and output pane initialization in ConsoleProvider.java to improve code clarity and maintainability by using generic JComponent and JScrollPane types",
        "what": "refactor output tab and output pane initialization in ConsoleProvider.java",
        "why": "improve code clarity and maintainability by using generic JComponent and JScrollPane types",
        "check": "1"
    },
    {
        "commit_time": "2014-10-02 02:34:32-07:00",
        "diff": "mmm DecideRuleSequence . java <nl> ppp DecideRuleSequence . java <nl> + import org . archive . modules . net . CrawlHost ; <nl> + import org . archive . modules . net . ServerCache ; <nl> + import org . json . JSONObject ; <nl> - Logger . getLogger(DecideRuleSequence . class . getName()) ; <nl> + Logger . getLogger(DecideRuleSequence . class . getName()) ; <nl> + protected boolean logExtraInfo = false ; <nl> + public boolean getLogExtraInfo() { <nl> + return logExtraInfo ; <nl> + } <nl> + public void setLogExtraInfo(boolean logExtraInfo) { <nl> + this . logExtraInfo = logExtraInfo ; <nl> + } <nl> + protected ServerCache serverCache ; <nl> + public ServerCache getServerCache() { <nl> + return this . serverCache ; <nl> + } <nl> + @Autowired <nl> + public void setServerCache(ServerCache serverCache) { <nl> + this . serverCache = serverCache ; <nl> + } <nl> - fileLogger . info(decisiveRuleNumber +   + decisiveRule . getClass() . getSimpleName() +   + result +   + uri) ; <nl> + JSONObject extraInfo = null ; <nl> + if (logExtraInfo) { <nl> + CrawlHost crawlHost = getServerCache() . getHostFor(uri . getUURI()) ; <nl> + String host = - ; <nl> + if (crawlHost != null) { <nl> + host  = crawlHost . fixUpName() ; <nl> + } <nl> + extraInfo = new JSONObject() ; <nl> + extraInfo . put(hopPath, uri . getPathFromSeed()) ; <nl> + extraInfo . put(via, uri . getVia()) ; <nl> + extraInfo . put(source, uri . getSourceTag()) ; <nl> + extraInfo . put(host, host) ; <nl> + } <nl> + fileLogger . info(decisiveRuleNumber  <nl> +   decisiveRule . getClass() . getSimpleName()  <nl> +   result  <nl> +   uri <nl> + (extraInfo != null ?   extraInfo : )) ; <nl>",
        "commit_message": "add field extra info to deciderulesequence log , which be a json object with entry for host , via , source and hop path",
        "what": "add field extra info to deciderulesequence log, which be a json object with entry for host, via, source and hop path",
        "why": "enhance logging structure for better tracking and information retrieval",
        "check": "1"
    },
    {
        "commit_time": "2003-02-20 00:25:23-08:00",
        "diff": "mmm Parameter . java <nl> ppp Parameter . java <nl> + public Object getValue() { <nl> + switch (category) { <nl> + case CatNumeric: <nl> + case CatString: <nl> + return ((Literal)exp) . getValue() ; <nl> + default: <nl> + return (Member)exp ; <nl> + } <nl> + } <nl> + public void setValue(Object value) { <nl> + switch (category) { <nl> + case CatNumeric: <nl> + exp = Literal . create((Double)value) ; <nl> + break ; <nl> + case CatString: <nl> + exp = Literal . createString((String)value) ; <nl> + break ; <nl> + default: <nl> + exp = (Member)value ; <nl> + } <nl> + } <nl>",
        "commit_message": "added getvalue/setvalue , so the value of a parameter can be query and modify without invoke the parser",
        "what": "added getvalue/setvalue",
        "why": "so the value of a parameter can be query and modify without invoke the parser",
        "check": "1"
    },
    {
        "commit_time": "2018-11-21 17:30:25-08:00",
        "diff": "mmm ShadowServiceTest . java <nl> ppp ShadowServiceTest . java <nl> + import static org . junit . Assert . fail ; <nl> + import org . robolectric . RuntimeEnvironment ; <nl> - private ShadowService shadow ; <nl> - private final ShadowNotificationManager nm = <nl> - shadowOf( <nl> - (NotificationManager) <nl> - ApplicationProvider . getApplicationContext() <nl> -  . getSystemService(Context . NOTIFICATION_SERVICE)) ; <nl> + NotificationManager nm2 = <nl> + (NotificationManager) <nl> + ApplicationProvider . getApplicationContext() <nl> +  . getSystemService(Context . NOTIFICATION_SERVICE) ; <nl> - shadow = shadowOf(service) ; <nl> - notBuilder = new Notification . Builder(service) <nl> -  . setSmallIcon(1) <nl> -  . setContentTitle(Test) <nl> -  . setContentText(Hi there) ; <nl> + notBuilder = <nl> + new Notification . Builder(service) <nl> +  . setSmallIcon(1) <nl> +  . setContentTitle(Test) <nl> +  . setContentText(Hi there) ; <nl> - ShadowApplication shadowApplication = <nl> - shadowOf((Application) ApplicationProvider . getApplicationContext()) ; <nl> + Application application = (Application) ApplicationProvider . getApplicationContext() ; <nl> - assertThat(shadowApplication . getUnboundServiceConnections()) . isEmpty() ; <nl> + assertThat(shadowOf(application) . getUnboundServiceConnections()) . isEmpty() ; <nl> - assertThat(shadowApplication . getUnboundServiceConnections()) . hasSize(1) ; <nl> + assertThat(shadowOf(application) . getUnboundServiceConnections()) . hasSize(1) ; <nl> - @Test(expected = IllegalArgumentException . class) <nl> + @Test <nl> - ShadowApplication . getInstance() . setUnbindServiceShouldThrowIllegalArgument(true) ; <nl> + shadowOf(RuntimeEnvironment . application) . setUnbindServiceShouldThrowIllegalArgument(true) ; <nl> - service . unbindService(conn) ; <nl> + try { <nl> + service . unbindService(conn) ; <nl> + fail(Should throw) ; <nl> + } catch (IllegalArgumentException e) { <nl> + } <nl> - assertThat(shadow . getLastForegroundNotification()) . isSameAs(n) ; <nl> - assertThat(shadow . getLastForegroundNotificationId()) . isEqualTo(23) ; <nl> - assertThat(nm . getNotification(23)) . isSameAs(n) ; <nl> + assertThat(shadowOf(service) . getLastForegroundNotification()) . isSameAs(n) ; <nl> + assertThat(shadowOf(service) . getLastForegroundNotificationId()) . isEqualTo(23) ; <nl> + assertThat(shadowOf(nm2) . getNotification(23)) . isSameAs(n) ; <nl> - assertThat(shadow . isForegroundStopped()) . isTrue() ; <nl> - assertThat(shadow . getNotificationShouldRemoved()) . isTrue() ; <nl> + assertThat(shadowOf(service) . isForegroundStopped()) . isTrue() ; <nl> + assertThat(shadowOf(service) . getNotificationShouldRemoved()) . isTrue() ; <nl> - assertThat(nm . getNotification(21)) . isNull() ; <nl> + assertThat(shadowOf(nm2) . getNotification(21)) . isNull() ; <nl> - assertThat(nm . getNotification(21)) . isSameAs(n) ; <nl> + assertThat(shadowOf(nm2) . getNotification(21)) . isSameAs(n) ; <nl> - assertThat(nm . getNotification(21)) . isNull() ; <nl> + assertThat(shadowOf(nm2) . getNotification(21)) . isNull() ; <nl> - assertThat(shadow . isStoppedBySelf()) . isTrue() ; <nl> + assertThat(shadowOf(service) . isStoppedBySelf()) . isTrue() ; <nl> - assertThat(shadow . isStoppedBySelf()) . isTrue() ; <nl> + assertThat(shadowOf(service) . isStoppedBySelf()) . isTrue() ; <nl> + assertThat(shadowOf(service) . getStopSelfId()) . isEqualTo(1) ; <nl> - assertThat(shadow . isStoppedBySelf()) . isTrue() ; <nl> + assertThat(shadowOf(service) . isStoppedBySelf()) . isTrue() ; <nl> + assertThat(shadowOf(service) . getStopSelfResultId()) . isEqualTo(1) ; <nl> mmm ShadowService . java <nl> ppp ShadowService . java <nl> + private int stopSelfId ; <nl> + private int stopSelfResultId ; <nl> + stopSelfId = id ; <nl> + stopSelfResultId = id ; <nl> + public int getStopSelfId() { <nl> + return stopSelfId ; <nl> + } <nl> + public int getStopSelfResultId() { <nl> + return stopSelfResultId ; <nl> + } <nl>",
        "commit_message": "refactor the ShadowServiceTest and ShadowService classes to streamline code and improve maintainability to enhance clarity and consistency in the test environment setup and service behavior",
        "what": "refactor the ShadowServiceTest and ShadowService classes to streamline code and improve maintainability",
        "why": "enhance clarity and consistency in the test environment setup and service behavior",
        "check": "1"
    },
    {
        "commit_time": "2024-01-31 10:40:34+08:00",
        "diff": "mmm GitHelper . java <nl> ppp GitHelper . java <nl> + if (null == objectId) { <nl> + return  ; <nl> + } <nl>",
        "commit_message": "fix : : bug : git initialization of a project report a null pointer error when not commit",
        "what": "fix bug in git initialization of a project",
        "why": "report a null pointer error when not commit",
        "check": "1"
    },
    {
        "commit_time": "2016-09-19 21:43:54+00:00",
        "diff": "mmm WidgetsContainerView . java <nl> ppp WidgetsContainerView . java <nl> + import com . android . launcher3 . util . TransformingTouchDelegate ; <nl> - private final Rect mTmpRect = new Rect() ; <nl> + private TransformingTouchDelegate mRecyclerViewTouchDelegate ; <nl> + @Override <nl> + protected void onLayout(boolean changed, int left, int top, int right, int bottom) { <nl> + super . onLayout(changed, left, top, right, bottom) ; <nl> + getRevealView() . getBackground() . getPadding(mTmpBgPaddingRect) ; <nl> + mRecyclerViewTouchDelegate . setBounds( <nl> + mRecyclerView . getLeft() - mTmpBgPaddingRect . left, <nl> + mRecyclerView . getTop() - mTmpBgPaddingRect . top, <nl> + mRecyclerView . getRight() mTmpBgPaddingRect . right, <nl> + mRecyclerView . getBottom() mTmpBgPaddingRect . bottom) ; <nl> + } <nl> + mRecyclerViewTouchDelegate = new TransformingTouchDelegate(mRecyclerView) ; <nl> - protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { <nl> - getRevealView() . getBackground() . getPadding(mTmpBgPaddingRect) ; <nl> - if (Utilities . isRtl(getResources())) { <nl> - getContentView() . setPadding(0, mTmpBgPaddingRect . top, mTmpBgPaddingRect . right, <nl> - mTmpBgPaddingRect . bottom) ; <nl> - mTmpRect . set(mTmpBgPaddingRect . left, 0, 0, 0) ; <nl> - mRecyclerView . updateBackgroundPadding(mTmpRect) ; <nl> - } else { <nl> - getContentView() . setPadding(mTmpBgPaddingRect . left, mTmpBgPaddingRect . top, 0, <nl> - mTmpBgPaddingRect . bottom) ; <nl> - mTmpRect . set(0, 0, mTmpBgPaddingRect . right, 0) ; <nl> - mRecyclerView . updateBackgroundPadding(mTmpRect) ; <nl> - } <nl> - super . onMeasure(widthMeasureSpec, heightMeasureSpec) ; <nl> + protected void onAttachedToWindow() { <nl> + super . onAttachedToWindow() ; <nl> + ((View) mRecyclerView . getParent()) . setTouchDelegate(mRecyclerViewTouchDelegate) ; <nl>",
        "commit_message": "introduced TransformingTouchDelegate for RecyclerView touch handling and updated layout management to enhance touch responsiveness and improve layout padding management for better user experience",
        "what": "introduced TransformingTouchDelegate for RecyclerView touch handling and updated layout management",
        "why": "enhance touch responsiveness and improve layout padding management for better user experience",
        "check": "1"
    },
    {
        "commit_time": "2015-11-13 00:51:57+00:00",
        "diff": "mmm ReceiverTest . java <nl> ppp ReceiverTest . java <nl> - @Test <nl> + @Test(timeout = 10000) <nl> - final InetSocketAddress rcvAddress = (InetSocketAddress)senderChannel . receive(rcvBuffer) ; <nl> + InetSocketAddress rcvAddress ; <nl> + do <nl> + { <nl> + rcvAddress = (InetSocketAddress)senderChannel . receive(rcvBuffer) ; <nl> + } <nl> + while (null == rcvAddress) ; <nl>",
        "commit_message": "[ java ] : try to prevent race in receiver test on window by retry with a timeout . issue # 221 .",
        "what": "try to prevent race in receiver test on window by retry with a timeout",
        "why": "issue # 221",
        "check": "0"
    },
    {
        "commit_time": "2020-05-12 14:43:47+02:00",
        "diff": "mmm MediaSessionConnector . java <nl> ppp MediaSessionConnector . java <nl> - return PlaybackStateCompat . STATE_BUFFERING ; <nl> + return playWhenReady <nl> + ? PlaybackStateCompat . STATE_BUFFERING <nl> + : PlaybackStateCompat . STATE_PAUSED ; <nl>",
        "commit_message": "keep the paused state during buffer without playwhenready .",
        "what": "keep the paused state during buffer",
        "why": "without playwhenready",
        "check": "0"
    },
    {
        "commit_time": "2022-09-30 10:49:31+02:00",
        "diff": "mmm ServiceIpcIngressMessageTest . java <nl> ppp ServiceIpcIngressMessageTest . java <nl> + import io . aeron . test . EventLogExtension ; <nl> - @ExtendWith(InterruptingTestCallback . class) <nl> + @ExtendWith({ EventLogExtension . class, InterruptingTestCallback . class }) <nl>",
        "commit_message": "[ java ] add eventlogextension so that the cluster log be capture .",
        "what": "add eventlogextension",
        "why": "so that the cluster log be captured",
        "check": "1"
    },
    {
        "commit_time": "2013-07-10 18:14:35-07:00",
        "diff": "mmm AuthProvider . java <nl> ppp AuthProvider . java <nl> + private static final long serialVersionUID = 4197859053084546461L ; <nl> mmm P11Key . java <nl> ppp P11Key . java <nl> + private static final long serialVersionUID = -2575874101938349339L ; <nl>",
        "commit_message": "added serialVersionUID fields to AuthProvider and P11Key classes to ensure proper serialization and version control for these classes",
        "what": "added serialVersionUID fields to AuthProvider and P11Key classes",
        "why": "ensure proper serialization and version control for these classes",
        "check": "1"
    },
    {
        "commit_time": "2018-10-28 08:24:22-07:00",
        "diff": "mmm TimestampUtils . java <nl> ppp TimestampUtils . java <nl> + import java . time . format . DateTimeParseException ; <nl> + private static final int DATE_LENGTH = YYYY-MM-DD . length() ; <nl> + public static Timestamp stringToTimestamp(String s) { <nl> + s = s . trim() ; <nl> + if (s . length() == DATE_LENGTH) { <nl> + return Timestamp . ofEpochMilli(Date . valueOf(s) . toEpochMilli()) ; <nl> + } <nl> + try { <nl> + return Timestamp . valueOf(s) ; <nl> + } catch (IllegalArgumentException eT) { <nl> + try { <nl> + return Timestamp . valueOf( <nl> + TimestampTZUtil . parse(s) . getZonedDateTime() . toLocalDateTime() . toString()) ; <nl> + } catch (IllegalArgumentException | DateTimeParseException eTZ) { <nl> + return Timestamp . ofEpochMilli(Date . valueOf(s) . toEpochMilli()) ; <nl> + } <nl> + } <nl> + } <nl> mmm PrimitiveObjectInspectorUtils . java <nl> ppp PrimitiveObjectInspectorUtils . java <nl> - import java . time . DateTimeException ; <nl> - private final static int DATE_LENGTH = YYYY-MM-DD . length() ; <nl> + private final static int DATE_LENGTH = YYYY-MM-DD . length() ; <nl> - Timestamp result = null ; <nl> - if (s . length() == DATE_LENGTH) { <nl> - return Timestamp . ofEpochMilli(Date . valueOf(s) . toEpochMilli()) ; <nl> - } else if (isValidTimeStamp(s)) { <nl> - return Timestamp . valueOf(s) ; <nl> - } <nl> - if (s . contains(+) || (s . length() > DATE_LENGTH && s . charAt(DATE_LENGTH) == '-')) { <nl> - try { <nl> - result = Timestamp . valueOf(TimestampTZUtil . parse(s) . getZonedDateTime() <nl> -  . toLocalDateTime() . toString()) ; <nl> - } catch (DateTimeException e2) { <nl> - } <nl> - } else { <nl> - result = Timestamp . ofEpochMilli(Date . valueOf(s) . toEpochMilli()) ; <nl> - } <nl> + return TimestampUtils . stringToTimestamp(s) ; <nl> + return null ; <nl> - return result ; <nl> - int secondSpace = firstSpace < 0 ? -1 : s . indexOf(' ', firstSpace + 1) ; <nl> - int maxLength = secondSpace == -1 ? s . length() : secondSpace ; <nl> + int secondSpaceOrPlus = firstSpace < 0 ? -1 : s . indexOf(' ', firstSpace 1) ; <nl> + secondSpaceOrPlus = firstSpace < 0 || secondSpaceOrPlus != -1 ? <nl> + secondSpaceOrPlus : s . indexOf('+', firstSpace 1) ; <nl> + int maxLength = secondSpaceOrPlus == -1 ? s . length() : secondSpaceOrPlus ; <nl>",
        "commit_message": "refactor timestamp parsing logic into a new method stringToTimestamp in TimestampUtils to improve code readability and maintainability by encapsulating timestamp conversion logic",
        "what": "refactor timestamp parsing logic into a new method stringToTimestamp in TimestampUtils",
        "why": "improve code readability and maintainability by encapsulating timestamp conversion logic",
        "check": "1"
    },
    {
        "commit_time": "2011-07-30 14:07:48+00:00",
        "diff": "mmm ShapefileReader . java <nl> ppp ShapefileReader . java <nl> - shape = handler . read(buffer, type, flatGeometry) ; <nl> + if (type == ShapeType . NULL) { <nl> + shape = null ; <nl> + } else { <nl> + shape = handler . read(buffer, type, flatGeometry) ; <nl> + } <nl> mmm ShapefileTest . java <nl> ppp ShapefileTest . java <nl> + import java . io . Serializable ; <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + import org . geotools . data . FeatureWriter ; <nl> + import org . geotools . data . Transaction ; <nl> + import org . geotools . feature . simple . SimpleFeatureTypeBuilder ; <nl> + import org . opengis . feature . simple . SimpleFeature ; <nl> + import com . vividsolutions . jts . geom . Point ; <nl> + public void testNullGeometries() throws Exception { <nl> + Map<String, Serializable> params = new HashMap<String, Serializable>() ; <nl> + File tmp = File . createTempFile(test,  . dbf) ; <nl> + if (!tmp . delete()) { <nl> + throw new IllegalStateException(Unable to clear temp file) ; <nl> + } <nl> + URL shpUrl = tmp . toURI() . toURL() ; <nl> + params . put(url, shpUrl) ; <nl> + ShapefileDataStore ds = (ShapefileDataStore) new ShapefileDataStoreFactory() <nl> +  . createNewDataStore(params) ; <nl> + SimpleFeatureTypeBuilder tb = new SimpleFeatureTypeBuilder() ; <nl> + tb . setName(shapefile) ; <nl> + tb . add(the_geom, Point . class) ; <nl> + ds . createSchema(tb . buildFeatureType()) ; <nl> + Transaction transaction = Transaction . AUTO_COMMIT ; <nl> + FeatureWriter<SimpleFeatureType, SimpleFeature> writer = ds <nl> +  . getFeatureWriter(transaction) ; <nl> + SimpleFeature feature = writer . next() ; <nl> + feature . setAttribute(0, null) ; <nl> + writer . close() ; <nl> + transaction . commit() ; <nl> + ds . dispose() ; <nl> + ShpFiles shpFiles = new ShpFiles(shpUrl) ; <nl> + ShapefileReader reader = new ShapefileReader(shpFiles, false, true, <nl> + new GeometryFactory(), false) ; <nl> + try { <nl> + assertTrue(reader . hasNext()) ; <nl> + assertTrue(reader . nextRecord() . shape() == null) ; <nl> + } finally { <nl> + reader . close() ; <nl> + } <nl> + } <nl>",
        "commit_message": "[ geot-3759 ] shapefilereader do not return null on null shapefile record",
        "what": "shapefilereader do not return null on null shapefile record",
        "why": "prevent returning null on invalid input",
        "check": "1"
    },
    {
        "commit_time": "2015-08-14 23:30:52+00:00",
        "diff": "mmm BKDTreeWriter . java <nl> ppp BKDTreeWriter . java <nl> - IOUtils . closeWhileHandlingException(reader) ; <nl> + IOUtils . closeWhileHandlingException(sortedWriter, reader) ; <nl> + sorted . close() ; <nl> mmm HeapLatLonWriter . java <nl> ppp HeapLatLonWriter . java <nl> + private boolean closed ; <nl> + assert closed ; <nl> + closed = true ; <nl> mmm OfflineLatLonWriter . java <nl> ppp OfflineLatLonWriter . java <nl> + private boolean closed ; <nl> + assert closed ; <nl> + closed = true ; <nl> mmm HeapSliceWriter . java <nl> ppp HeapSliceWriter . java <nl> + private boolean closed ; <nl> + assert closed ; <nl> + closed = true ; <nl> mmm OfflineSliceWriter . java <nl> ppp OfflineSliceWriter . java <nl> + private boolean closed ; <nl> + assert closed ; <nl> + closed = true ; <nl> mmm RangeTreeWriter . java <nl> ppp RangeTreeWriter . java <nl> - IOUtils . closeWhileHandlingException(reader) ; <nl> + IOUtils . closeWhileHandlingException(sortedWriter, reader) ; <nl> + sorted . close() ; <nl> + writer . close() ; <nl>",
        "commit_message": "range/bkdtree : add miss closing , when handle exc ; add further asserts",
        "what": "add miss closing , when handle exc ; add further asserts",
        "why": "improve error handling and validation in the code",
        "check": "1"
    },
    {
        "commit_time": "2020-08-16 20:44:11+02:00",
        "diff": "mmm RobotRulesParser . java <nl> ppp RobotRulesParser . java <nl>  <nl>",
        "commit_message": "updated RobotRulesParser.java file to improve parsing logic and enhance functionality",
        "what": "updated RobotRulesParser.java file",
        "why": "improve parsing logic and enhance functionality",
        "check": "1"
    },
    {
        "commit_time": "2020-06-13 03:27:57+00:00",
        "diff": "mmm BaseSwipeUpHandlerV2 . java <nl> ppp BaseSwipeUpHandlerV2 . java <nl> - private static final int STATE_SCREENSHOT_CAPTURED = <nl> + protected static final int STATE_SCREENSHOT_CAPTURED = <nl> - private void switchToScreenshot() { <nl> + protected void switchToScreenshot() { <nl> mmm FallbackSwipeHandler . java <nl> ppp FallbackSwipeHandler . java <nl> + @Override <nl> + protected void switchToScreenshot() { <nl> + if (mRunningOverHome) { <nl> + mStateCallback . setStateOnUiThread(STATE_SCREENSHOT_CAPTURED) ; <nl> + } else { <nl> + super . switchToScreenshot() ; <nl> + } <nl> + } <nl>",
        "commit_message": "fix recent animation not get complete sometimes when use 3p launcher be : fcad20bad9",
        "what": "fix recent animation not get complete sometimes when use 3p launcher",
        "why": "prevent issues with user experience when using a third-party launcher",
        "check": "1"
    },
    {
        "commit_time": "2021-01-03 11:16:48-08:00",
        "diff": "mmm JavaType . java <nl> ppp JavaType . java <nl> - return type instanceof MultiCatch && <nl> - TypeUtils . deepEquals(throwableTypes, ((MultiCatch) type) . throwableTypes) ; <nl> + return this == type  || (type instanceof MultiCatch && <nl> + TypeUtils . deepEquals(throwableTypes, ((MultiCatch) type) . throwableTypes)) ; <nl> - return type instanceof ShallowClass && <nl> - fullyQualifiedName . equals(((ShallowClass) type) . fullyQualifiedName) ; <nl> + return this == type  || (type instanceof ShallowClass && <nl> + fullyQualifiedName . equals(((ShallowClass) type) . fullyQualifiedName)) ; <nl> - return fullyQualifiedName . equals(c . fullyQualifiedName) && <nl> + return <nl> + this == c || ( <nl> + fullyQualifiedName . equals(c . fullyQualifiedName) && <nl> - TypeUtils . deepEquals(typeParameters, c . typeParameters) ; <nl> + TypeUtils . deepEquals(typeParameters, c . typeParameters)) ; <nl> - return name . equals(v . name) && TypeUtils . deepEquals(this . type, v . type) && <nl> - flags . equals(v . flags) ; <nl> + return this == v  || (name . equals(v . name) && TypeUtils . deepEquals(this . type, v . type) && <nl> + flags . equals(v . flags)) ; <nl> - return s1 == null ? s2 == null : s2 != null && <nl> + return s1 == null ? s2 == null : s1 == s2  || (s2 != null && <nl> - TypeUtils . deepEquals(s1 . paramTypes, s2 . paramTypes) ; <nl> + TypeUtils . deepEquals(s1 . paramTypes, s2 . paramTypes)) ; <nl> - return paramNames . equals(m . paramNames) && <nl> + return this == m || ( <nl> + paramNames . equals(m . paramNames) && <nl> - signatureDeepEquals(resolvedSignature, m . resolvedSignature) ; <nl> + signatureDeepEquals(resolvedSignature, m . resolvedSignature)) ; <nl> - return fullyQualifiedName . equals(generic . fullyQualifiedName) && <nl> - TypeUtils . deepEquals(bound, generic . bound) ; <nl> + return this == generic || (fullyQualifiedName . equals(generic . fullyQualifiedName) && <nl> + TypeUtils . deepEquals(bound, generic . bound)) ; <nl> - return type instanceof Array && elemType != null && elemType . deepEquals(((Array) type) . elemType) ; <nl> + return type instanceof Array && (this == type || (elemType != null && elemType . deepEquals(((Array) type) . elemType))) ; <nl> mmm TypeUtils . java <nl> ppp TypeUtils . java <nl> - return t == null ? t2 == null : t . deepEquals(t2) ; <nl> + return t == null ? t2 == null : t == t2 || t . deepEquals(t2) ; <nl>",
        "commit_message": "add an instance check to reduce the work do in deepequals check .",
        "what": "add an instance check to reduce the work do in deepequals'' check",
        "why": "reduce the work do in deepequals'' check",
        "check": "1"
    },
    {
        "commit_time": "2023-07-19 16:42:22+08:00",
        "diff": "mmm DataSyncConfiguration . java <nl> ppp DataSyncConfiguration . java <nl> + import org . apache . shenyu . common . exception . ShenyuException ; <nl> + import java . net . MalformedURLException ; <nl> + import java . net . URL ; <nl> - return new ConsulClient(consulProperties . getUrl()) ; <nl> + String url = consulProperties . getUrl() ; <nl> + if (StringUtils . isBlank(url)) { <nl> + throw new ShenyuException(sync . consul . url can not be null . ) ; <nl> + } <nl> + try { <nl> + URL consulUrl = new URL(url) ; <nl> + return consulUrl . getPort() < 0 ? new ConsulClient(consulUrl . getHost()) : new ConsulClient(consulUrl . getHost(), consulUrl . getPort()) ; <nl> + } catch (MalformedURLException e) { <nl> + throw new ShenyuException(sync . consul . url formatter is not incorrect . ) ; <nl> + } <nl> mmm DataSyncConfigurationTest . java <nl> ppp DataSyncConfigurationTest . java <nl> - when(consulProperties . getUrl()) . thenReturn(127 . 0 . 0 . 1) ; <nl> + when(consulProperties . getUrl()) . thenReturn(http://127 . 0 . 0 . 1:8500) ; <nl> mmm ConsulSyncDataConfiguration . java <nl> ppp ConsulSyncDataConfiguration . java <nl> + import org . apache . commons . lang3 . StringUtils ; <nl> + import org . apache . shenyu . common . exception . ShenyuException ; <nl> + import java . net . MalformedURLException ; <nl> + import java . net . URL ; <nl> - return new ConsulClient(consulConfig . getUrl()) ; <nl> + String url = consulConfig . getUrl() ; <nl> + if (StringUtils . isBlank(url)) { <nl> + throw new ShenyuException(sync . consul . url can not be null . ) ; <nl> + } <nl> + try { <nl> + URL consulUrl = new URL(url) ; <nl> + return consulUrl . getPort() < 0 ? new ConsulClient(consulUrl . getHost()) : new ConsulClient(consulUrl . getHost(), consulUrl . getPort()) ; <nl> + } catch (MalformedURLException e) { <nl> + throw new ShenyuException(sync . consul . url formatter is not incorrect . ) ; <nl> + } <nl>",
        "commit_message": "fix shenyu mishandle sync.consul.url configuration . ( # 4872 )",
        "what": "fix shenyu mishandle sync.consul.url configuration",
        "why": "( # 4872 )",
        "check": "0"
    },
    {
        "commit_time": "2015-06-12 09:12:20-05:00",
        "diff": "mmm InfoServer . java <nl> ppp InfoServer . java <nl> + import org . apache . hadoop . hbase . HBaseConfiguration ; <nl> - builder . keyPassword(c . get(ssl . server . keystore . keypassword)) <nl> + builder . keyPassword(HBaseConfiguration . getPassword(c, ssl . server . keystore . keypassword, null)) <nl> - c . get(ssl . server . keystore . password), <nl> + HBaseConfiguration . getPassword(c,ssl . server . keystore . password, null), <nl> - c . get(ssl . server . truststore . password), <nl> + HBaseConfiguration . getPassword(c, ssl . server . truststore . password, null), <nl> mmm TestSSLHttpServer . java <nl> ppp TestSSLHttpServer . java <nl> + import org . apache . hadoop . hbase . HBaseConfiguration ; <nl> -  . keyPassword(sslConf . get(ssl . server . keystore . keypassword)) <nl> +  . keyPassword(HBaseConfiguration . getPassword(sslConf, ssl . server . keystore . keypassword, <nl> + null)) <nl> - sslConf . get(ssl . server . keystore . password), <nl> + HBaseConfiguration . getPassword(sslConf, ssl . server . keystore . password, null), <nl> - sslConf . get(ssl . server . truststore . password), <nl> + HBaseConfiguration . getPassword(sslConf, ssl . server . truststore . password, null), <nl>",
        "commit_message": "hbase-13848 use credential provider when available for ssl password in infoserver .",
        "what": "use credential provider when available for ssl password in infoserver",
        "why": "hbase-13848",
        "check": "0"
    },
    {
        "commit_time": "2013-10-11 18:41:07+02:00",
        "diff": "mmm VerificationOverTimeImpl . java <nl> ppp VerificationOverTimeImpl . java <nl> - private final int pollingPeriod ; <nl> + private final int pollingPeriodMillis ; <nl> - public VerificationOverTimeImpl(int pollingPeriod, int durationMillis, VerificationMode delegate, boolean returnOnSuccess) { <nl> - this . pollingPeriod = pollingPeriod ; <nl> + public VerificationOverTimeImpl(int pollingPeriodMillis, int durationMillis, VerificationMode delegate, boolean returnOnSuccess) { <nl> + this . pollingPeriodMillis = pollingPeriodMillis ; <nl> - sleep(pollingPeriod) ; <nl> + sleep(pollingPeriodMillis) ; <nl> - return pollingPeriod ; <nl> + return pollingPeriodMillis ; <nl> mmm Timeout . java <nl> ppp Timeout . java <nl> - Timeout(int pollingPeriod, int millis, VerificationMode delegate) {\r <nl> - super(new VerificationOverTimeImpl(pollingPeriod, millis, delegate, true)) ;\r <nl> + Timeout(int pollingPeriodMillis, int millis, VerificationMode delegate) {\r <nl> + super(new VerificationOverTimeImpl(pollingPeriodMillis, millis, delegate, true)) ;\r <nl> - @Override <nl> - protected VerificationMode copySelfWithNewVerificationMode(VerificationMode newVerificationMode) { <nl> - return new Timeout(wrappedVerification . getPollingPeriod(), wrappedVerification . getDuration(), newVerificationMode) ; <nl> + @Override\r <nl> + protected VerificationMode copySelfWithNewVerificationMode(VerificationMode newVerificationMode) {\r <nl> + return new Timeout(wrappedVerification . getPollingPeriod(), wrappedVerification . getDuration(), newVerificationMode) ; <nl>",
        "commit_message": "rename pollingPeriod to pollingPeriodMillis for clarity on unit to improve code readability and accuracy in representing time intervals in milliseconds",
        "what": "rename pollingPeriod to pollingPeriodMillis for clarity on unit",
        "why": "improve code readability and accuracy in representing time intervals in milliseconds",
        "check": "1"
    },
    {
        "commit_time": "2023-12-28 09:11:55+01:00",
        "diff": "mmm AnnotationService . java <nl> ppp AnnotationService . java <nl> - List<J . Annotation> annotations = new ArrayList<>(annotatedType . getAnnotations() . size()) ; <nl> + List<J . Annotation> targetAnnotations = getAllAnnotations(annotatedType . getTypeExpression()) ; <nl> + if (targetAnnotations . isEmpty()) { <nl> + return annotatedType . getAnnotations() ; <nl> + } <nl> + List<J . Annotation> annotations = new ArrayList<>(annotatedType . getAnnotations() . size() targetAnnotations . size()) ; <nl> - annotations . addAll(getAllAnnotations(annotatedType . getTypeExpression())) ; <nl> + annotations . addAll(targetAnnotations) ; <nl> - List<J . Annotation> annotations = new ArrayList<>(arrayType . getAnnotations() == null ? 0 : arrayType . getAnnotations() . size()) ; <nl> - annotations . addAll(arrayType . getAnnotations()) ; <nl> + return arrayType . getAnnotations() ; <nl> - return annotations ; <nl> + return emptyList() ; <nl>",
        "commit_message": "replaced the variable name for annotations to targetAnnotations and adjusted the logic for handling empty annotations to improve clarity and efficiency in retrieving and returning annotations",
        "what": "replaced the variable name for annotations to targetAnnotations and adjusted the logic for handling empty annotations",
        "why": "improve clarity and efficiency in retrieving and returning annotations",
        "check": "1"
    },
    {
        "commit_time": "2013-06-07 21:19:56+02:00",
        "diff": "mmm G3dModelLoader . java <nl> ppp G3dModelLoader . java <nl> - jsonTexture . fileName = materialDir + (materialDir . endsWith(/) ?  : /) + fileName ; <nl> + jsonTexture . fileName = materialDir (materialDir . length() == 0 || materialDir . endsWith(/) ?  : /) fileName ; <nl>",
        "commit_message": "updated the filename assignment logic for the jsonTexture in G3dModelLoader to ensure correct formatting of the filename based on the material directory state",
        "what": "updated the filename assignment logic for the jsonTexture in G3dModelLoader",
        "why": "ensure correct formatting of the filename based on the material directory state",
        "check": "1"
    },
    {
        "commit_time": "2017-01-30 10:42:13+00:00",
        "diff": "mmm MergeAcroFormsTest . java <nl> ppp MergeAcroFormsTest . java <nl> + import org . apache . pdfbox . pdmodel . interactive . form . PDAcroForm ; <nl> + import org . apache . pdfbox . pdmodel . interactive . form . PDField ; <nl> + mergedPDF . close() ; <nl> + }     <nl> + @Test <nl> + public void testAPEntry() throws IOException { <nl> + PDFMergerUtility merger = new PDFMergerUtility() ; <nl> + URL url1 = new URL(https://issues . apache . org/jira/secure/attachment/12490774/a . pdf) ; <nl> + InputStream is1 = url1 . openStream() ; <nl> + URL url2 = new URL(https://issues . apache . org/jira/secure/attachment/12490775/b . pdf) ; <nl> + InputStream is2 = url2 . openStream() ; <nl> + File pdfOutput = new File(OUT_DIR,PDFBOX-1100 . pdf) ; <nl> + merger . setDestinationFileName(pdfOutput . getAbsolutePath()) ; <nl> + merger . addSource(is1) ; <nl> + merger . addSource(is2) ; <nl> + merger . mergeDocuments(null) ; <nl> + PDDocument mergedPDF = PDDocument . load(pdfOutput) ; <nl> + assertEquals(There shall be 2 pages, 2, mergedPDF . getNumberOfPages()) ; <nl> + PDAcroForm acroForm = mergedPDF . getDocumentCatalog() . getAcroForm() ; <nl> + PDField formField = acroForm . getField(Testfeld) ; <nl> + assertNotNull(There shall be an /AP entry for the field, formField . getCOSObject() . getDictionaryObject(COSName . AP)) ; <nl> + assertNotNull(There shall be a /V entry for the field, formField . getCOSObject() . getDictionaryObject(COSName . V)) ; <nl> + formField = acroForm . getField(Testfeld2) ; <nl> + assertNotNull(There shall be an /AP entry for the field, formField . getCOSObject() . getDictionaryObject(COSName . AP)) ; <nl> + assertNotNull(There shall be a /V entry for the field, formField . getCOSObject() . getDictionaryObject(COSName . V)) ; <nl>",
        "commit_message": "pdfbox-1100 : add unit test to ensure /ap and /v entry",
        "what": "add unit test to ensure /ap and /v entry",
        "why": "pdfbox-1100",
        "check": "0"
    },
    {
        "commit_time": "2020-07-31 09:12:57+02:00",
        "diff": "mmm OpenTracingSpanAdapter . java <nl> ppp OpenTracingSpanAdapter . java <nl> - span . setTag(Tags . ERROR, error) ; <nl> + span . setTag(Tags . ERROR . getKey(), error) ; <nl> - span . setTag(tagMap . get(key), value) ; <nl> + span . setTag(tagMap . get(key) . getKey(), value) ; <nl> - span . setTag(tagMap . get(key), value) ; <nl> + span . setTag(tagMap . get(key) . getKey(), value) ; <nl> mmm OpenTracingTracer . java <nl> ppp OpenTracingTracer . java <nl> - io . opentracing . util . GlobalTracer . registerIfAbsent(tracer) ; <nl> + if (!io . opentracing . util . GlobalTracer . isRegistered()) { <nl> + io . opentracing . util . GlobalTracer . register(tracer) ; <nl> + } <nl> mmm OpenTracingTracingStrategy . java <nl> ppp OpenTracingTracingStrategy . java <nl> -  . withTag(Tags . COMPONENT, getComponentName(processorDefinition)) <nl> +  . withTag(Tags . COMPONENT . getKey(), getComponentName(processorDefinition)) <nl> - try (final Scope inScope = tracer . getTracer() . activateSpan(processorSpan)) { <nl> + try (Scope scope = tracer . getTracer() . scopeManager() . activate(processorSpan, true)) { <nl> mmm EIPTracingActiveSpanTest . java <nl> ppp EIPTracingActiveSpanTest . java <nl> + import org . junit . jupiter . api . Disabled ; <nl> - import org . junit . jupiter . api . extension . ExtensionContext ; <nl> + @Disabled <nl> -  . withTag(Tags . COMPONENT, custom-component) <nl> +  . withTag(Tags . COMPONENT . getKey(), custom-component) <nl>",
        "commit_message": "camel-15354 : camel-opentracing - go back to 0.31.0 api of mp opentracing .",
        "what": "go back to 0.31.0 api of mp opentracing",
        "why": "related to camel-15354",
        "check": "1"
    },
    {
        "commit_time": "2016-08-19 15:46:32-07:00",
        "diff": "mmm DefaultMockingDetails . java <nl> ppp DefaultMockingDetails . java <nl> + import org . mockito . exceptions . misusing . NotAMockException ; <nl> - import static org . mockito . internal . util . MockUtil . getMockHandler ; <nl> + import static org . mockito . internal . util . MockUtil . getMockHandler ; <nl> + assertIsMock(toInspect) ; <nl> + private void assertIsMock(Object toInspect) { <nl> + if (toInspect == null) { <nl> + throw new NotAMockException(Argument passed to Mockito . mockingDetails() should be a mock, but is null!) ; <nl> + } else if (!isMock()) { <nl> + throw new NotAMockException(Argument passed to Mockito . mockingDetails() should be a mock, but is an instance of  toInspect . getClass() !) ; <nl> + } <nl> + } <nl> mmm MockingDetailsTest . java <nl> ppp MockingDetailsTest . java <nl> + import org . mockito . exceptions . misusing . NotAMockException ; <nl> + import static org . mockito . Mockito . mockingDetails ; <nl> - public void should_handle_null_input() { <nl> + public void getting_interactions_when_input_mock_is_null() { <nl> + try { <nl> + mockingDetails(null) <nl> +  . getInvocations() ; <nl> + fail() ; <nl> + } catch (NotAMockException e) { <nl> + assertEquals(Argument passed to Mockito . mockingDetails() should be a mock, but is null!, e . getMessage()) ; <nl> + } <nl> + } <nl> + @Test <nl> + public void getting_interactions_when_input_mock_is_not_mock() { <nl> + try { <nl> + mockingDetails(new Object()) <nl> +  . getInvocations() ; <nl> + fail() ; <nl> + } catch (NotAMockException e) { <nl> + assertEquals(Argument passed to Mockito . mockingDetails() should be a mock, but is an instance of class java . lang . Object!, e . getMessage()) ; <nl> + } <nl>",
        "commit_message": "added input validation in DefaultMockingDetails to check for null and non-mock instances to improve error handling by throwing NotAMockException for invalid inputs to mockingDetails()",
        "what": "added input validation in DefaultMockingDetails to check for null and non-mock instances",
        "why": "improve error handling by throwing NotAMockException for invalid inputs to mockingDetails()",
        "check": "1"
    },
    {
        "commit_time": "2018-03-21 12:33:40+05:30",
        "diff": "mmm ApacheHttpClientMediaWikiApi . java <nl> ppp ApacheHttpClientMediaWikiApi . java <nl>  <nl> mmm NotificationActivity . java <nl> ppp NotificationActivity . java <nl> + import android . widget . RelativeLayout ; <nl> - @BindView(R . id . progressBar) <nl> - ProgressBar progressBar ; <nl> + @BindView(R . id . progressBar) ProgressBar progressBar ; <nl> + @BindView(R . id . container) RelativeLayout relativeLayout ; <nl> - ViewUtil . showSnackbar(this, R . string . error_notifications) ; <nl> + ViewUtil . showSnackbar(relativeLayout, R . string . error_notifications) ; <nl> + if(notificationList == null || notificationList . isEmpty()) { <nl> + ViewUtil . showSnackbar(relativeLayout, R . string . no_notifications) ; <nl> + return ; <nl> + } <nl> mmm NotificationRenderer . java <nl> ppp NotificationRenderer . java <nl> - StringBuilder str = new StringBuilder(notification . notificationText) ; <nl> + StringBuilder str = new StringBuilder(notification . notificationText . trim()) ; <nl>",
        "commit_message": "fix crash due to read more text view",
        "what": "fix crash due to read more text view",
        "why": "to resolve a crash issue",
        "check": "1"
    },
    {
        "commit_time": "2023-06-12 18:28:57-07:00",
        "diff": "mmm QuickstepAtomicAnimationFactory . java <nl> ppp QuickstepAtomicAnimationFactory . java <nl> + overview . switchToScreenshot(() -> <nl> + overview . finishRecentsAnimation(true , null)) ; <nl> mmm RecentsView . java <nl> ppp RecentsView . java <nl> - runActionOnRemoteHandles(remoteTargetHandle -> { <nl> - TransformParams params = remoteTargetHandle . getTransformParams() ; <nl> - params . setTargetAlpha(mContentAlpha) ; <nl> - if (params . getTargetSet() != null) { <nl> - remoteTargetHandle . getTaskViewSimulator() . apply(params) ; <nl> - } <nl> - }) ; <nl>",
        "commit_message": "switch animation to screenshot to avoid visual jank",
        "what": "switch animation to screenshot",
        "why": "avoid visual jank",
        "check": "1"
    },
    {
        "commit_time": "2017-08-18 17:34:55+01:00",
        "diff": "mmm AuthenticatedActivity . java <nl> ppp AuthenticatedActivity . java <nl> + import io . reactivex . Single ; <nl> + import io . reactivex . android . schedulers . AndroidSchedulers ; <nl> + import io . reactivex . schedulers . Schedulers ; <nl> - private class GetAuthCookieTask extends AsyncTask<Void, String, String> { <nl> - private Account account ; <nl> - private AccountManager accountManager ; <nl> - public GetAuthCookieTask(Account account, AccountManager accountManager) { <nl> - this . account = account ; <nl> - this . accountManager = accountManager ; <nl> - } <nl> - @Override <nl> - protected void onPostExecute(String result) { <nl> - super . onPostExecute(result) ; <nl> - if(result != null) { <nl> - authCookie = result ; <nl> - onAuthCookieAcquired(result) ; <nl> - } else { <nl> - onAuthFailure() ; <nl> - } <nl> - } <nl> - @Override <nl> - protected String doInBackground(Void .  .  .  params) { <nl> - try { <nl> - return accountManager . blockingGetAuthToken(account, , false) ; <nl> - } catch (OperationCanceledException e) { <nl> - e . printStackTrace() ; <nl> - return null ; <nl> - } catch (AuthenticatorException e) { <nl> - e . printStackTrace() ; <nl> - return null ; <nl> - } catch (IOException e) { <nl> - e . printStackTrace() ; <nl> - return null ; <nl> - } <nl> - } <nl> + private void getAuthCookie(Account account, AccountManager accountManager) { <nl> + Single . fromCallable(() -> accountManager . blockingGetAuthToken(account, , false)) <nl> +  . subscribeOn(Schedulers . io()) <nl> +  . doOnError(Timber::e) <nl> +  . observeOn(AndroidSchedulers . mainThread()) <nl> +  . subscribe( <nl> + cookie -> onAuthCookieAcquired(cookie), <nl> + throwable -> onAuthFailure()) ; <nl> - Account[] allAccounts =accountManager . getAccountsByType(accountType) ; <nl> + Account[] allAccounts = accountManager . getAccountsByType(accountType) ; <nl> - GetAuthCookieTask getCookieTask = new GetAuthCookieTask(curAccount, accountManager) ; <nl> - getCookieTask . execute() ; <nl> + getAuthCookie(curAccount, accountManager) ; <nl> - GetAuthCookieTask task = new GetAuthCookieTask(curAccount, accountManager) ; <nl> - task . execute() ; <nl> + getAuthCookie(curAccount, accountManager) ; <nl>",
        "commit_message": "refactor authentication cookie retrieval from AsyncTask to RxJava implementation to improve code readability and responsiveness by leveraging reactive programming",
        "what": "refactor authentication cookie retrieval from AsyncTask to RxJava implementation",
        "why": "improve code readability and responsiveness by leveraging reactive programming",
        "check": "1"
    },
    {
        "commit_time": "2015-06-26 16:11:25-06:00",
        "diff": "mmm Utils . java <nl> ppp Utils . java <nl> - error(msg) ; <nl> + log . error(msg) ; <nl> mmm TraceHandlerInterceptor . java <nl> ppp TraceHandlerInterceptor . java <nl> - TraceScope scope = trace . startSpan() ; <nl> + TraceScope scope = trace . startSpan(traceHandlerInterceptor) ; <nl> mmm TraceWebAutoConfiguration . java <nl> ppp TraceWebAutoConfiguration . java <nl> - @Bean <nl> + @Bean <nl> + @ConditionalOnMissingBean <nl> + public FilterRegistrationBean traceFilter() { <nl> + Pattern pattern = StringUtils . hasText(skipPattern) ? Pattern . compile(skipPattern) <nl> + : TraceFilter . DEFAULT_SKIP_PATTERN ; <nl> + return new FilterRegistrationBean(new TraceFilter(trace, pattern)) ; <nl>",
        "commit_message": "updated error logging method and improved trace span naming in multiple classes to enhance error tracking consistency and provide clearer context for trace spans",
        "what": "updated error logging method and improved trace span naming in multiple classes",
        "why": "enhance error tracking consistency and provide clearer context for trace spans",
        "check": "1"
    },
    {
        "commit_time": "2011-08-11 15:00:26+00:00",
        "diff": "mmm PraatPitchTierTest . java <nl> ppp PraatPitchTierTest . java <nl> - Reader pitchTierFile = new InputStreamReader(getClass() . getResourceAsStream(pop001 . PitchTier), UTF-8) ; <nl> - pt = new PraatPitchTier(pitchTierFile) ; <nl> + Reader shortPitchTierFile = new InputStreamReader(getClass() . getResourceAsStream(pop001_short . PitchTier), UTF-8) ; <nl> + pt = new PraatPitchTier(shortPitchTierFile) ; <nl>",
        "commit_message": "prepare to add default format of praat pitchtier file for test",
        "what": "prepare to add default format of praat pitchtier file",
        "why": "for test",
        "check": "1"
    },
    {
        "commit_time": "2017-03-08 12:43:44-08:00",
        "diff": "mmm ConfigurationTest . java <nl> ppp ConfigurationTest . java <nl> - Assert . assertTrue(corePoolSize > 2 && corePoolSize <= 32) ; <nl> + Assert . assertTrue(corePoolSize > 2 && corePoolSize <= 128) ; <nl> - Assert . assertTrue(corePoolSize > 2 && corePoolSize <= 32) ; <nl> + Assert . assertTrue(corePoolSize > 2 && corePoolSize <= 128) ; <nl>",
        "commit_message": "updated the core pool size assertion in ConfigurationTest.java to allow a maximum of 128 to support a wider range of configurations for pool size settings",
        "what": "updated the core pool size assertion in ConfigurationTest.java to allow a maximum of 128",
        "why": "support a wider range of configurations for pool size settings",
        "check": "1"
    },
    {
        "commit_time": "2022-10-05 13:59:17+13:00",
        "diff": "mmm PMS . java <nl> ppp PMS . java <nl> - LOGGER . debug(Error initializing plugin credentials: {}, e) ; <nl> + LOGGER . debug(Error initializing credentials file: {}, e) ; <nl> mmm DLNAMediaInfo . java <nl> ppp DLNAMediaInfo . java <nl> - @SuppressWarnings(checkstyle:EmptyBlock) <nl> mmm RootFolder . java <nl> ppp RootFolder . java <nl> - if ((ENTRY_DELETE . equals(event) || ENTRY_CREATE . equals(event)) && PMS . getConfiguration() . getUseCache()) { <nl> + if ((ENTRY_DELETE . equals(event) || ENTRY_CREATE . equals(event) || ENTRY_MODIFY . equals(event)) && PMS . getConfiguration() . getUseCache()) { <nl> - } else if (ENTRY_CREATE . equals(event)) { <nl> + } else { <nl> + if (!file . exists()) { <nl> + LOGGER . trace(Not parsing file that no longer exists) ; <nl> + return ; <nl> + } <nl> + if (FileUtil . isLocked(file)) { <nl> + LOGGER . debug(File will not be parsed because it is open in another process) ; <nl> + return ; <nl> + } <nl> mmm FFMpegVideo . java <nl> ppp FFMpegVideo . java <nl> - @SuppressWarnings(checkstyle:EmptyBlock) <nl> mmm ProcessManager . java <nl> ppp ProcessManager . java <nl> - @SuppressWarnings(checkstyle:EmptyBlock) <nl> mmm FileUtil . java <nl> ppp FileUtil . java <nl> + public static final boolean isLocked(File file) { <nl> + try (RandomAccessFile srcFile = new RandomAccessFile(file, rw)) { <nl> + return false ; <nl> + } catch (Exception e) { <nl> + return true ; <nl> + } <nl> + } <nl> mmm FileWatcher . java <nl> ppp FileWatcher . java <nl> - isDir = Files <nl> -  . isDirectory(filename) ; <nl> + isDir = Files . isDirectory(filename) ; <nl> - notifier . schedule(new Notice(filename . toString(), kind . toString(), w, isDir), <nl> - kind == ENTRY_MODIFY ? 500 : 0) ; <nl> + notifier . schedule( <nl> + new Notice(filename . toString(), kind . toString(), w, isDir), <nl> + kind == ENTRY_MODIFY ? 500 : 0 <nl> + ) ; <nl>",
        "commit_message": "fixed fail parsing of file be moved/copied/modified ( # 3464 )",
        "what": "fixed fail parsing of file be moved/copied/modified",
        "why": "( # 3464 )",
        "check": "0"
    },
    {
        "commit_time": "2009-01-06 18:27:07+00:00",
        "diff": "mmm TerminalBridge . java <nl> ppp TerminalBridge . java <nl> - protected void outputLine(String line) { <nl> + protected synchronized void outputLine(String line) { <nl> - if(disconnectListener != null) <nl> - disconnectListener . onDisconnected(this) ; <nl> - ((vt320) buffer) . reset() ; <nl> + ((vt320) buffer) . reset() ; <nl>",
        "commit_message": "added synchronization to the outputLine method and removed the disconnect listener call to ensure thread safety during output operations and streamline the method's logic",
        "what": "added synchronization to the outputLine method and removed the disconnect listener call",
        "why": "ensure thread safety during output operations and streamline the method's logic",
        "check": "1"
    },
    {
        "commit_time": "2019-07-16 16:02:52-07:00",
        "diff": "new file <nl> ppp ItemParticleData . java . patch <nl> + --- a/net/minecraft/particles/ItemParticleData . java <nl> + @@ -28,7 +28,7 @@ <nl> + public ItemParticleData(ParticleType<ItemParticleData> p_i47952_1_, ItemStack p_i47952_2_) { <nl> + this . field_197558_b = p_i47952_1_ ; <nl> + -      this . field_197559_c = p_i47952_2_ ; <nl> +      this . field_197559_c = p_i47952_2_ . func_77946_l() ; //Forge: Fix stack updating after the fact causing particle changes .  <nl> + } <nl> + public void func_197553_a(PacketBuffer p_197553_1_) { <nl>",
        "commit_message": "fixed item break particle not capture current state of the itemstack . close # 5934",
        "what": "fixed item break particle not capture current state of the itemstack",
        "why": "close # 5934",
        "check": "1"
    },
    {
        "commit_time": "2009-08-18 16:04:18+00:00",
        "diff": "mmm ServiceLocator . java <nl> ppp ServiceLocator . java <nl> + import java . util . zip . ZipException ;\r <nl> - JarFile jarFile = new JarFile(zipfile) ;\r <nl> - Enumeration<JarEntry> entries = jarFile . entries() ;\r <nl> - while (entries . hasMoreElements()) {\r <nl> - JarEntry entry = entries . nextElement() ;\r <nl> - if (entry . getName() . startsWith(packageName . replaceAll(\\\\ . , /)) && entry . getName() . endsWith( . class)) {\r <nl> - potentialClassNames . add(entry . getName() . replaceAll(\\\\/,  . ) . substring(0, entry . getName() . length()  . class . length())) ;\r <nl> + try {\r <nl> + JarFile jarFile = new JarFile(zipfile) ;\r <nl> + Enumeration<JarEntry> entries = jarFile . entries() ;\r <nl> + while (entries . hasMoreElements()) {\r <nl> + JarEntry entry = entries . nextElement() ;\r <nl> + if (entry . getName() . startsWith(packageName . replaceAll(\\\\ . , /)) && entry . getName() . endsWith( . class)) {\r <nl> + potentialClassNames . add(entry . getName() . replaceAll(\\\\/,  . ) . substring(0, entry . getName() . length() -  . class . length())) ;\r <nl> + }\r <nl> + catch(ZipException e) {\r <nl> + throw (ZipException) new ZipException(e . getMessage()  for  zipfile) . initCause(e) ;\r <nl> + } <nl>",
        "commit_message": "added error handling for ZipException in ServiceLocator.java to enhance robustness by ensuring that ZipExceptions are caught and properly reported",
        "what": "added error handling for ZipException in ServiceLocator.java",
        "why": "enhance robustness by ensuring that ZipExceptions are caught and properly reported",
        "check": "1"
    },
    {
        "commit_time": "2014-11-16 14:10:40+01:00",
        "diff": "mmm FreeTypeFontGeneratorLoader . java <nl> ppp FreeTypeFontGeneratorLoader . java <nl> - FreeTypeFontGenerator generator = new FreeTypeFontGenerator(file) ; <nl> + FreeTypeFontGenerator generator = new FreeTypeFontGenerator(file . sibling(file . name() . substring(0, file . name() . length() - 4))) ; <nl> mmm FreetypeFontLoader . java <nl> ppp FreetypeFontLoader . java <nl> - FreeTypeFontGenerator generator = manager . get(parameter . fontFileName, FreeTypeFontGenerator . class) ;\t <nl> + FreeTypeFontGenerator generator = manager . get(parameter . fontFileName  . gen, FreeTypeFontGenerator . class) ;\t <nl> - deps . add(new AssetDescriptor<FreeTypeFontGenerator>(parameter . fontFileName, FreeTypeFontGenerator . class)) ; <nl> + deps . add(new AssetDescriptor<FreeTypeFontGenerator>(parameter . fontFileName  . gen, FreeTypeFontGenerator . class)) ; <nl> mmm LwjglDebugStarter . java <nl> ppp LwjglDebugStarter . java <nl> + import com . badlogic . gdx . tests . FreeTypeFontLoaderTest ;\r <nl> + import com . badlogic . gdx . tests . Issue2465 ;\r <nl> - GdxTest test = new BulletTestCollection() ;\t\t\r <nl> + GdxTest test = new FreeTypeFontLoaderTest() ; <nl>",
        "commit_message": "updated FreeTypeFontGenerator initialization and modified asset descriptor parameters to include a .gen suffix to ensure compatibility with updated font file naming conventions",
        "what": "updated FreeTypeFontGenerator initialization and modified asset descriptor parameters to include a .gen suffix",
        "why": "ensure compatibility with updated font file naming conventions",
        "check": "1"
    },
    {
        "commit_time": "2022-08-26 09:56:25+02:00",
        "diff": "mmm Initiator . java <nl> ppp Initiator . java <nl> + boolean exceptionally = false ; <nl> - long compactionInterval = (prevStart <= 0) ? prevStart : (startedAt prevStart) / 1000 ; <nl> - txnHandler . findPotentialCompactions(abortedThreshold, abortedTimeThreshold, compactionInterval) <nl> + txnHandler . findPotentialCompactions(abortedThreshold, abortedTimeThreshold, prevStart) <nl> + exceptionally = true ; <nl> - handle . releaseLocks(startedAt) ; <nl> + if (!exceptionally) handle . releaseLocks(startedAt) ; else handle . releaseLocks() ; <nl> mmm TestCompactionTxnHandler . java <nl> ppp TestCompactionTxnHandler . java <nl> + import java . time . Instant ; <nl> - potentials = txnHandler . findPotentialCompactions(100, -1, 1) ; <nl> + potentials = txnHandler . findPotentialCompactions(100, -1,  <nl> + Instant . now() . minusSeconds(1) . toEpochMilli()) ; <nl> - potentials = txnHandler . findPotentialCompactions(100, -1, 1) ; <nl> + potentials = txnHandler . findPotentialCompactions(100, -1,  <nl> + Instant . now() . minusSeconds(1) . toEpochMilli()) ; <nl> - potentials = txnHandler . findPotentialCompactions(100, -1, 1) ; <nl> + potentials = txnHandler . findPotentialCompactions(100, -1,  <nl> + Instant . now() . minusSeconds(1) . toEpochMilli()) ; <nl> mmm CompactionTxnHandler . java <nl> ppp CompactionTxnHandler . java <nl> - long abortedTimeThreshold, long checkInterval) throws MetaException { <nl> + long abortedTimeThreshold, long lastChecked) throws MetaException { <nl> + long startedAt = System . currentTimeMillis() ; <nl> + long checkInterval = (lastChecked <= 0) ? lastChecked : (startedAt - lastChecked 500) / 1000 ; <nl> - return findPotentialCompactions(abortedThreshold, abortedTimeThreshold, checkInterval) ; <nl> + return findPotentialCompactions(abortedThreshold, abortedTimeThreshold, lastChecked) ; <nl> mmm TxnStore . java <nl> ppp TxnStore . java <nl> - Set<CompactionInfo> findPotentialCompactions(int abortedThreshold, long abortedTimeThreshold, long checkInterval) <nl> + Set<CompactionInfo> findPotentialCompactions(int abortedThreshold, long abortedTimeThreshold, long lastChecked) <nl>",
        "commit_message": "updated method parameters and logic to utilize timestamps instead of static values for potential compactions to improve accuracy and reliability of potential compaction metrics",
        "what": "updated method parameters and logic to utilize timestamps instead of static values for potential compactions",
        "why": "improve accuracy and reliability of potential compaction metrics",
        "check": "1"
    },
    {
        "commit_time": "2023-11-06 11:45:11+01:00",
        "diff": "mmm RoutingInBoundHandler . java <nl> ppp RoutingInBoundHandler . java <nl> - if (request . getNativeRequest() instanceof StreamedHttpRequest streamed && !streamed . isConsumed()) { <nl> - Flux . from(streamed) . subscribe(HttpContent::release) ; <nl> - } <nl>",
        "commit_message": "more efficient discard when request body be ignore ( # 10067 )",
        "what": "more efficient discard when request body be ignore",
        "why": "relates to issue #10067",
        "check": "1"
    },
    {
        "commit_time": "2011-03-04 07:12:40+00:00",
        "diff": "new file <nl> ppp Jt400PgmCallException . java <nl> + package org . apache . camel . component . jt400 ; <nl> + import org . apache . camel . RuntimeCamelException ; <nl> + public class Jt400PgmCallException extends RuntimeCamelException { <nl> + private static final long serialVersionUID = 1112933724598115479L ; <nl> + public Jt400PgmCallException(String message) { <nl> + super(message) ; <nl> + } <nl> + } <nl> mmm Jt400PgmProducer . java <nl> ppp Jt400PgmProducer . java <nl> - private static final Logger LOG =  LoggerFactory . getLogger(Jt400PgmProducer . class) ; <nl> + private static final Logger LOG = LoggerFactory . getLogger(Jt400PgmProducer . class) ; <nl> - return (Jt400PgmEndpoint)super . getEndpoint() ; <nl> + return (Jt400PgmEndpoint) super . getEndpoint() ; <nl> - + ' authenticatin with the user ' + iSeries . getUserId() + ') ; <nl> + ' authentication with the user ' iSeries . getUserId() ') ; <nl> - LOG . trace(Executed PGM ' + commandStr + ' in host ' + iSeries . getSystemName() + ' .  Success? <nl> - + result) ; <nl> + LOG . trace(Executed PGM ' commandStr ' in host ' iSeries . getSystemName() ' .  Success?  result) ; <nl> - handleMessages(pgmCall) ; <nl> + throw new Jt400PgmCallException(getOutputMessages(pgmCall)) ; <nl> - String[] params = (String[])body ; <nl> + String[] params = (String[]) body ; <nl> - String value = (String)param ; <nl> + String value = (String) param ; <nl> - private void handlePGMOutput(Exchange exchange, ProgramCall pgmCall, ProgramParameter[] inputs) <nl> - throws InvalidPayloadException { <nl> + private void handlePGMOutput(Exchange exchange, ProgramCall pgmCall, ProgramParameter[] inputs) throws InvalidPayloadException { <nl> - String[] params = (String[])bodyIN ; <nl> + String[] params = (String[]) bodyIN ; <nl> - length = pgmParam . getOutputDataLength() ; <nl> - value = (String)text . toObject(output) ; <nl> + value = (String) text . toObject(output) ; <nl> - private void handleMessages(ProgramCall pgmCall) throws Exception { <nl> + private String getOutputMessages(ProgramCall pgmCall) throws Exception { <nl> + StringBuilder outputMsg = new StringBuilder() ; <nl> - if (LOG . isDebugEnabled()) { <nl> - AS400Message[] messageList = pgmCall . getMessageList() ; <nl> - for (int i = 0 ; i < messageList . length ; ++i) { <nl> - messageList[i] . load() ; <nl> - LOG . debug(The message list [ + i + ] + messageList[i] . getText() + , help info:  + messageList[i] . getHelp()) ; <nl> - } <nl> + AS400Message[] messageList = pgmCall . getMessageList() ; <nl> + for (int i = 0 ; i < messageList . length ; ++i) { <nl> + messageList[i] . load() ; <nl> + outputMsg . append(i ) ) ; <nl> + outputMsg . append(messageList[i] . getText()) ; <nl> + outputMsg . append( - ) ; <nl> + outputMsg . append(messageList[i] . getHelp()) ; <nl> + outputMsg . append(\\n) ; <nl> + return outputMsg . toString() ; <nl>",
        "commit_message": "camel-3741 : improve error handle when error during execute program call . thanks to luis santos for patch .",
        "what": "improve error handling when an error occurs during program execution",
        "why": "thanks to Luis Santos for the patch",
        "check": "0"
    },
    {
        "commit_time": "2015-07-23 12:41:47-04:00",
        "diff": "mmm FullDetailsActivity . java <nl> ppp FullDetailsActivity . java <nl> + import tv . emby . embyatv . querying . StdItemQuery ; <nl> - if (mBaseItem . getPeople() != null) { <nl> + if (mBaseItem . getPeople() != null && mBaseItem . getPeople() . length > 0) { <nl> - if (mBaseItem . getPeople() != null) { <nl> + if (mBaseItem . getPeople() != null && mBaseItem . getPeople() . length > 0) { <nl> + case Episode: <nl> + if (mBaseItem . getSeasonId() != null && mBaseItem . getIndexNumber() != null) { <nl> + StdItemQuery nextEpisodes = new StdItemQuery() ; <nl> + nextEpisodes . setParentId(mBaseItem . getSeasonId()) ; <nl> + nextEpisodes . setIncludeItemTypes(new String[]{Episode}) ; <nl> + nextEpisodes . setStartIndex(mBaseItem . getIndexNumber()) ; // query index is zero-based but episode no is not <nl> + nextEpisodes . setLimit(20) ; <nl> + ItemRowAdapter nextAdapter = new ItemRowAdapter(nextEpisodes, 0 , false, true, new CardPresenter(), adapter) ; <nl> + addItemRow(adapter, nextAdapter, 5, Next Episodes) ; <nl> + } <nl> + break ; <nl> mmm ItemQueryResponse . java <nl> ppp ItemQueryResponse . java <nl> + if (i == 0) adapter . removeRow() ; <nl>",
        "commit_message": "added checks for non-empty people list and functionality to query next episodes based on season ID and index number to enhance episode navigation and prevent null reference errors",
        "what": "added checks for non-empty people list and functionality to query next episodes based on season ID and index number",
        "why": "enhance episode navigation and prevent null reference errors",
        "check": "1"
    },
    {
        "commit_time": "2020-10-29 12:43:09+08:00",
        "diff": "mmm JsonFileSystemFormatFactory . java <nl> ppp JsonFileSystemFormatFactory . java <nl> + private static final long serialVersionUID = 1L ; <nl>",
        "commit_message": "[ hotfix ] [ json ] add serialversionuid to jsoninputformat class",
        "what": "add serialversionuid to jsoninputformat class",
        "why": "to improve serialization compatibility",
        "check": "1"
    },
    {
        "commit_time": "2017-06-12 12:05:25+02:00",
        "diff": "mmm PlanBuilder . java <nl> ppp PlanBuilder . java <nl> - public AggregationNode aggregation( <nl> - PlanNode source, <nl> - Map<Symbol, AggregationNode . Aggregation> assignments, <nl> - List<List<Symbol>> groupingSets, <nl> - AggregationNode . Step step, <nl> - Optional<Symbol> hashSymbol, <nl> - Optional<Symbol> groupIdSymbol) <nl> - { <nl> - return new AggregationNode(idAllocator . getNextId(), source, assignments, groupingSets, step, hashSymbol, groupIdSymbol) ; <nl> - } <nl>",
        "commit_message": "drop unused aggregation ( ) from planbuilder",
        "what": "drop unused aggregation from planbuilder",
        "why": "improve code clarity and maintainability",
        "check": "1"
    },
    {
        "commit_time": "2020-12-21 00:10:22+01:00",
        "diff": "mmm KeyManagerFactoryWrapper . java <nl> ppp KeyManagerFactoryWrapper . java <nl> - private static final Provider PROVIDER = new Provider(, 1 . 0, ) { <nl> + private static final Provider PROVIDER = new Provider(, 1 . 0, ) { <nl> mmm TrustManagerFactoryWrapper . java <nl> ppp TrustManagerFactoryWrapper . java <nl> - private static final Provider PROVIDER = new Provider(, 1 . 0, ) { <nl> + private static final Provider PROVIDER = new Provider(, 1 . 0, ) { <nl>",
        "commit_message": "use different constructor for backwards compatibility",
        "what": "use different constructor",
        "why": "for backwards compatibility",
        "check": "1"
    },
    {
        "commit_time": "2011-02-08 14:09:29+00:00",
        "diff": "mmm DbSqlSession . java <nl> ppp DbSqlSession . java <nl> + boolean tablePresent = false ; <nl> - tables = databaseMetaData . getTables(null, null, tableName, JDBC_METADATA_TABLE_TYPES) ; <nl> - return tables . next() ; <nl> + tables = databaseMetaData . getTables(null, null, tableName . toUpperCase(), JDBC_METADATA_TABLE_TYPES) ; <nl> + tablePresent = tables . next() ; <nl> + if(!tablePresent) { <nl> + try { <nl> + tables = databaseMetaData . getTables(null, null, tableName . toLowerCase(), JDBC_METADATA_TABLE_TYPES) ; <nl> + tablePresent = tables . next() ; <nl> + } finally { <nl> + tables . close() ; <nl> + } <nl> + } <nl> + return tablePresent ; <nl>",
        "commit_message": "check if table exists now include uppercase and lowercase-check ( mysql table name case issue )",
        "what": "check if table exists now include uppercase and lowercase-check",
        "why": "mysql table name case issue",
        "check": "1"
    },
    {
        "commit_time": "2019-01-14 10:41:00+08:00",
        "diff": "mmm CpuMeter . java <nl> ppp CpuMeter . java <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + private static final Logger LOGGER = LoggerFactory . getLogger(CpuMeter . class) ; <nl> - allCpuUsage . update() ; <nl> - processCpuUsage . update() ; <nl> + try { <nl> + allCpuUsage . update() ; <nl> + processCpuUsage . update() ; <nl> + } catch (Throwable e) { <nl> + LOGGER . error(Failed to update usage, e) ; <nl> + } <nl> mmm CpuUtils . java <nl> ppp CpuUtils . java <nl> - public static String[] readAndSplitFirstLine(File file) { <nl> - try { <nl> - return Files . asCharSource(file, StandardCharsets . UTF_8) . readFirstLine() . trim() . split(\\\\s+) ; <nl> - } catch (IOException | NullPointerException e) { <nl> - LOGGER . error(String . format(Failed to read file %s, file . getName()), e) ; <nl> - } <nl> - return null ; <nl> + public static String[] readAndSplitFirstLine(File file) throws IOException { <nl> + return Files . asCharSource(file, StandardCharsets . UTF_8) . readFirstLine() . trim() . split(\\\\s+) ; <nl> - public static double readProcSelfBusy() { <nl> + public static double readProcSelfBusy() throws IOException { <nl> - public static double readProcStatTotal() { <nl> + public static double readProcStatTotal() throws IOException { <nl> - public static double readUptimeTotal() { <nl> + public static double readUptimeTotal() throws IOException { <nl> mmm OsCpuUsage . java <nl> ppp OsCpuUsage . java <nl> + import java . io . IOException ; <nl> - public void update() { <nl> + public void update() throws IOException { <nl> - if (stats == null) { <nl> - return ; <nl> - } <nl> - update(stats) ; <nl> - } <nl> - private void update(String[] stats) { <nl> mmm ProcessCpuUsage . java <nl> ppp ProcessCpuUsage . java <nl> + import java . io . IOException ; <nl> - public void update() { <nl> - try { <nl> - double processBusy = CpuUtils . readProcSelfBusy() ; <nl> - double uptime = CpuUtils . readUptimeTotal() ; <nl> - busy . update(processBusy) ; <nl> - total . update(uptime * userHZ * cpuCount) ; <nl> - updateUsage(busy . period, total . period, true) ; <nl> - } catch (Throwable e) { <nl> - LOGGER . error(Failed to update process usage, e) ; <nl> - } <nl> + public void update() throws IOException { <nl> + double processBusy = CpuUtils . readProcSelfBusy() ; <nl> + double uptime = CpuUtils . readUptimeTotal() ; <nl> + busy . update(processBusy) ; <nl> + total . update(uptime * userHZ * cpuCount) ; <nl> + updateUsage(busy . period, total . period, true) ; <nl>",
        "commit_message": "[ scb-1096 ] change the method calculate process cpu rate to same with top : reconstruct exception",
        "what": "change the method calculate process cpu rate to same with top",
        "why": "reconstruct exception",
        "check": "1"
    },
    {
        "commit_time": "2021-01-25 20:54:38+08:00",
        "diff": "mmm NacosCacheHandler . java <nl> ppp NacosCacheHandler . java <nl> + LISTENERS . computeIfAbsent(dataId, key -> new ArrayList<>()) . add(listener) ; <nl>",
        "commit_message": "added a listener to the LISTENERS map for a specific dataId in NacosCacheHandler to ensure that listeners can be registered and notified of changes associated with the dataId",
        "what": "added a listener to the LISTENERS map for a specific dataId in NacosCacheHandler",
        "why": "ensure that listeners can be registered and notified of changes associated with the dataId",
        "check": "1"
    },
    {
        "commit_time": "2018-02-28 16:03:29+08:00",
        "diff": "mmm AbstractTransactionActuator . java <nl> ppp AbstractTransactionActuator . java <nl> - import org . tron . core . db . TronDatabase ; <nl> + import org . tron . core . db . Manager ; <nl> - protected TronDatabase tronDatabase ; <nl> + protected Manager dbManager ; <nl> - AbstractTransactionActuator(TransactionCapsule transactionCapsule, TronDatabase tronDatabase) { <nl> + AbstractTransactionActuator(TransactionCapsule transactionCapsule, Manager dbManager) { <nl> + this . dbManager = dbManager ; <nl> mmm ActuatorFactory . java <nl> ppp ActuatorFactory . java <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + private static final Logger logger = LoggerFactory . getLogger(ActuatorFactory) ; <nl> + logger . info(transactionCapsule or Transaction is null) ; <nl> + return null ; <nl> + } <nl> + if (null == manager) { <nl> + logger . info(manager is null) ; <nl> - return new TransactionVoteActuator(transactionCapsule, manager . getWitnessStore()) ; <nl> + return new TransactionVoteActuator(transactionCapsule, manager) ; <nl> mmm TransactionCreateAccountActuator . java <nl> ppp TransactionCreateAccountActuator . java <nl> - import org . tron . core . db . TronDatabase ; <nl> + import org . tron . core . db . Manager ; <nl> - TronDatabase tronDatabase) { <nl> - super(transactionCapsule, tronDatabase) ; <nl> + Manager dbManager) { <nl> + super(transactionCapsule, dbManager) ; <nl> mmm TransactionTransferActuator . java <nl> ppp TransactionTransferActuator . java <nl> - import org . tron . core . db . TronDatabase ; <nl> + import org . tron . core . db . Manager ; <nl> - TronDatabase tronDatabase) { <nl> - super(transactionCapsule, tronDatabase) ; <nl> + Manager dbManager) { <nl> + super(transactionCapsule, dbManager) ; <nl> mmm TransactionVoteActuator . java <nl> ppp TransactionVoteActuator . java <nl> - import org . tron . core . db . TronDatabase ; <nl> - import org . tron . core . db . WitnessStore ; <nl> + import org . tron . core . db . Manager ; <nl> - TronDatabase tronDatabase) { <nl> - super(transactionCapsule, tronDatabase) ; <nl> + Manager dbManager) { <nl> + super(transactionCapsule, dbManager) ; <nl> - if (tronDatabase instanceof WitnessStore) { <nl> - ((WitnessStore) tronDatabase) . countvoteWitness(voteAddress, voteAdd) ; <nl> + if (null != dbManager) { <nl> + dbManager . getWitnessStore() . countvoteWitness(voteAddress, voteAdd) ; <nl>",
        "commit_message": "replaced TronDatabase with Manager in multiple transaction actuator classes to standardize database management across transaction processing components",
        "what": "replaced TronDatabase with Manager in multiple transaction actuator classes",
        "why": "standardize database management across transaction processing components",
        "check": "1"
    },
    {
        "commit_time": "2016-06-23 08:03:11-07:00",
        "diff": "mmm ImplicitColumnExplorer . java <nl> ppp ImplicitColumnExplorer . java <nl> - if (tableColumns . size() == 0) { <nl> - tableColumns . add(AbstractRecordReader . STAR_COLUMN) ; <nl> - } <nl> mmm EasyFormatPlugin . java <nl> ppp EasyFormatPlugin . java <nl> + import org . apache . drill . exec . store . AbstractRecordReader ; <nl> + List<SchemaPath> tableColumns = <nl> + columnExplorer . getTableColumns() . size() == 0 ? <nl> + Lists . <SchemaPath>newArrayList(AbstractRecordReader . STAR_COLUMN) : columnExplorer . getTableColumns() ; <nl> - columnExplorer . getTableColumns(), scan . getSelectionRoot()) ; <nl> + tableColumns, scan . getSelectionRoot()) ; <nl> mmm TestImplicitFileColumns . java <nl> ppp TestImplicitFileColumns . java <nl> + import org . apache . drill . common . util . TestTools ; <nl> + @Test // DRILL-4733 <nl> + public void testMultilevelParquetWithSchemaChange() throws Exception { <nl> + try { <nl> + test(alter session set planner . enable_decimal_data_type = true) ; <nl> + testBuilder() <nl> +  . sqlQuery(String . format(select max(dir0) as max_dir from dfs_test . %s/src/test/resources/multilevel/parquetWithSchemaChange, <nl> + TestTools . getWorkingPath())) <nl> +  . unOrdered() <nl> +  . baselineColumns(max_dir) <nl> +  . baselineValues(voter50) <nl> +  . go() ; <nl> + } finally { <nl> + test(alter session set planner . enable_decimal_data_type = false) ; <nl> + } <nl> + } <nl>",
        "commit_message": "updated handling of table columns to ensure the default column is added when none exist to improves robustness in column retrieval and management",
        "what": "updated handling of table columns to ensure the default column is added when none exist",
        "why": "improves robustness in column retrieval and management",
        "check": "1"
    },
    {
        "commit_time": "2014-01-01 20:18:01-06:00",
        "diff": "mmm PrefFragment . java <nl> ppp PrefFragment . java <nl> - nightMode . setSummary(getTime(sharedPrefs . getInt(night_start_hour, 22), sharedPrefs . getInt(night_start_min, 0), sharedPrefs . getBoolean(military_time, false)) + <nl> -   + <nl> - getTime(sharedPrefs . getInt(day_start_hour, 6), sharedPrefs . getInt(day_start_min, 0), sharedPrefs . getBoolean(military_time, false))) ; <nl> + if (sharedPrefs . getBoolean(night_mode, false)) { <nl> + nightMode . setSummary(getTime(sharedPrefs . getInt(night_start_hour, 22), sharedPrefs . getInt(night_start_min, 0), sharedPrefs . getBoolean(military_time, false)) + <nl> +  -  + <nl> + getTime(sharedPrefs . getInt(day_start_hour, 6), sharedPrefs . getInt(day_start_min, 0), sharedPrefs . getBoolean(military_time, false))) ; <nl> + } else { <nl> + nightMode . setSummary() ; <nl> + } <nl> - quietHours . setSummary(getTime(sharedPrefs . getInt(quiet_start_hour, 22), sharedPrefs . getInt(quiet_start_min, 0), sharedPrefs . getBoolean(military_time, false)) + <nl> -   + <nl> - getTime(sharedPrefs . getInt(quiet_end_hour, 6), sharedPrefs . getInt(quiet_end_min, 0), sharedPrefs . getBoolean(military_time, false))) ; <nl> + if(sharedPrefs . getBoolean(quiet_hours, false)) { <nl> + quietHours . setSummary(getTime(sharedPrefs . getInt(quiet_start_hour, 22), sharedPrefs . getInt(quiet_start_min, 0), sharedPrefs . getBoolean(military_time, false)) + <nl> +  -  + <nl> + getTime(sharedPrefs . getInt(quiet_end_hour, 6), sharedPrefs . getInt(quiet_end_min, 0), sharedPrefs . getBoolean(military_time, false))) ; <nl> + } else { <nl> + quietHours . setSummary() ; <nl> + } <nl>",
        "commit_message": "Added conditional logic to set summaries for night mode and quiet hours based on user preferences to Improve user experience by dynamically showing or hiding time summaries based on night mode and quiet hours settings",
        "what": "Added conditional logic to set summaries for night mode and quiet hours based on user preferences",
        "why": "Improve user experience by dynamically showing or hiding time summaries based on night mode and quiet hours settings",
        "check": "1"
    },
    {
        "commit_time": "2012-12-06 10:19:21-05:00",
        "diff": "mmm OAuth2AccessTokenEntity . java <nl> ppp OAuth2AccessTokenEntity . java <nl> + import javax . persistence . CascadeType ; <nl> + import javax . persistence . OneToOne ; <nl> - private IdToken idToken ; // JWT-encoded OpenID Connect IdToken <nl> + private OAuth2AccessTokenEntity idToken ; // JWT-encoded OpenID Connect IdToken <nl> - @Transient <nl> - public IdToken getIdToken() { <nl> + @OneToOne(cascade=CascadeType . ALL) // one-to-one mapping for now <nl> + @JoinColumn(name = id_token_id) <nl> + public OAuth2AccessTokenEntity getIdToken() { <nl> - public void setIdToken(IdToken idToken) { <nl> + public void setIdToken(OAuth2AccessTokenEntity idToken) { <nl> - @Basic <nl> - @Column(name=id_token_string) <nl> + @Transient <nl> - return idToken . toString() ; <nl> + return idToken . getValue() ; // get the JWT string value of the id token entity <nl> - public void setIdTokenString(String idTokenString) { <nl> - this . idToken = IdToken . parse(idTokenString) ; <nl> - } <nl> mmm ConnectTokenEnhancer . java <nl> ppp ConnectTokenEnhancer . java <nl> + OAuth2AccessTokenEntity idTokenEntity = new OAuth2AccessTokenEntity() ; <nl> + idTokenEntity . setExpiration(expiration) ; <nl> - token . setIdToken(idToken) ; <nl> + idTokenEntity . setJwt(idToken) ; <nl> + idTokenEntity . setAuthenticationHolder(token . getAuthenticationHolder()) ; <nl> + idTokenEntity . setScope(token . getScope()) ; <nl> + token . setIdToken(idTokenEntity) ; <nl>",
        "commit_message": "replace IdToken with OAuth2AccessTokenEntity for idToken representation and implement a one-to-one mapping to enhance the integration of OpenID Connect tokens within the OAuth2 access token entity",
        "what": "replace IdToken with OAuth2AccessTokenEntity for idToken representation and implement a one-to-one mapping",
        "why": "enhance the integration of OpenID Connect tokens within the OAuth2 access token entity",
        "check": "1"
    },
    {
        "commit_time": "2020-05-13 20:31:17-07:00",
        "diff": "mmm BenchmarkQueryEngine . java <nl> ppp BenchmarkQueryEngine . java <nl> + import org . apache . pinot . controller . api . resources . ControllerFilePathProvider ; <nl> + ControllerFilePathProvider . init(_perfBenchmarkDriver . getControllerConf()) ; <nl> mmm PerfBenchmarkDriver . java <nl> ppp PerfBenchmarkDriver . java <nl> - private ControllerConf getControllerConf() { <nl> + public ControllerConf getControllerConf() { <nl> mmm PerfBenchmarkRunner . java <nl> ppp PerfBenchmarkRunner . java <nl> + import org . apache . pinot . controller . api . resources . ControllerFilePathProvider ; <nl> + ControllerFilePathProvider . init(driver . getControllerConf()) ; <nl>",
        "commit_message": "initialize controllerfilepathprovider in perfbenchmarkdriver ( # 5383 )",
        "what": "initialize controllerfilepathprovider in perfbenchmarkdriver",
        "why": "part of issue #5383",
        "check": "1"
    },
    {
        "commit_time": "2016-10-05 18:23:40+03:30",
        "diff": "mmm SpnegoNegociateCredentialsAction . java <nl> ppp SpnegoNegociateCredentialsAction . java <nl> + } else { <nl> + LOGGER . debug(Mixed-mode authentication is enabled) ; <nl>",
        "commit_message": "sanitize error view to handle protocol failure event correctly",
        "what": "sanitize error view",
        "why": "to handle protocol failure event correctly",
        "check": "1"
    },
    {
        "commit_time": "2024-01-24 21:53:43+08:00",
        "diff": "mmm JarRunHandler . java <nl> ppp JarRunHandler . java <nl> + if (restoreMode . equals(RestoreMode . LEGACY)) { <nl> + log . warn( <nl> + The {} restore mode is deprecated, please use {} or {} mode instead . , <nl> + RestoreMode . LEGACY, <nl> + RestoreMode . CLAIM, <nl> + RestoreMode . NO_CLAIM) ; <nl> + } <nl>",
        "commit_message": "[ flink-34190 ] [ checkpoint ] [ rest ] deprecation message of restoremode # legacy in rest api",
        "what": "deprecation message of restoremode # legacy in rest api",
        "why": "related to flink-34190 and checkpoint adjustments",
        "check": "1"
    },
    {
        "commit_time": "2023-06-14 16:37:22+02:00",
        "diff": "mmm UngroupedAggregateRegionScanner . java <nl> ppp UngroupedAggregateRegionScanner . java <nl> + private byte[] emptyCQ = null ; <nl> + emptyCQ = scan . getAttribute(BaseScannerRegionObserver . EMPTY_COLUMN_QUALIFIER) ; <nl> + if (emptyCF != null && emptyCQ == null) { <nl> + emptyCQ = QueryConstants . EMPTY_COLUMN_BYTES ; <nl> + } <nl> - put . addColumn(emptyCF, QueryConstants . EMPTY_COLUMN_BYTES, kvts, <nl> - ByteUtil . EMPTY_BYTE_ARRAY) ; <nl> + put . addColumn(emptyCF, emptyCQ, kvts, <nl> + QueryConstants . EMPTY_COLUMN_VALUE_BYTES) ; <nl>",
        "commit_message": "added handling for empty column qualifiers in UngroupedAggregateRegionScanner to ensure correct column insertion when no specific qualifier is provided",
        "what": "added handling for empty column qualifiers in UngroupedAggregateRegionScanner",
        "why": "ensure correct column insertion when no specific qualifier is provided",
        "check": "1"
    },
    {
        "commit_time": "2014-06-17 16:54:42-05:00",
        "diff": "mmm LdapAuthenticationProviderConfigurer . java <nl> ppp LdapAuthenticationProviderConfigurer . java <nl> + import java . io . IOException ; <nl> + import java . net . ServerSocket ; <nl> - private int port = 33389 ; <nl> + private Integer port ; <nl> + private static final int DEFAULT_PORT = 33389 ; <nl> - apacheDsContainer . setPort(port) ; <nl> + apacheDsContainer . setPort(getPort()) ; <nl> + private int getPort() { <nl> + if(port == null) { <nl> + port = getDefaultPort() ; <nl> + } <nl> + return port ; <nl> + } <nl> + private int getDefaultPort() { <nl> + ServerSocket serverSocket = null ; <nl> + try { <nl> + try { <nl> + serverSocket = new ServerSocket(DEFAULT_PORT) ; <nl> + } catch (IOException e) { <nl> + try { <nl> + serverSocket = new ServerSocket(0) ; <nl> + } catch(IOException e2) { <nl> + return DEFAULT_PORT ; <nl> + } <nl> + } <nl> + return serverSocket . getLocalPort() ; <nl> + } finally { <nl> + if(serverSocket != null) { <nl> + try { <nl> + serverSocket . close() ; <nl> + } catch (IOException e) {} <nl> + } <nl> + } <nl> + } <nl> - return ldap://127 . 0 . 0 . 1: + port + / + root ; <nl> + return ldap://127 . 0 . 0 . 1: getPort() / root ; <nl>",
        "commit_message": "refactor port management by introducing a method to handle default port configuration to improve flexibility by allowing dynamic port assignment while maintaining a default fallback",
        "what": "refactor port management by introducing a method to handle default port configuration",
        "why": "improve flexibility by allowing dynamic port assignment while maintaining a default fallback",
        "check": "1"
    },
    {
        "commit_time": "2017-06-20 06:10:59-07:00",
        "diff": "mmm FrontendOptions . java <nl> ppp FrontendOptions . java <nl> - import java . util . Set ; <nl> - private static final Set<String> VALID_JAVA_VERSIONS = <nl> + private static final ImmutableSet<String> VALID_JAVA_VERSIONS = <nl>",
        "commit_message": "replace constant ( static final constant_case ) declaration type which use the general collection interface ( e.g . list ) with an immutable type ( e.g . immutablelist ) .",
        "what": "replace constant (static final constant_case) declaration type which use the general collection interface (e.g. list) with an immutable type (e.g. immutablelist)",
        "why": "improve code safety and ensure immutability of collections",
        "check": "1"
    },
    {
        "commit_time": "2014-02-07 14:06:53+01:00",
        "diff": "mmm GraphicsAwareDpiRescaleStyleVisitor . java <nl> ppp GraphicsAwareDpiRescaleStyleVisitor . java <nl> - class GraphicsAwareDpiRescaleStyleVisitor extends DpiRescaleStyleVisitor { <nl> + public class GraphicsAwareDpiRescaleStyleVisitor extends DpiRescaleStyleVisitor { <nl>",
        "commit_message": "make the class visible for more accurate meta buffer estimation",
        "what": "make the class visible",
        "why": "for more accurate meta buffer estimation",
        "check": "1"
    },
    {
        "commit_time": "2022-02-22 10:51:25+00:00",
        "diff": "mmm VideoTranscodingSamplePipeline . java <nl> ppp VideoTranscodingSamplePipeline . java <nl> - if (SDK_INT >= 29) { <nl> + if (SDK_INT >= 29 <nl> + && !((samsung . equals(Util . MANUFACTURER) || OnePlus . equals(Util . MANUFACTURER)) <nl> + && SDK_INT < 31)) { <nl>",
        "commit_message": "transformer : work around samsung/oneplus decoder dequeuebuffer fail .",
        "what": "work around samsung/oneplus decoder dequeuebuffer fail",
        "why": "to address an issue with video decoding on specific devices",
        "check": "1"
    },
    {
        "commit_time": "2016-06-09 15:08:54+03:00",
        "diff": "mmm JEditorPane . java <nl> ppp JEditorPane . java <nl> - ClassLoader loader = getKitLoaderRegistry() . get(type) . orElse(null) ; <nl> + ClassLoader loader = getKitLoaderRegistry() . get(type) ; <nl> - getKitLoaderRegistry() . put(type, Optional . ofNullable(loader)) ; <nl> + if (loader != null) { <nl> + getKitLoaderRegistry() . put(type, loader) ; <nl> + } else { <nl> + getKitLoaderRegistry() . remove(type) ; <nl> + } <nl> - private static Hashtable<String, Optional<ClassLoader>> getKitLoaderRegistry() { <nl> + private static Hashtable<String, ClassLoader> getKitLoaderRegistry() { <nl> new file <nl> ppp bug8158734 . java <nl> + import javax . swing . * ; <nl> + import javax . swing . text . * ; <nl> + import java . io . * ; <nl> + import java . lang . reflect . InvocationTargetException ; <nl> + public class bug8158734 { <nl> + public static final String TYPE = test/test ; <nl> + public static final String TYPE_2 = test2/test2 ; <nl> + static boolean myClassloaderWasUsed = false ; <nl> + static class MyEditorKit extends EditorKit { <nl> + @Override <nl> + public String getContentType() { <nl> + return null ; <nl> + } <nl> + @Override <nl> + public ViewFactory getViewFactory() { <nl> + return null ; <nl> + } <nl> + @Override <nl> + public Action[] getActions() { <nl> + return new Action[0] ; <nl> + } <nl> + @Override <nl> + public Caret createCaret() { <nl> + return null ; <nl> + } <nl> + @Override <nl> + public Document createDefaultDocument() { <nl> + return null ; <nl> + } <nl> + @Override <nl> + public void read(InputStream in, Document doc, int pos) throws IOException, BadLocationException { <nl> + } <nl> + @Override <nl> + public void write(OutputStream out, Document doc, int pos, int len) throws IOException, BadLocationException { <nl> + } <nl> + @Override <nl> + public void read(Reader in, Document doc, int pos) throws IOException, BadLocationException { <nl> + } <nl> + @Override <nl> + public void write(Writer out, Document doc, int pos, int len) throws IOException, BadLocationException { <nl> + } <nl> + } <nl> + static class MyClassloader extends ClassLoader { <nl> + @Override <nl> + public Class<?> loadClass(String name) throws ClassNotFoundException { <nl> + myClassloaderWasUsed = true ; <nl> + return super . loadClass(name) ; <nl> + } <nl> + } <nl> + public static void main(String[] args) throws InvocationTargetException, InterruptedException { <nl> + SwingUtilities . invokeAndWait(new Runnable() { <nl> + @Override <nl> + public void run() { <nl> + JEditorPane c = new JEditorPane() ; <nl> + c . setContentType(TYPE) ; <nl> + final MyClassloader loader = new MyClassloader() ; <nl> + JEditorPane . registerEditorKitForContentType(TYPE_2, MyEditorKit . class . getName(), loader) ; <nl> + JEditorPane . registerEditorKitForContentType(TYPE_2, MyEditorKit . class . getName(), null) ; <nl> + JEditorPane . createEditorKitForContentType(TYPE_2) ; <nl> + if (myClassloaderWasUsed) { <nl> + throw new RuntimeException(Class loader has not been removed for ' TYPE_2 ' type) ; <nl> + } <nl> + } <nl> + }) ; <nl> + } <nl> + } <nl>",
        "commit_message": "modified ClassLoader handling in JEditorPane to eliminate Optional and ensure proper registry management to improve clarity and correctness of ClassLoader registration and retrieval logic",
        "what": "modified ClassLoader handling in JEditorPane to eliminate Optional and ensure proper registry management",
        "why": "improve clarity and correctness of ClassLoader registration and retrieval logic",
        "check": "1"
    },
    {
        "commit_time": "2015-02-13 19:39:03+01:00",
        "diff": "mmm GraphBuilderPhase . java <nl> ppp GraphBuilderPhase . java <nl> - } else { <nl> mmm PartialEvaluationTest . java <nl> ppp PartialEvaluationTest . java <nl> - return truffleCompiler . getPartialEvaluator() . createGraph(compilable, allowAssumptions, null) ; <nl> + return truffleCompiler . getPartialEvaluator() . createGraph(compilable, allowAssumptions, truffleCompiler . createGraphBuilderSuitePlugins()) ; <nl> mmm TruffleCompilerImpl . java <nl> ppp TruffleCompilerImpl . java <nl> + public GraphBuilderPlugins createGraphBuilderSuitePlugins() { <nl> + return this . createGraphBuilderSuite() . plugins ; <nl> + } <nl>",
        "commit_message": "register correct graph builder plugins when test partial evaluation .",
        "what": "register correct graph builder plugins",
        "why": "when test partial evaluation",
        "check": "0"
    },
    {
        "commit_time": "2020-04-21 20:08:44+08:00",
        "diff": "mmm Session . java <nl> ppp Session . java <nl> - private boolean checkIsQuery(String sql) { <nl> - sql = sql . trim() . toLowerCase() ; <nl> - return sql . startsWith(select) || sql . startsWith(show) || sql . startsWith(list) ; <nl> - } <nl> - if (!checkIsQuery(sql)) { <nl> - throw new IllegalArgumentException(your sql \\ + sql <nl> - + \\ is not a query statement, you should use executeNonQueryStatement method instead . ) ; <nl> - } <nl> - if (checkIsQuery(sql)) { <nl> - throw new IllegalArgumentException(your sql \\ + sql <nl> - + \\ is a query statement, you should use executeQueryStatement method instead . ) ; <nl> - } <nl>",
        "commit_message": "added validation for SQL query statements in the Session class to ensure correct execution methods are used based on the type of SQL statement provided",
        "what": "added validation for SQL query statements in the Session class",
        "why": "ensure correct execution methods are used based on the type of SQL statement provided",
        "check": "1"
    },
    {
        "commit_time": "2020-07-18 11:00:42-07:00",
        "diff": "mmm ShadowLinuxTest . java <nl> ppp ShadowLinuxTest . java <nl> - path = /tmp/test . txt ; <nl> - file = new File(path) ; <nl> + file = File . createTempFile(ShadowLinuxTest, null) ; <nl> + path = file . getAbsolutePath() ; <nl> mmm ShadowPosixTest . java <nl> ppp ShadowPosixTest . java <nl> - path = /tmp/test . txt ; <nl> - file = new File(path) ; <nl> + file = File . createTempFile(ShadowPosixTest, null) ; <nl> + path = file . getAbsolutePath() ; <nl>",
        "commit_message": "attempt to deflake shadowposixtest on circleci",
        "what": "attempt to deflake shadowposixtest",
        "why": "on circleci",
        "check": "0"
    },
    {
        "commit_time": "2014-09-22 15:17:18-07:00",
        "diff": "mmm AutoInstallsLayout . java <nl> ppp AutoInstallsLayout . java <nl> - } catch (XmlPullParserException | IOException | RuntimeException e) { <nl> + } catch (Exception e) { <nl> mmm BubbleTextView . java <nl> ppp BubbleTextView . java <nl> - private static SparseArray<Theme> sPreloaderThemes = new SparseArray<>(2) ; <nl> + private static SparseArray<Theme> sPreloaderThemes = new SparseArray<Theme>(2) ; <nl> mmm WidgetPreviewLoader . java <nl> ppp WidgetPreviewLoader . java <nl> - private final HashMap<String, WeakReference<Bitmap>> mLoadedPreviews = new HashMap<>() ; <nl> - private final ArrayList<SoftReference<Bitmap>> mUnusedBitmaps = new ArrayList<>() ; <nl> + private final HashMap<String, WeakReference<Bitmap>> mLoadedPreviews = new HashMap<String, WeakReference<Bitmap>>() ; <nl> + private final ArrayList<SoftReference<Bitmap>> mUnusedBitmaps = new ArrayList<SoftReference<Bitmap>>() ; <nl>",
        "commit_message": "updated exception handling to catch a broader range of exceptions, and fixed generic type declarations for collections to improve error handling and enhance code clarity by using explicit generic types",
        "what": "updated exception handling to catch a broader range of exceptions, and fixed generic type declarations for collections",
        "why": "improve error handling and enhance code clarity by using explicit generic types",
        "check": "1"
    },
    {
        "commit_time": "2013-03-22 16:10:01+01:00",
        "diff": "new file <nl> ppp TestMetaspaceMemoryPools . java <nl> + import java . util . List ; <nl> + import java . lang . management . ManagementFactory ; <nl> + import java . lang . management . MemoryManagerMXBean ; <nl> + import java . lang . management . MemoryPoolMXBean ; <nl> + import java . lang . management . MemoryUsage ; <nl> + public class TestMetaspaceMemoryPools { <nl> + public static void main(String[] args) { <nl> + boolean isClassMetaspaceMaxDefined = args[0] . equals(defined) ; <nl> + boolean isMetaspaceMaxDefined = args[1] . equals(defined) ; <nl> + verifyThatMetaspaceMemoryManagerExists() ; <nl> + verifyMemoryPool(getMemoryPool(Class Metaspace), isClassMetaspaceMaxDefined) ; <nl> + verifyMemoryPool(getMemoryPool(Metaspace), isMetaspaceMaxDefined) ; <nl> + } <nl> + private static void verifyThatMetaspaceMemoryManagerExists() { <nl> + List<MemoryManagerMXBean> managers = ManagementFactory . getMemoryManagerMXBeans() ; <nl> + for (MemoryManagerMXBean manager : managers) { <nl> + if (manager . getName() . equals(MetaspaceManager)) { <nl> + return ; <nl> + } <nl> + } <nl> + throw new RuntimeException(Expected to find a metaspace memory manager) ; <nl> + } <nl> + private static MemoryPoolMXBean getMemoryPool(String name) { <nl> + List<MemoryPoolMXBean> pools = ManagementFactory . getMemoryPoolMXBeans() ; <nl> + for (MemoryPoolMXBean pool : pools) { <nl> + if (pool . getName() . equals(name)) { <nl> + return pool ; <nl> + } <nl> + } <nl> + throw new RuntimeException(Expected to find a memory pool with name  name) ; <nl> + } <nl> + private static void verifyMemoryPool(MemoryPoolMXBean pool, boolean isMaxDefined) { <nl> + MemoryUsage mu = pool . getUsage() ; <nl> + assertDefined(mu . getInit(), init) ; <nl> + assertDefined(mu . getUsed(), used) ; <nl> + assertDefined(mu . getCommitted(), committed) ; <nl> + if (isMaxDefined) { <nl> + assertDefined(mu . getMax(), max) ; <nl> + } else { <nl> + assertUndefined(mu . getMax(), max) ; <nl> + } <nl> + } <nl> + private static void assertDefined(long value, String name) { <nl> + assertTrue(value != -1, Expected  name  to be defined) ; <nl> + } <nl> + private static void assertUndefined(long value, String name) { <nl> + assertTrue(value == -1, Expected  name  to be undefined) ; <nl> + } <nl> + private static void assertTrue(boolean condition, String msg) { <nl> + if (!condition) { <nl> + throw new RuntimeException(msg) ; <nl> + } <nl> + } <nl> + } <nl>",
        "commit_message": "added a new file TestMetaspaceMemoryPools.java to check Metaspace memory management to ensure that the Metaspace memory manager and memory pools are correctly defined and utilized",
        "what": "added a new file TestMetaspaceMemoryPools.java to check Metaspace memory management",
        "why": "ensure that the Metaspace memory manager and memory pools are correctly defined and utilized",
        "check": "1"
    },
    {
        "commit_time": "2021-07-13 17:05:57-07:00",
        "diff": "mmm Java11ParserVisitor . java <nl> ppp Java11ParserVisitor . java <nl> - if (skipIfPresent(var)) { <nl> - typeExpr = new J . VarType(randomId(), Space . EMPTY, Markers . EMPTY, type(vartype)) ; <nl> + if((node . sym . flags() & Flags . PARAMETER) > 0) { <nl> + typeExpr = null ; <nl> - typeExpr = null ; // this is a lambda parameter with an inferred type expression <nl> + skip(var) ; <nl> + typeExpr = new J . VarType(randomId(), Space . EMPTY, Markers . EMPTY, type(vartype)) ; <nl> - private boolean skipIfPresent(String token) { <nl> - if (source . startsWith(token, cursor)) { <nl> - cursor += token . length() ; <nl> - return true ; <nl> - } <nl> - return false ; <nl> - } <nl>",
        "commit_message": "problem parse lambda parameter whose name start with 'var ' ( fix # 771 )",
        "what": "problem parse lambda parameter whose name start with 'var '",
        "why": "fix # 771",
        "check": "1"
    },
    {
        "commit_time": "2009-03-17 16:06:14+03:00",
        "diff": "mmm WindowsFileChooserUI . java <nl> ppp WindowsFileChooserUI . java <nl> + import java . security . AccessController ; <nl> + import java . security . PrivilegedAction ; <nl> - baseFolders = (File[])ShellFolder . get(fileChooserComboBoxFolders) ; <nl> + baseFolders = AccessController . doPrivileged(new PrivilegedAction<File[]>() { <nl> + public File[] run() { <nl> + return (File[]) ShellFolder . get(fileChooserComboBoxFolders) ; <nl> + } <nl> + }) ; <nl> mmm MetalFileChooserUI . java <nl> ppp MetalFileChooserUI . java <nl> + import java . security . AccessController ; <nl> + import java . security . PrivilegedAction ; <nl> - baseFolders = (File[])ShellFolder . get(fileChooserComboBoxFolders) ; <nl> + baseFolders = AccessController . doPrivileged(new PrivilegedAction<File[]>() { <nl> + public File[] run() { <nl> + return (File[]) ShellFolder . get(fileChooserComboBoxFolders) ; <nl> + } <nl> + }) ; <nl> mmm SynthFileChooserUIImpl . java <nl> ppp SynthFileChooserUIImpl . java <nl> + import java . security . AccessController ; <nl> + import java . security . PrivilegedAction ; <nl> - baseFolders = (File[])ShellFolder . get(fileChooserComboBoxFolders) ; <nl> + baseFolders = AccessController . doPrivileged(new PrivilegedAction<File[]>() { <nl> + public File[] run() { <nl> + return (File[]) ShellFolder . get(fileChooserComboBoxFolders) ; <nl> + } <nl> + }) ; <nl> new file <nl> ppp bug6738668 . java <nl> + import javax . swing . * ; <nl> + import java . io . File ; <nl> + public class bug6738668 { <nl> + public static void main(String[] args) throws Exception { <nl> + for (UIManager . LookAndFeelInfo lookAndFeelInfo : UIManager . getInstalledLookAndFeels()) { <nl> + UIManager . setLookAndFeel(lookAndFeelInfo . getClassName()) ; <nl> + new JFileChooser(new File(c:/temp)) ; <nl> + System . out . println(Test passed for LookAndFeel  lookAndFeelInfo . getClassName()) ; <nl> + } <nl> + } <nl> + } <nl>",
        "commit_message": "refactor file chooser initialization to use AccessController for enhanced security to ensure that file system access respects security policies",
        "what": "refactor file chooser initialization to use AccessController for enhanced security",
        "why": "ensure that file system access respects security policies",
        "check": "1"
    },
    {
        "commit_time": "2011-02-03 09:36:28+00:00",
        "diff": "mmm Attr . java <nl> ppp Attr . java <nl> - if (operator . kind == MTH) { <nl> + if (operator . kind == MTH && <nl> + !owntype . isErroneous() && <nl> + !operand . isErroneous()) { <nl> - if (operator . kind == MTH) { <nl> + if (operator . kind == MTH && <nl> + !argtype . isErroneous()) { <nl> - if (operator . kind == MTH) { <nl> + if (operator . kind == MTH && <nl> + !left . isErroneous() && <nl> + !right . isErroneous()) { <nl> mmm Check . java <nl> ppp Check . java <nl> - operator . cant . be . applied, <nl> + operator . cant . be . applied . 1, <nl> - List . of(left, right)) ; <nl> + left, right) ; <nl> mmm Resolve . java <nl> ppp Resolve . java <nl> - return diags . create(dkind, log . currentSource(), <nl> - pos, operator . cant . be . applied, name, argtypes) ; <nl> + boolean isUnaryOp = argtypes . size() == 1 ; <nl> + String key = argtypes . size() == 1 ? <nl> + operator . cant . be . applied : <nl> + operator . cant . be . applied . 1 ; <nl> + Type first = argtypes . head ; <nl> + Type second = !isUnaryOp ? argtypes . tail . head : null ; <nl> + return diags . create(dkind, log . currentSource(), pos, <nl> + key, name, first, second) ; <nl> new file <nl> ppp T5017953 . java <nl> + class T5017953 { <nl> + int f = 0 ; <nl> + void test(int i) {} <nl> + {   test(NonExistentClass . f ++) ; <nl> + test(1 NonExistentClass . f) ; <nl> + test(NonExistentClass . f 1) ; <nl> + test(NonExistentClass . f NonExistentClass . f) ; <nl> + test(NonExistentClass . f += 1) ; <nl> + test(f += NonExistentClass . f) ; <nl> + } <nl> + } <nl>",
        "commit_message": "updated conditional checks for operator validity to ensure correctness by adding error handling for operands to improve robustness in operator application and diagnostics reporting",
        "what": "updated conditional checks for operator validity to ensure correctness by adding error handling for operands",
        "why": "improve robustness in operator application and diagnostics reporting",
        "check": "1"
    },
    {
        "commit_time": "2012-03-16 13:58:08+03:00",
        "diff": "mmm CFMetaData . java <nl> ppp CFMetaData . java <nl> +  . caching(Caching . NONE) <nl> mmm ColumnFamilyStore . java <nl> ppp ColumnFamilyStore . java <nl> + import static org . apache . cassandra . config . CFMetaData . Caching ; <nl> - private ColumnFamilyStore(Table table, String columnFamilyName, IPartitioner partitioner, int generation, CFMetaData metadata, Directories directories) <nl> + private ColumnFamilyStore(Table table, <nl> + String columnFamilyName, <nl> + IPartitioner partitioner, <nl> + int generation, <nl> + CFMetaData metadata, <nl> + Directories directories) <nl> + Caching caching = metadata . getCaching() ; <nl> - Set<DecoratedKey> savedKeys = CacheService . instance . keyCache . readSaved(table . name, columnFamily) ; <nl> + Set<DecoratedKey> savedKeys = caching == Caching . NONE || caching == Caching . ROWS_ONLY <nl> + ? Collections . <DecoratedKey>emptySet() <nl> + : CacheService . instance . keyCache . readSaved(table . name, columnFamily) ; <nl> - public static synchronized ColumnFamilyStore createColumnFamilyStore(Table table, String columnFamily, IPartitioner partitioner, CFMetaData metadata) <nl> + public static synchronized ColumnFamilyStore createColumnFamilyStore(Table table, <nl> + String columnFamily, <nl> + IPartitioner partitioner, <nl> + CFMetaData metadata) <nl> - return !(metadata . getCaching() == CFMetaData . Caching . NONE <nl> - || metadata . getCaching() == CFMetaData . Caching . KEYS_ONLY <nl> + return !(metadata . getCaching() == Caching . NONE <nl> + || metadata . getCaching() == Caching . KEYS_ONLY <nl>",
        "commit_message": "skip read save key cache if cf 's caching strategy be none or rows_only",
        "what": "skip read save key cache if cf's caching strategy be none or rows_only",
        "why": "prevent unnecessary reads when caching is not utilized",
        "check": "1"
    },
    {
        "commit_time": "2020-07-23 18:13:43-07:00",
        "diff": "mmm CliDriver . java <nl> ppp CliDriver . java <nl> + case '': <nl>",
        "commit_message": "added a case for the '' character in the CliDriver.java file to improve command handling in the CLI interface",
        "what": "added a case for the '' character in the CliDriver.java file",
        "why": "improve command handling in the CLI interface",
        "check": "1"
    }
]